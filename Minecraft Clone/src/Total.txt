"./Client\\Client.cpp"
﻿#include <chrono>

#include "Client.h"
#include "Player/MainPlayer.h"
#include "Profiler/PerformanceProfiler.h"
#include "Render/DebugScreen/DebugScreen.h"
#include "Render/WorldRender.h"
#include "../Core/Options/Option.h"
#include "../Level/Chunk/Block/Blocks.h"
#include "../Level/Item/ItemTextureAtlas.h"
#include "../Level/Entity/Entities.h"
#include "../Level/Timer/Timer.h"
#include "../Level/Server/Server.h"
#include "../Level/Server/Communication/InternalServer.h"
#include "../Level/LevelLoader.h"
#include "../Level/Level.h"
#include "../RenderEngine/ChunkRenderer/TerrainRenderer.h"
#include "../RenderEngine/EntityRenderer/MultiEntityRender.h"
#include "../RenderEngine/EntityRenderer/EntityRenderUpdate.h"
#include "../RenderEngine/GUI/TextRenderer.h"
#include "../RenderEngine/OpenGL/Framebuffer/Framebuffer.h"
#include "../Utils/LogUtils.h"

Client::Client() : 
    server_{ std::make_unique<InternalServer>() },
    terrain_render_{ std::make_unique<WorldRender>() },
    entity_render_{ std::make_unique<MultiEntityRenderer>() },
    entity_updater_{ std::make_unique<EntityRendererUpdater>() },
    framebuffer_{ std::make_unique<TexturedFrameBuffer>() },
    text_render_{ std::make_unique<TextRenderer>() },
    debug_screen_{ std::make_unique<DebugScreen>() },
    main_player_{ std::make_unique<MainPlayer>() },
    profiler_{ new PerformanceProfiler()}
{

}

Client::~Client() = default;

void Client::Initialize() {
    Start();

    g_blocks.Initialize();
    g_entity_list.Initialize();
    entity_render_->Initialize(profiler_);
    entity_render_->SetWindow(GetWindow());
    text_render_->InitializeTextRenderer(GetWindow());
    g_items.RegisterAll();
    g_item_atlas.Initialize(512 * 16 * 2, 16 * 2 * 8);

    for (auto& item : g_items.item_container_) {
        g_item_atlas.AddItem(item.second);
    }

    framebuffer_->GenBuffer(properties_.window_size_x_, properties_.window_size_y_, (float)g_app_options.graphics_scale_, GL_RGB);

    DisableCursor();

    server_->startInternalServer(main_player_->player_.get());

    main_player_->Initialize(GetWindow(), server_.get());
    main_player_->SetPlayerPosition(0., 50, 0.);
    main_player_->SetPlayerRotation(-135.f, -30.);

    entity_updater_->SetEntityRenderer(entity_render_.get(), server_->GetTickClock());

    entity_updater_->Start(server_->server->level_->main_world_.get());

    g_logger.LogInfo("Client::Initialize", "Generating World");
    terrain_render_->Start(GetWindow(), server_.get(), profiler_);
    g_logger.LogInfo("Client::Initialize", "Starting Gameloop");

    debug_screen_->Initialize(GetWindow());
}

void Client::run() {
    Initialize();
    GameLoop();
    Cleanup();
}

void Client::Cleanup() {
    entity_render_->Clean();
    terrain_render_->Stop();
    server_->Stop();
    g_logger.Stop();
    entity_updater_->Stop();
    g_blocks.CleanUp();
    glfwDestroyWindow(GetWindow());
}

void Client::SetDebugScreen() {
    debug_screen_->EditText("Stat1", "VRAM Usage: " + std::to_string((double)terrain_render_->renderer_->getVRAMUsageFull() / 1000000.0) + " MB");
    debug_screen_->EditText("Stat2", "XYZ: " + std::to_string(main_player_->GetEntityProperties().position_.x) + "/" + std::to_string(main_player_->GetEntityProperties().position_.y) + "/" + std::to_string(main_player_->GetEntityProperties().position_.z));
    debug_screen_->EditText("Stat3", "Velocity XYZ: " + std::to_string(main_player_->GetEntityProperties().velocity_.x) + "/" + std::to_string(main_player_->GetEntityProperties().velocity_.y) + "/" + std::to_string(main_player_->GetEntityProperties().velocity_.z));
    debug_screen_->EditText("Stat4", "VRAM Fragmentation Rate: " + std::to_string(terrain_render_->renderer_->getFragmentationRate() * 100) + "%");
    debug_screen_->EditText("Stat5", "FPS: " + std::to_string(1.0 / frametime_));
    debug_screen_->EditText("Stat6", "Mesh Stats (ms) Total/S0/S1/S2: " + std::to_string(terrain_render_->build_time_ / 1000.f) + "/" + std::to_string(terrain_render_->build_stage_0_ / 1000.f) + "/" + std::to_string(terrain_render_->build_stage_1_ / 1000.f) + "/" + std::to_string(terrain_render_->build_stage_2_ / 1000.f));
    debug_screen_->EditText("Stat7", "Lighting Engine Queued: " + std::to_string(server_->server->level_->level_loader_->GetLightEngineQueueSize()));
    debug_screen_->EditText("Stat8", "Event Queue Size: N/A");
    debug_screen_->EditText("Stat9", "Server Tick (MSPT): " + std::to_string(server_->GetMSPT()));
    debug_screen_->EditText("Stat10","Chunk Count: " + std::to_string(server_->GetChunkCount()));
    debug_screen_->Update();
}

void Client::Render() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    framebuffer_->BindFBO();

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (!properties_.draw_solid_)
        RenderLines();

    entity_render_->Render();
    terrain_render_->Render();

    if (!properties_.draw_solid_)
        RenderSolid();

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    framebuffer_->UnbindFBO();

    framebuffer_->Render();

    main_player_->RenderGUIs();
    debug_screen_->Render();
}

void Client::GameLoop() {

    Timer time;

    while (!WindowCloseCheck()) {
        Timer FrametimeTracker;

        Update();

        Render();
        profiler_->ProfileStart("root/refresh");
        Refresh();
        profiler_->ProfileStop("root/refresh");
        frametime_ = FrametimeTracker.GetTimePassed_s();

        inputs_.delta_ = frametime_;

        if (time.GetTimePassed_ms() > 50) {
            SetDebugScreen();
            time.Set();
        }
        
    }
}

void Client::Update() {
    PollInputs();

    if (inputs_.CheckKey(GLFW_KEY_F)) {
        properties_.draw_solid_ = false;
    }
    if (inputs_.CheckKey(GLFW_KEY_G)) {
        properties_.draw_solid_ = true;
    }

    if (inputs_.CheckKeyPress(GLFW_KEY_R)) {
        entity_render_->Reload();
    }

    if (inputs_.CheckKeyPress(GLFW_KEY_P)) {
        profiler_->LoadCache();
        profiler_->print();
    }

    if (inputs_.CheckKey(GLFW_KEY_ESCAPE)) {
        glfwSetWindowShouldClose(GetWindow(), true);
    }



    if (properties_.window_size_dirty_) {
        properties_.window_size_dirty_ = false;

        framebuffer_->Clear();
        framebuffer_->GenBuffer(properties_.window_size_x_, properties_.window_size_y_, (float)g_app_options.graphics_scale_);
    }

    main_player_->Update(inputs_, server_->server->level_->main_world_.get());

    terrain_render_->SetPosition(main_player_->GetEntityProperties().position_);
    terrain_render_->SetRotation(main_player_->GetEntityProperties().rotation_);

    entity_render_->SetPosition(main_player_->GetEntityProperties().position_);
    entity_render_->SetRotation(main_player_->GetEntityProperties().rotation_);

    entity_render_->SetTimePastTick(server_->GetTickClock()->GetTimePassed_s());
    entity_render_->Update();

    terrain_render_->Update();

    inputs_.UpdateAllKey();
}
"./Client\\Client.h"
#pragma once
#include "../RenderEngine/Window.h"

class MainPlayer;
class InternalServer;
class WorldRender;
class MultiEntityRenderer;
class EntityRendererUpdater;
class TexturedFrameBuffer;
class TextRenderer;
class DebugScreen;
class PerformanceProfiler;

class Client : protected Window {
public:
    Client();
    ~Client();

    void run();
private:
    void Initialize();
    void GameLoop();
    void Update();
    void Cleanup();
    void Render();
    void SetDebugScreen();

    double frametime_ = 0.5;

    std::unique_ptr<MainPlayer> main_player_;

    std::unique_ptr<InternalServer> server_ = nullptr;
    std::unique_ptr<WorldRender> terrain_render_ = nullptr;
    std::unique_ptr<MultiEntityRenderer> entity_render_ = nullptr;
    std::unique_ptr<EntityRendererUpdater> entity_updater_ = nullptr;
    std::unique_ptr<TexturedFrameBuffer> framebuffer_ = nullptr;
    std::unique_ptr<TextRenderer> text_render_ = nullptr;
    std::unique_ptr<DebugScreen> debug_screen_ = nullptr;
    PerformanceProfiler* profiler_ = nullptr;
};
"./Client\\ClientLevel\\ClientCache.h"
#pragma once
#include "../../Level/DataContainer/ChunkMapData.h"
#include "Entity/ClientEntities.h"
#include "../../Level/World/Collusion/WorldCollusion.h"

class ClientCache {
private:
    ChunkMap chunk_cache_;
public:
    ClientEntities entities_;
    WorldCollusionDetector collusion_manager_;

    ClientCache() {
        collusion_manager_.Initialize(&chunk_cache_);
    }

    void AddChunk(std::unique_ptr<Chunk> chunk) {
        chunk_cache_.InsertChunk(std::move(chunk));
    }

    void EraseChunk(ChunkPos pos) {
        chunk_cache_.EraseChunk(pos);
    }

    Chunk* GetChunk(ChunkPos pos) const {
        return chunk_cache_.GetChunk(pos);
    }
};
"./Client\\ClientLevel\\ClientLevel.h"
#pragma once
#include "ClientCache.h"

struct ClientLevel {
    ClientCache cache;

};
"./Client\\ClientLevel\\Entity\\ClientEntities.h"
#pragma once
#include "../../../Level/Typenames.h"
#include "../../../Level/Entity/Entity.h"

class ClientEntities {
private:
    FastHashMap<EntityUUID, EntityProperty> entities_;
    FastHashSet<EntityUUID> changed_entities_;
    FastHashSet<EntityUUID> removed_entities_;
public:

    void AddEntity(EntityProperty entityProperty) {
        if (entities_.count(entityProperty.entity_uuid_)) {
            g_logger.LogError("ClientEntities::AddEntity", "Tried to insert already existing entity.");
            return;
        }
        entities_[entityProperty.entity_uuid_] = entityProperty;
        changed_entities_.insert(entityProperty.entity_uuid_);

        // Delete entity from removed if it is in there

        if (removed_entities_.count(entityProperty.entity_uuid_)) {
            removed_entities_.erase(entityProperty.entity_uuid_);
        }
    }

    void ChangeEntity(EntityProperty entityProperty) {
        if (!entities_.count(entityProperty.entity_uuid_)) {
            g_logger.LogError("ClientEntities::ChangeEntity", "Tried to change entity that doesn't exist.");
            return;
        }
        entities_[entityProperty.entity_uuid_] = entityProperty;
        changed_entities_.insert(entityProperty.entity_uuid_);
    }

    EntityProperty GetEntity(EntityUUID uuid) const {
        if (!entities_.count(uuid)) {
            g_logger.LogError("ClientEntities::GetEntity", "Tried to get entity that doesn't exist.");
        }

        const auto& it = entities_.find(uuid);
        return it->second;
    }

    void RemoveEntity(EntityUUID uuid) {
        if (!entities_.count(uuid)) {
            g_logger.LogError("ClientEntities::RemoveEntity", "Tried to remove entity that doesn't exist.");
        }

        entities_.erase(uuid);
        if (changed_entities_.count(uuid)) {
            changed_entities_.erase(uuid);
        }
        removed_entities_.insert(uuid);
    }

    std::vector<EntityProperty> GetAllEntities() const {
        std::vector<EntityProperty> out;
        out.reserve(GetEntityCount());

        for (const auto& [uuid, entityProperty] : entities_) {
            out.push_back(entityProperty);
        }

        return out;
    }

    std::vector<EntityProperty> GetChangedEntities() {
        std::vector<EntityProperty> out;
        out.reserve(GetChangedEntityCount());

        for (EntityUUID uuid : changed_entities_) {
            out.push_back(entities_.find(uuid)->second);
        }

        changed_entities_.clear();

        return out;
    }

    std::vector<EntityUUID> GetRemovedEntitiesUUID() {
        std::vector<EntityUUID> out(removed_entities_.begin(), removed_entities_.end());
        removed_entities_.clear();
        return out;
    }

    size_t GetEntityCount() const {
        return entities_.size();
    }

    size_t GetChangedEntityCount() const {
        return changed_entities_.size();
    }
};
"./Client\\ClientLevel\\Interface\\IClientLevel.h"
#pragma once

class IClientLevel {
private:


public:


};
"./Client\\Communication\\ServerInteraction.cpp"
#include "ServerInteraction.h"
#include "../../Level/Server/Communication/InternalServer.h"
#include "../../Level/Event/Event.h"

void ServerInteraction::AssignServer(InternalServer* server) { //Default  to  integrated server for now
    server_ = server;
}

bool ServerInteraction::CheckCollusion(Ray& ray) {
    return server_->CheckRayIntersection(ray);
}
void ServerInteraction::SendEvent(Event::Event event) {
    server_->SendEvent(event);
}

BlockID ServerInteraction::GetBlock(const BlockPos& pos) {
    return server_->GetBlock(pos);
}

std::vector<EntityUUID> ServerInteraction::GetRemovedEntities() {
    return server_->GetRemovedEntities();
}

std::vector<EntityProperty> ServerInteraction::GetUpdatedEntities() {
    return server_->GetUpdatedEntities();
}
"./Client\\Communication\\ServerInteraction.h"
#pragma once
#include <vector>
#include "../../Level/Typenames.h"

//Abstraction to interact with server
//For external server it will  store a cache of the world

class InternalServer;

struct EntityProperty;
struct Ray;

namespace Event {
    struct Event;
}

class ServerInteraction {
public:
    void AssignServer(InternalServer* server);
    bool CheckCollusion(Ray& ray);
    void SendEvent(Event::Event event);
    BlockID GetBlock(const BlockPos& pos);
    std::vector<EntityUUID> GetRemovedEntities();
    std::vector<EntityProperty> GetUpdatedEntities();
private:
    int dimension_id_ = 0;
    InternalServer* server_;
};
"./Client\\IO\\IO.cpp"
#include <gl/glew.h>
#include <GLFW/glfw3.h>
#include "IO.h"
#include "KEY_CODE.h"

void UserInputs::UpdateAllKey() {
    for (const auto& key : keys_) {
        keys_[key.first] = HOLD;
    }

    mouse_.scroll_direction_ = mouse_.SCROLL_NONE;

    mouse_.displacement_ = glm::dvec2(0.0, 0.0);

    if (mouse_.left_ == mouse_.PRESS) {
        mouse_.left_ = mouse_.HOLD;
    }

    if (mouse_.right_ == mouse_.PRESS) {
        mouse_.right_ = mouse_.HOLD;
    }

    if (mouse_.middle_ == mouse_.PRESS) {
        mouse_.middle_ = mouse_.HOLD;
    }
}

void UserInputs::PressIndividualKey(int key) {
    if (keys_.count(key)) {
        keys_[key] = HOLD;
    } else {
        keys_[key] = PRESS;
    }
}

void UserInputs::ReleaseIndividualKey(int key) {
    if (keys_.count(key)) {
        keys_.erase(key);
    }
}

bool UserInputs::CheckKey(int key) const {
    if (keys_.count(key)) {
        return true;
    }
    return false;
}

bool UserInputs::CheckKeyPress(int key) const {
    if (!CheckKey(key)) {
        return false;
    }
    auto it = keys_.find(key);
    return it->second == PRESS;
}

bool UserInputs::CheckKeyHold(int key) const {
    if (!CheckKey(key)) {
        return false;
    }
    auto it = keys_.find(key);
    return it->second == HOLD;
}
"./Client\\IO\\IO.h"
#pragma once
#include <glm/vec2.hpp>

#include "../../Level/Typenames.h"

struct MouseInputs {
    enum ButtonState {
        RELEASE, PRESS, HOLD
    };

    enum ScrollState {
        SCROLL_NONE, SCROLL_DOWN, SCROLL_UP
    };

    ButtonState left_ = RELEASE;
    ButtonState middle_ = RELEASE;
    ButtonState right_ = RELEASE;

    ScrollState scroll_direction_ = SCROLL_NONE; //-1 or 1

    glm::dvec2 displacement_ = glm::dvec2(0.f, 0.f);
    glm::dvec2 position_ = glm::dvec2(0.f, 0.f);
};


class UserInputs {
private:

    enum KeyStatus {
        PRESS, HOLD
    };

    FastHashMap<int, KeyStatus> keys_;

public:

    void UpdateAllKey();

    void PressIndividualKey(int key);

    void ReleaseIndividualKey(int key);
    
    bool CheckKey(int key) const;

    bool CheckKeyPress(int key) const;

    bool CheckKeyHold(int key) const;

    MouseInputs mouse_;
    
    float delta_ = 0.f;
};
"./Client\\IO\\KEY_CODE.h"
#pragma once
inline constexpr unsigned short int KEY_SPACE = 32;
inline constexpr unsigned short int KEY_APOSTROPHE = 39; /* ' */
inline constexpr unsigned short int KEY_COMMA = 44; /* , */
inline constexpr unsigned short int KEY_MINUS = 45; /* - */
inline constexpr unsigned short int KEY_PERIOD = 46; /* . */
inline constexpr unsigned short int KEY_SLASH = 47; /* / */
inline constexpr unsigned short int KEY_0 = 48;
inline constexpr unsigned short int KEY_1 = 49;
inline constexpr unsigned short int KEY_2 = 50;
inline constexpr unsigned short int KEY_3 = 51;
inline constexpr unsigned short int KEY_4 = 52;
inline constexpr unsigned short int KEY_5 = 53;
inline constexpr unsigned short int KEY_6 = 54;
inline constexpr unsigned short int KEY_7 = 55;
inline constexpr unsigned short int KEY_8 = 56;
inline constexpr unsigned short int KEY_9 = 57;
inline constexpr unsigned short int KEY_SEMICOLON = 59; /* ; */
inline constexpr unsigned short int KEY_EQUAL = 61; /* = */
inline constexpr unsigned short int KEY_A = 65;
inline constexpr unsigned short int KEY_B = 66;
inline constexpr unsigned short int KEY_C = 67;
inline constexpr unsigned short int KEY_D = 68;
inline constexpr unsigned short int KEY_E = 69;
inline constexpr unsigned short int KEY_F = 70;
inline constexpr unsigned short int KEY_G = 71;
inline constexpr unsigned short int KEY_H = 72;
inline constexpr unsigned short int KEY_I = 73;
inline constexpr unsigned short int KEY_J = 74;
inline constexpr unsigned short int KEY_K = 75;
inline constexpr unsigned short int KEY_L = 76;
inline constexpr unsigned short int KEY_M = 77;
inline constexpr unsigned short int KEY_N = 78;
inline constexpr unsigned short int KEY_O = 79;
inline constexpr unsigned short int KEY_P = 80;
inline constexpr unsigned short int KEY_Q = 81;
inline constexpr unsigned short int KEY_R = 82;
inline constexpr unsigned short int KEY_S = 83;
inline constexpr unsigned short int KEY_T = 84;
inline constexpr unsigned short int KEY_U = 85;
inline constexpr unsigned short int KEY_V = 86;
inline constexpr unsigned short int KEY_W = 87;
inline constexpr unsigned short int KEY_X = 88;
inline constexpr unsigned short int KEY_Y = 89;
inline constexpr unsigned short int KEY_Z = 90;
inline constexpr unsigned short int KEY_LEFT_BRACKET = 91; /* [ */
inline constexpr unsigned short int KEY_BACKSLASH = 92; /* \ */
inline constexpr unsigned short int KEY_RIGHT_BRACKET = 93; /* ] */
inline constexpr unsigned short int KEY_GRAVE_ACCENT = 96; /* ` */
inline constexpr unsigned short int KEY_WORLD_1 = 161; /* non-US #1 */
inline constexpr unsigned short int KEY_WORLD_2 = 162; /* non-US #2 */
inline constexpr unsigned short int KEY_ESCAPE = 256;
inline constexpr unsigned short int KEY_ENTER = 257;
inline constexpr unsigned short int KEY_TAB = 258;
inline constexpr unsigned short int KEY_BACKSPACE = 259;
inline constexpr unsigned short int KEY_INSERT = 260;
inline constexpr unsigned short int KEY_DELETE = 261;
inline constexpr unsigned short int KEY_RIGHT = 262;
inline constexpr unsigned short int KEY_LEFT = 263;
inline constexpr unsigned short int KEY_DOWN = 264;
inline constexpr unsigned short int KEY_UP = 265;
inline constexpr unsigned short int KEY_PAGE_UP = 266;
inline constexpr unsigned short int KEY_PAGE_DOWN = 267;
inline constexpr unsigned short int KEY_HOME = 268;
inline constexpr unsigned short int KEY_END = 269;
inline constexpr unsigned short int KEY_CAPS_LOCK = 280;
inline constexpr unsigned short int KEY_SCROLL_LOCK = 281;
inline constexpr unsigned short int KEY_NUM_LOCK = 282;
inline constexpr unsigned short int KEY_PRINT_SCREEN = 283;
inline constexpr unsigned short int KEY_PAUSE = 284;
inline constexpr unsigned short int KEY_F1 = 290;
inline constexpr unsigned short int KEY_F2 = 291;
inline constexpr unsigned short int KEY_F3 = 292;
inline constexpr unsigned short int KEY_F4 = 293;
inline constexpr unsigned short int KEY_F5 = 294;
inline constexpr unsigned short int KEY_F6 = 295;
inline constexpr unsigned short int KEY_F7 = 296;
inline constexpr unsigned short int KEY_F8 = 297;
inline constexpr unsigned short int KEY_F9 = 298;
inline constexpr unsigned short int KEY_F10 = 299;
inline constexpr unsigned short int KEY_F11 = 300;
inline constexpr unsigned short int KEY_F12 = 301;
inline constexpr unsigned short int KEY_F13 = 302;
inline constexpr unsigned short int KEY_F14 = 303;
inline constexpr unsigned short int KEY_F15 = 304;
inline constexpr unsigned short int KEY_F16 = 305;
inline constexpr unsigned short int KEY_F17 = 306;
inline constexpr unsigned short int KEY_F18 = 307;
inline constexpr unsigned short int KEY_F19 = 308;
inline constexpr unsigned short int KEY_F20 = 309;
inline constexpr unsigned short int KEY_F21 = 310;
inline constexpr unsigned short int KEY_F22 = 311;
inline constexpr unsigned short int KEY_F23 = 312;
inline constexpr unsigned short int KEY_F24 = 313;
inline constexpr unsigned short int KEY_F25 = 314;
inline constexpr unsigned short int KEY_KP_0 = 320;
inline constexpr unsigned short int KEY_KP_1 = 321;
inline constexpr unsigned short int KEY_KP_2 = 322;
inline constexpr unsigned short int KEY_KP_3 = 323;
inline constexpr unsigned short int KEY_KP_4 = 324;
inline constexpr unsigned short int KEY_KP_5 = 325;
inline constexpr unsigned short int KEY_KP_6 = 326;
inline constexpr unsigned short int KEY_KP_7 = 327;
inline constexpr unsigned short int KEY_KP_8 = 328;
inline constexpr unsigned short int KEY_KP_9 = 329;
inline constexpr unsigned short int KEY_KP_DECIMAL = 330;
inline constexpr unsigned short int KEY_KP_DIVIDE = 331;
inline constexpr unsigned short int KEY_KP_MULTIPLY = 332;
inline constexpr unsigned short int KEY_KP_SUBTRACT = 333;
inline constexpr unsigned short int KEY_KP_ADD = 334;
inline constexpr unsigned short int KEY_KP_ENTER = 335;
inline constexpr unsigned short int KEY_KP_EQUAL = 336;
inline constexpr unsigned short int KEY_LEFT_SHIFT = 340;
inline constexpr unsigned short int KEY_LEFT_CONTROL = 341;
inline constexpr unsigned short int KEY_LEFT_ALT = 342;
inline constexpr unsigned short int KEY_LEFT_SUPER = 343;
inline constexpr unsigned short int KEY_RIGHT_SHIFT = 344;
inline constexpr unsigned short int KEY_RIGHT_CONTROL = 345;
inline constexpr unsigned short int KEY_RIGHT_ALT = 346;
inline constexpr unsigned short int KEY_RIGHT_SUPER = 347;
inline constexpr unsigned short int KEY_MENU = 348;
"./Client\\Player\\MainPlayer.cpp"
#include <glm/vec2.hpp>

#include "MainPlayer.h"
#include "PlayerMovement.h"
#include "WorldInteraction.h"
#include "../IO/IO.h"
#include "../IO/KEY_CODE.h"
#include "../../Level/Item/ItemTextureAtlas.h"
#include "../../Level/Entity/Mobs/Player.h"
#include "../../Level/Entity/Properties/EntityProperties.h"
#include "../../RenderEngine/GUI/GUI.h"
#include "../../RenderEngine/GUI/GUISet.h"


MainPlayer::MainPlayer() : 
    player_{std::make_unique<Player>()},
    movement_{std::make_unique<PlayerMovement>()},
    interactions_{ std::make_unique<WorldInteraction>() },
    player_gui_{std::make_unique<GUI>()} {

}

MainPlayer::~MainPlayer() = default;

void MainPlayer::Initialize(GLFWwindow* win, InternalServer* server) {
    player_gui_->Initialize(win);

    float ItemViewRelativeSize = 0.85f;

    GUISet hotbar;
    hotbar.SetGUITexture("assets/minecraft/textures/gui/widgets.png");
    hotbar.AddGUIElement("Hotbar", "",
        glm::vec2(9.f * hotbar_size_ * 1.0055555555f, hotbar_size_ * 1.05f),
        glm::vec2(0.f, -1.f + hotbar_size_ * 0.5f),
        glm::vec2(0.5f, 0.5f),
        glm::vec2(181.5f,21.5f));

    hotbar.AddGUIElement("Select", "",
        glm::vec2(hotbar_size_ * 1.1f,  hotbar_size_ * 1.1f),
        glm::vec2(-hotbar_size_ * 4.f, -1.f + hotbar_size_ * 0.5f),
        glm::vec2(0.5f, 22.5f),
        glm::vec2(22.5f, 44.5f));

    GUISet itemBar;
    itemBar.SetGUITexture(g_item_atlas.atlas_.texture_id_,
        g_item_atlas.atlas_.width_,
        g_item_atlas.atlas_.height_);

    for (int i = 0; i < 9; i++) {
        itemBar.AddGUIElementNorm(std::to_string(i), "",
            glm::vec2(hotbar_size_* ItemViewRelativeSize, hotbar_size_ * ItemViewRelativeSize),
            glm::vec2(hotbar_size_ * (float)(i - 4), -1.f + hotbar_size_ * 0.5f),
            glm::vec2(0,0),
            glm::vec2(1,1));
    }

    gui_index_ = player_gui_->AddGUI("PlayerGUI", hotbar);
    item_gui_index_ = player_gui_->AddGUI("Itembar", itemBar);
    internal_server_ = server;
}

void MainPlayer::RenderGUIs() {
    player_gui_->Render();
}

void MainPlayer::PrepareGUIs() {
    size_t currentSlotIndex = player_->entity_inventory_.right_hand_slot_;
    if (currentSlotIndex != slot_index_) {
        slot_index_ = currentSlotIndex;
        player_gui_->EditGUISet(gui_index_).EditElementPosition("Select", glm::vec2(hotbar_size_ * (float)((int)slot_index_ - 4), -1.f + hotbar_size_ * 0.5f));
    }

    for (int i = 0; i < 9; i++) {
        ItemStack item = player_->entity_inventory_.GetItem(i);
        ItemUVMapping uv = g_item_atlas.items_uv_map_[item.item_.properties_.id_];

        if (item.IsInitialized()) {
            player_gui_->EditGUISet(item_gui_index_).EditElementUVNorm(std::to_string(i), uv.uv_1_, uv.uv_2_);
        }
        else {
            player_gui_->EditGUISet(item_gui_index_).EditElementUVNorm(std::to_string(i), glm::vec2(0.f,0.f), glm::vec2(0.f,0.f));
        }
        

    }

    player_gui_->PrepareRenderer();
}

void MainPlayer::Update(UserInputs inputs, Dimension* dimension) {
    InventoryUpdate(inputs);
    interactions_->Interact(player_.get(), inputs, dimension);
    movement_->Update(player_.get(), inputs, internal_server_);
    PrepareGUIs();
}

EntityProperty MainPlayer::GetEntityProperties() {
    return player_->properties_;
}

void MainPlayer::SetPlayerRotation(float x, float y) {
    player_->properties_.rotation_ = glm::vec2(x, y);
}

void MainPlayer::SetPlayerPosition(float x, float y, float z) {
    player_->properties_.position_ = glm::vec3(x, y, z);
}

void MainPlayer::InventoryUpdate(UserInputs inputs) {
    int Direction = 0;

    switch (inputs.mouse_.scroll_direction_) {
    case inputs.mouse_.SCROLL_DOWN:
        Direction = 1;
        break;
    case inputs.mouse_.SCROLL_UP:
        Direction = -1;
        break;
    case inputs.mouse_.SCROLL_NONE:
        break;
    }

    int currentInventorySlot = player_->entity_inventory_.right_hand_slot_;
    // int MaxInventorySize = m_Player.m_EntityInventory.GetSlotCount();

    if (currentInventorySlot + Direction == 9) {
        currentInventorySlot = 0;
    } else if (currentInventorySlot + Direction == -1) {
        currentInventorySlot = 8;
    }
    else {
        currentInventorySlot += Direction;
    }

    if (inputs.CheckKeyPress(KEY_1))
        currentInventorySlot = 0;
    if (inputs.CheckKeyPress(KEY_2))
        currentInventorySlot = 1;
    if (inputs.CheckKeyPress(KEY_3))
        currentInventorySlot = 2;
    if (inputs.CheckKeyPress(KEY_4))
        currentInventorySlot = 3;
    if (inputs.CheckKeyPress(KEY_5))
        currentInventorySlot = 4;
    if (inputs.CheckKeyPress(KEY_6))
        currentInventorySlot = 5;
    if (inputs.CheckKeyPress(KEY_7))
        currentInventorySlot = 6;
    if (inputs.CheckKeyPress(KEY_8))
        currentInventorySlot = 7;
    if (inputs.CheckKeyPress(KEY_9))
        currentInventorySlot = 8;

    player_->entity_inventory_.right_hand_slot_ = currentInventorySlot;
}
"./Client\\Player\\MainPlayer.h"
#pragma once
#include <memory>

class InternalServer;
class UserInputs;
class Dimension;
class PlayerMovement;
class Player;
class WorldInteraction;
class GUI;

struct GLFWwindow;
struct EntityProperty;


class MainPlayer {
public:

    MainPlayer();
    ~MainPlayer();

    void Initialize(GLFWwindow* win, InternalServer* server);

    void Update(UserInputs inputs, Dimension* dimension);

    EntityProperty GetEntityProperties();

    void SetPlayerRotation(float x, float y);
    void SetPlayerPosition(float x, float y, float z);

    void RenderGUIs();

    std::unique_ptr<Player> player_;
private:

    void PrepareGUIs();
    void InventoryUpdate(UserInputs inputs);

    std::unique_ptr<PlayerMovement> movement_;
    std::unique_ptr<WorldInteraction> interactions_;
    std::unique_ptr<GUI> player_gui_;

    InternalServer* internal_server_ = nullptr;

    size_t gui_index_ = 0;
    size_t item_gui_index_ = 0;
    size_t slot_index_ = 0;

    float hotbar_size_ = 0.135;
};
"./Client\\Player\\PlayerMovement.cpp"
#include <glm/vec3.hpp>
#include <glm/geometric.hpp>
#include <cmath>

#include "PlayerMovement.h"
#include "../IO/IO.h"
#include "../IO/KEY_CODE.h"
#include "../../Level/Entity/Mobs/Player.h"
#include "../../Level/Server/Communication/InternalServer.h"
#include "../../Utils/Math/vectorOperations.h"

void PlayerMovement::Update(Player* player, const UserInputs& inputs, InternalServer* server) {

    if (inputs.CheckKeyPress(KEY_C)) {
        enable_collusion_ = !enable_collusion_;
    }

    RotatePlayer(player, inputs);
    MovePlayer(player, inputs, server);
}

float PlayerMovement::VelocityMovementCurve(float current, float max, float delta) {

    int currentTime = static_cast<int>(-log(max - current) + log(max)); //TODO: Fix this

    int x = static_cast<int>(delta - log(max) - currentTime);

    if (x <= 0) {
        x = 0;
    }

    return max - expf(-x);
}

void PlayerMovement::RotatePlayer(Player* player, const UserInputs& Inputs) {
    float CamSensitivity = 0.1f;

    player->properties_.rotation_.x += static_cast<float>(Inputs.mouse_.displacement_.x * CamSensitivity);
    player->properties_.rotation_.y -= static_cast<float>(Inputs.mouse_.displacement_.y * CamSensitivity);

    if (player->properties_.rotation_.y > 89.9999f)
        player->properties_.rotation_.y = 89.9999f;
    if (player->properties_.rotation_.y < -89.9999f)
        player->properties_.rotation_.y = -89.9999f;
}

void PlayerMovement::MoveRelative(Player* player, float strafe, float up, float forward,  float friction) {
    float f = strafe * strafe + up * up + forward * forward;

    if (f >= 1.0e-4f) {
        f = sqrtf(f);

        f = f < 1.0f ? 1.0f : f;
        
        f = friction / f;
        strafe = strafe * f;
        up = up * f;
        forward = forward * f;

        float zCoord = sin(player->properties_.rotation_.y * 0.017453292f);
        float xCoord = cos(player->properties_.rotation_.y * 0.017453292f);

        player->properties_.velocity_.x += strafe * xCoord - forward * zCoord;
        player->properties_.velocity_.y += up;
        player->properties_.velocity_.z += forward * xCoord + strafe * zCoord;
    }
}

void PlayerMovement::MovePlayer(Player* player, const UserInputs& inputs, InternalServer* server) {

    glm::vec3 front(
        cos(player->properties_.rotation_.x * 0.0174533) * cos(player->properties_.rotation_.y * 0.0174533),
        0,
        sin(player->properties_.rotation_.x * 0.0174533) * cos(player->properties_.rotation_.y * 0.0174533)
    );

    front = normalize(front);

    glm::vec3 right = normalize(cross(front, glm::vec3(0.0, 1.0, 0.0)));
    right.y = 0;

    float velocity = player->properties_.max_speed_;

    if (inputs.CheckKey(KEY_LEFT_CONTROL)) {
        velocity *= 8.f;
    }

    float v = VelocityMovementCurve(Magnitude(player->properties_.velocity_), velocity, inputs.delta_) / sqrtf(2);

    player->properties_.velocity_ = glm::vec3(0.f, 0.f, 0.f);

    if (inputs.CheckKey(KEY_W)) {
        player->properties_.velocity_ += front * v;
    }
    if (inputs.CheckKey(KEY_A)) {
        player->properties_.velocity_ += -right * v;
    }
    if (inputs.CheckKey(KEY_S)) {
        player->properties_.velocity_ += -front * v;
    }
    if (inputs.CheckKey(KEY_D)) {
        player->properties_.velocity_ += right * v;
    }

    if (inputs.CheckKey(KEY_LEFT_SHIFT)) {
        player->properties_.velocity_.y += -VelocityMovementCurve(Magnitude(player->properties_.velocity_), velocity, inputs.delta_);
    }


    if (inputs.CheckKey(KEY_SPACE) && (server->CheckPlayerOnGround() && enable_collusion_)) {
        player->properties_.velocity_.y += velocity * 4000;
    }

    if (inputs.CheckKey(KEY_SPACE)) {
        player->properties_.velocity_.y += velocity;
    }


    if (enable_collusion_) {
        float gravity = -80;
        gravity = 0;

        player->properties_.velocity_.y += gravity;

        glm::vec3 time = server->GetPlayerCollusionTimes();

        if ((time.x != -1.) && (time.x <= inputs.delta_)) {
            player->properties_.velocity_.x = 0;
        }
        if ((time.y != -1.) && (time.y <= inputs.delta_)) {
            player->properties_.velocity_.y = 0;

            player->properties_.velocity_.x = player->properties_.velocity_.x * powf(1.f / 250.f, inputs.delta_);
            player->properties_.velocity_.z = player->properties_.velocity_.z * powf(1.f / 250.f, inputs.delta_);
        }
        if ((time.z != -1.) && (time.z <= inputs.delta_)) {
            player->properties_.velocity_.z = 0;
        }
    }


    player->properties_.position_ += player->properties_.velocity_ * inputs.delta_ / 2.f;
    player->properties_.velocity_ = player->properties_.velocity_ * powf(3.f / 25.f, inputs.delta_);
    /*float jumpMovementFactor = 0.02F;
    float f = 0.91;

    float blockSlipperiness = 0.6;

    if (server->checkPlayerOnGround() && m_EnableCollusion) {
        f = blockSlipperiness * 0.91;
    }

    float f2 = 0.16277136F / (f * f * f);
    float friction = 0.f;

    if (server->checkPlayerOnGround() && m_EnableCollusion) {
        friction = f2 * 0.08;
    }
    else {
        friction = jumpMovementFactor;
    }

    float baseAcceleration = 0.1f;
    if (Inputs.CheckKey(KEY_LEFT_SHIFT)) {
        baseAcceleration = 0.13f;
    }
    
    float strafe = 0.f, forward = 0.f, up = 0.f;

    if (Inputs.CheckKey(KEY_W)) {
        forward += baseAcceleration;
    }
    if (Inputs.CheckKey(KEY_A)) {
        strafe -= baseAcceleration;
    }
    if (Inputs.CheckKey(KEY_S)) {
        forward -= baseAcceleration;
    }
    if (Inputs.CheckKey(KEY_D)) {
        strafe += baseAcceleration;
    }

    if (Inputs.CheckKey(KEY_SPACE)) {
        up += baseAcceleration;
    }

    MoveRelative(player , strafe, up, forward, friction);*/


}
"./Client\\Player\\PlayerMovement.h"
#pragma once

class Player;
class UserInputs;
class InternalServer;

class PlayerMovement {
public:
    void Update(Player* player, const UserInputs& inputs, InternalServer* world);
private:
    float VelocityMovementCurve(float current, float max, float delta);

    void RotatePlayer(Player* player, const UserInputs& inputs);
    void MovePlayer(Player* player, const UserInputs& inputs, InternalServer* server);
    void MoveRelative(Player* player, float strafe, float up, float forward, float friction);

    bool enable_collusion_ = false;

};
"./Client\\Player\\WorldInteraction.cpp"
#include <glm/geometric.hpp>
#include <glm/vec3.hpp>

#include "WorldInteraction.h"
#include "../IO/IO.h"
#include "../IO/KEY_CODE.h"
#include "../../Level/Dimension/Dimension.h"
#include "../../Level/Entity/Mobs/Player.h"
#include "../../Utils/Math/vectorOperations.h"
#include "../../Utils/Math/Ray/Ray.h"

void WorldInteraction::Interact(Player* player, const UserInputs& inputs, Dimension* dimension) {
    Ray ray;
    ray.origin_ = player->properties_.position_;
    ray.direction_ = glm::dvec3(
        cos(player->properties_.rotation_.x * 0.0174533) * cos(player->properties_.rotation_.y * 0.0174533),
        sin(player->properties_.rotation_.y * 0.0174533),
        sin(player->properties_.rotation_.x * 0.0174533) * cos(player->properties_.rotation_.y * 0.0174533));

    BlockID block = player->entity_inventory_.GetItem(player->entity_inventory_.right_hand_slot_).item_.GetBlock();

    if (inputs.mouse_.right_ == inputs.mouse_.PRESS) {
        PlaceBlock(ray, block, dimension);
    }

    if (inputs.mouse_.left_ == inputs.mouse_.PRESS) {
        BreakBlock(ray, dimension);
    }
    if (inputs.mouse_.middle_ == inputs.mouse_.PRESS) {
        BlockID newBlock = GetBlock(ray, dimension);
        if (newBlock != g_blocks.AIR) {
            player->entity_inventory_.SetSlot(player->entity_inventory_.right_hand_slot_, ItemStack{ g_items.GetItem(g_items.GetBlockItem(newBlock)) });
        }
        
    }
}

BlockID WorldInteraction::GetBlock(Ray ray, Dimension* dimension) {
    if (dimension->world_interactions_.collusions_->CheckRayIntersection(ray)) {
        return dimension->world_interactions_.GetBlock(BlockPos{ (int)floor(ray.end_point_.x), (int)floor(ray.end_point_.y), (int)floor(ray.end_point_.z) });
    }
    return g_blocks.AIR;
}

void WorldInteraction::BreakBlock(Ray ray, Dimension* dimension) {
    if (dimension->world_interactions_.collusions_->CheckRayIntersection(ray)) {
        Event::BlockEvent breakBlock;
        breakBlock.block_= g_blocks.AIR;
        breakBlock.pos_ = BlockPos{ (int)floor(ray.end_point_.x),
                                    (int)floor(ray.end_point_.y),
                                    (int)floor(ray.end_point_.z) };
        breakBlock.id_ = g_event_handler.BlockPlace;
        dimension->event_manager_.AddEvent(breakBlock);

    }
}

void WorldInteraction::PlaceBlock(Ray ray, BlockID block, Dimension* dimension) {
    if (dimension->world_interactions_.collusions_->CheckRayIntersection(ray)) {
        int BounceSurface = ray.bounce_surface_;

        glm::ivec3 placePos = floor(ray.end_point_);

        placePos[(int)floor(BounceSurface >> 1)] += (BounceSurface & 0b1) - ((BounceSurface + 1) & 0b1); //Offsets block location to be placed by 1 block

        Event::BlockEvent placeBlock;

        placeBlock.block_ = block;
        placeBlock.pos_ = BlockPos{ placePos.x, placePos.y, placePos.z };
        placeBlock.id_ = g_event_handler.BlockPlace;

        dimension->event_manager_.AddEvent(placeBlock);
    }
}
"./Client\\Player\\WorldInteraction.h"
#pragma once
#include "../../Level/Typenames.h"

class Player;
class UserInputs;
class Dimension;

struct Ray;

class WorldInteraction {
public:
    void Interact(Player* player, const UserInputs& Inputs, Dimension* dimension);
private:
    BlockID GetBlock(Ray ray, Dimension* dimension);
    void BreakBlock(Ray ray, Dimension* dimension);
    void PlaceBlock(Ray ray, BlockID block, Dimension* dimension);
};
"./Client\\Profiler\\PerformanceProfiler.cpp"
#include "PerformanceProfiler.h"

#include "../../Level/Timer/Timer.h"
#include "../../FileManager/Files.h"

PerformanceProfiler::PerformanceProfiler() {
    initial_time_ = std::chrono::high_resolution_clock::now();
}

void PerformanceProfiler::ProfileStart(uint64_t hash) {
    timer_stack_.emplace(hash, 0);
    timer_stack_.top().second = (std::chrono::high_resolution_clock::now() - initial_time_).count();
}

void PerformanceProfiler::ProfileStart(std::string path) {
    uint64_t hash = Hasher(path);
    if (!string_hash_container_.count(hash)) {
        RegisterPaths(path);
    }

    timer_stack_.emplace(hash, (std::chrono::high_resolution_clock::now() - initial_time_).count());
}

void PerformanceProfiler::ProfileStop(uint64_t hash) {
    uint64_t timePass = (std::chrono::high_resolution_clock::now() - initial_time_).count() - timer_stack_.top().second;
    time_pass_cache_.emplace_back(hash, timePass);
    timer_stack_.pop();
}

void PerformanceProfiler::ProfileStop(std::string path) {
    uint64_t hash = Hasher(path);
    uint64_t timePass = (std::chrono::high_resolution_clock::now() - initial_time_).count() - timer_stack_.top().second;

    time_pass_cache_.emplace_back(hash, timePass);
    timer_stack_.pop();
}

// TOOD: Fix me
void PerformanceProfiler::RegisterPaths(std::string path) {
    string_hash_container_[Hasher(path)] = path;
    std::vector<std::string> tokens = Tokenize(path, '/');
    std::vector<std::string> pathTokens = {};

    if (tokens.size() != 1) {
        pathTokens.insert(pathTokens.end(), tokens.begin(), tokens.end());
    }

    string_tokenized_hash_container_[Hasher(path)] = pathTokens;

}

uint64_t PerformanceProfiler::Hasher(std::string path) {
    return std::hash<std::string>{}(path);
}

void PerformanceProfiler::LoadCache() {
    CondenseCache();

    for (const auto& [hash, time] : time_pass_cache_) {
        std::vector<std::string> tokens = string_tokenized_hash_container_[hash];
        root_.ChangeTime(tokens, 0, (double)time);
    }

    time_pass_cache_.clear();
}

void PerformanceProfiler::print() {
    root_.print();
}

void PerformanceProfiler::CondenseCache() {
    FastHashMap<uint64_t, uint64_t> condensedCache = {};

    for (const auto& [hash, time] : time_pass_cache_) {
        if (condensedCache.count(hash)) {
            condensedCache[hash] += time;
        }
        else {
            condensedCache[hash] = time;
        }
    }

    time_pass_cache_.clear();
    for (const auto& [hash, time] : condensedCache) {
        time_pass_cache_.emplace_back(hash, time);
    }

}

void PerformanceProfiler::CombineCache(PerformanceProfiler profiler) {
    //Simplify cache first
    profiler.CondenseCache();
    time_pass_cache_.insert(time_pass_cache_.end(), profiler.time_pass_cache_.begin(), profiler.time_pass_cache_.end());
    string_hash_container_.insert(profiler.string_hash_container_.begin(), profiler.string_hash_container_.end());
    string_tokenized_hash_container_.insert(profiler.string_tokenized_hash_container_.begin(), profiler.string_tokenized_hash_container_.end());
    CondenseCache();
}

PerformanceProfiler::PerformanceTree::PerformanceTree() = default;
PerformanceProfiler::PerformanceTree::PerformanceTree(std::string name) : name_(name) {};

void PerformanceProfiler::PerformanceTree::ChangeTime(std::vector<std::string>& path, int depth, double time) {
    time_passed_ += time;

    if (path.size() == depth) {
        return;
    }

    for (auto& node : nodes_) {
        if (!strcmp(node->name_.c_str(), path[depth].c_str())) {
            node->ChangeTime(path, depth + 1, time);
            return;
        }
    }

    nodes_.push_back(std::make_unique<PerformanceTree>(path[depth]));
    nodes_.back()->ChangeTime(path, depth + 1, time);
}

void PerformanceProfiler::PerformanceTree::print(int depth) const {
    std::string out = "";

    for (int i = 0; i < depth; i++) {
        out += ' ';
    }

    if (depth != 0) {
        out += '-';
    }

    out += name_ + ':';
    out += std::to_string(time_passed_ / 1000000.0) + " ms\n";
    std::cout << out;

    for (const auto& node : nodes_) {
        node->print(depth + 1);
    }
}
"./Client\\Profiler\\PerformanceProfiler.h"
#pragma once
#include <string>
#include <iostream>
#include <stack>


#include "../../Level/Typenames.h"



class PerformanceProfiler {
public:
    PerformanceProfiler();

    void ProfileStart(uint64_t hash);

    void ProfileStart(std::string path);

    void ProfileStop(uint64_t hash);

    void ProfileStop(std::string path);

    // TOOD: Fix me
    void RegisterPaths(std::string path);

    uint64_t Hasher(std::string path);

    void LoadCache();

    void print();

    void CondenseCache();

    void CombineCache(PerformanceProfiler profiler);

    std::vector<std::pair<uint64_t, uint64_t>> time_pass_cache_{};

    FastHashMap<uint64_t, std::string> string_hash_container_;
    FastHashMap<uint64_t, std::vector<std::string>> string_tokenized_hash_container_;
private:
    std::stack<std::pair<uint64_t, uint64_t>> timer_stack_;
    

    struct PerformanceTree {
        PerformanceTree();
        PerformanceTree(std::string name);

        void ChangeTime(std::vector<std::string>& path, int depth, double time);
        
        void print(int depth = 0) const;

        double time_passed_ = 0.0;
        std::string name_ = "";
        std::vector<std::unique_ptr<PerformanceTree>> nodes_{};
        
    };

    PerformanceTree root_{"root"};
    std::chrono::steady_clock::time_point initial_time_;

};
"./Client\\Render\\DebugScreen\\DebugScreen.cpp"
#include <gl/glew.h>
#include <GLFW/glfw3.h>

#include "DebugScreen.h"
#include "../../../RenderEngine/GUI/TextRenderer.h"
DebugScreen::DebugScreen() : renderer_{std::make_unique<TextRenderer>() } {
}

DebugScreen::~DebugScreen() = default;

void DebugScreen::Render() {
    renderer_->RenderFont();
}

void DebugScreen::Update() {
    renderer_->ConstructBuffer();
}

void DebugScreen::EditText(std::string name, const char* c) {
    EditText(name, std::string(c));
}

void DebugScreen::EditText(std::string name, std::string text) {
    renderer_->EditFontText(name, text);
}

void DebugScreen::Initialize(GLFWwindow* w) {
    window_ = w;
    renderer_->InitializeTextRenderer(w);
    glm::vec3 clr = glm::vec3(0.2f, 0.2f, 0.2f);
    float a = 0.5;

    RenderableFont versionFont;
    versionFont.FontSize(0.05f);
    versionFont.SetText(std::string("Version 1.3.0A"));
    versionFont.SetPosition(glm::vec2(-1.f, 0.95f));
    versionFont.AddBackground(clr, a);

    for (int i = 1; i <= 10; i++) {
        RenderableFont stat;
        stat.FontSize(0.04f);
        stat.SetText(std::string("N/A"));
        stat.SetPosition(glm::vec2(-1.f, 0.95f - 0.05f * i));
        stat.AddBackground(clr, a);
        stat.setBackgroundPadding(0.005f, 0.0f);
        renderer_->InsertFontObject("Stat" + std::to_string(i), stat);
    }

    renderer_->InsertFontObject("Title", versionFont);

    Update();
}
"./Client\\Render\\DebugScreen\\DebugScreen.h"
#pragma once
#include <string>
#include <memory>
#include <glm/vec3.hpp>

class TextRenderer;

struct GLFWWindow;

class DebugScreen {
private:
    GLFWwindow* window_{ nullptr };
    std::unique_ptr<TextRenderer> renderer_;
    float fps_{ 0.0f };
    int vram_usage_mb_{ 0 };
    glm::vec3 position_{ 0.f, 0.f, 0.f };
public:
    DebugScreen();
    ~DebugScreen();
    void Render();
    void Update();
    void EditText(std::string name, const char* c);
    void EditText(std::string name, std::string text);
    void Initialize(GLFWwindow* w);
};
"./Client\\Render\\PlayerPOV.cpp"
#include "PlayerPOV.h"
#include "../../RenderEngine/Camera/camera.h"

PlayerPOV::PlayerPOV() : camera_{ std::make_unique<Camera>() }{

}

void PlayerPOV::SetPosition(glm::vec3 pos) {
    camera_->position_ = pos;
}

void PlayerPOV::SetRotation(glm::vec2 rot) {
    camera_->yaw_ = rot.x;
    camera_->pitch_ = rot.y;

    camera_->updateCameraVectors();
}

void PlayerPOV::SetFOV(float fov) {
    camera_->fov_ = fov;
}

Camera* PlayerPOV::GetCamera() {
    return camera_.get();
}
"./Client\\Render\\PlayerPOV.h"
#pragma once
#include <memory>
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>

class Camera;

class PlayerPOV {
public:
    PlayerPOV();
    void SetPosition(glm::vec3 pos);
    void SetRotation(glm::vec2 rot);
    void SetFOV(float fov);

    Camera* GetCamera();
private:
    std::unique_ptr<Camera> camera_;
};
"./Client\\Render\\WorldRender.cpp"
﻿#include "WorldRender.h"

#include "../Render/PlayerPOV.h"
#include "../../Utils/Clock.h"
#include "../../Core/Options/Option.h"
#include "../../Level/Server/Communication/InternalServer.h"
#include "../../RenderEngine/ChunkRenderer/Mesh/ChunkMeshingV2.h"
#include "../../RenderEngine/ChunkRenderer/TerrainRenderer.h"

static thread_local Mesh::ChunkMeshData chunkMesher;

WorldRender::WorldRender() : 
    player_{std::make_unique<PlayerPOV>()},
    renderer_{std::make_unique<TerrainRenderer>()} {

}

void WorldRender::SetRotation(glm::dvec2 rotation) {
    player_->SetRotation(rotation);
}

void WorldRender::SetPosition(glm::dvec3 position) {
    player_->SetPosition(position);
}

void WorldRender::Render() {
    renderer_->RenderSky();
    renderer_->Render();
}

void WorldRender::LoadChunkToRenderer(ChunkPos chunk) {
    if (server_->GetChunk(chunk) != nullptr) {
        mesh_thread_pool_->SubmitTask(chunk);
    }

}

void WorldRender::LoadChunkMultiToRenderer(std::vector<ChunkPos> chunks) {
    mesh_thread_pool_->SubmitTask(chunks);
}


std::unique_ptr<Mesh::ChunkVertexData> WorldRender::Worker(const ChunkPos& pos) {
    Chunk* chunk = WorldRender::server_->GetChunk(pos);

    Timer timer;
    chunkMesher.Reset();
    chunkMesher.SetChunk(chunk);
    chunkMesher.GenerateMesh();
    size_t time = static_cast<size_t>(timer.GetTimePassed_μs());

    //Transfer Infomation
    std::unique_ptr<Mesh::ChunkVertexData> data = std::make_unique<Mesh::ChunkVertexData>();
    data->solidVertices.resize(chunkMesher.solid_face_count_ * 12);
    data->transparentVertices.resize(chunkMesher.transparent_face_count_ * 12);
    data->position_ = pos;
    data->time_ = time;

    memcpy(data->solidVertices.data(), chunkMesher.vertices_buffer_.data(), chunkMesher.solid_face_count_ * 12 * sizeof(uint32_t));
    memcpy(data->transparentVertices.data(), chunkMesher.transparent_vertices_buffer_.data(), chunkMesher.transparent_face_count_ * 12 * sizeof(uint32_t));

    return data;
}

void WorldRender::Update() {
    
    const int chunkUpdateLimit = 4000;
    int updateAmount = 0;

    std::vector<std::unique_ptr<Mesh::ChunkVertexData>> output = mesh_thread_pool_->GetOutput();

    mesh_add_queue_.insert(mesh_add_queue_.end(), std::make_move_iterator(output.begin()), std::make_move_iterator(output.end()));

    while (!mesh_add_queue_.empty()) {
        if (chunkUpdateLimit == updateAmount) {
            break;
        }
        //profiler_->CombineCache(worker_output_[(uint64_t)workerId].front()->profiler);
        build_time_ += mesh_add_queue_.back()->time_;
        renderer_->AddChunk(std::move(mesh_add_queue_.back()));
        mesh_add_queue_.pop_back();
    }

    LoadChunkMultiToRenderer(server_->GetUpdatedChunks());

    if (updateAmount < chunkUpdateLimit) {
        renderer_->Defrag(1);
    }

    renderer_->Update();
    renderer_->PrepareRenderer();

}

void WorldRender::Stop() {
    mesh_thread_pool_->Stop();
    renderer_->Cleanup();
}

void WorldRender::Start(GLFWwindow* window, InternalServer* server, PerformanceProfiler* profiler) {
    horizontal_render_distance_ = g_app_options.horizontal_render_distance_;
    vertical_render_distance_ = g_app_options.vertical_render_distance_;

    size_t threadCount = g_app_options.mesh_threads_;

    mesh_thread_pool_ = std::make_unique<ThreadPool<ChunkPos, 
        std::unique_ptr<Mesh::ChunkVertexData>, 
        WorldRender::Worker>>(threadCount, "Mesher", 250);

    window_ = window;
    WorldRender::server_ = server;

    renderer_->Initialize(window_, player_->GetCamera());
    renderer_->LoadAssets();
    renderer_->setSettings(horizontal_render_distance_, vertical_render_distance_, 90);

    profiler_ = profiler;
}

size_t WorldRender::GetQueuedSize() {
    return mesh_thread_pool_->GetQueueSize();
}
"./Client\\Render\\WorldRender.h"
#pragma once
#include <memory>
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>

#include "WorldRenderInfo.h"
#include "../../Utils/ThreadPool.h"
#include "../../Level/Typenames.h"

class TerrainRenderer;
class InternalServer;
class PerformanceProfiler;
class PlayerPOV;

struct GLFWwindow;

namespace Mesh {
    struct ChunkVertexData;
}

class WorldRender : public WorldRenderInfo {
public:
    WorldRender();

    void SetRotation(glm::dvec2 rotation);

    void SetPosition(glm::dvec3 position);

    void Render();

    void LoadChunkToRenderer(ChunkPos chunk);

    void LoadChunkMultiToRenderer(std::vector<ChunkPos> chunks);

    void Start(GLFWwindow* window, InternalServer* server, PerformanceProfiler* profiler);

    void Stop();

    void Update();

    size_t GetQueuedSize();

    std::unique_ptr<TerrainRenderer> renderer_;
    PerformanceProfiler* profiler_;
private:
    static std::unique_ptr<Mesh::ChunkVertexData> Worker(const ChunkPos& pos);
    
    std::unique_ptr<ThreadPool<ChunkPos, std::unique_ptr<Mesh::ChunkVertexData>, WorldRender::Worker>> mesh_thread_pool_;
    std::vector<std::unique_ptr<Mesh::ChunkVertexData>> mesh_add_queue_;

    std::unique_ptr<PlayerPOV> player_;
    GLFWwindow* window_;
    static InternalServer* server_;
};

inline InternalServer* WorldRender::server_ = nullptr;
"./Client\\Render\\WorldRenderInfo.h"
#pragma once

struct WorldRenderInfo {
    double build_time_ = 0.0;

    double build_stage_0_ = 0.0;
    double build_stage_1_ = 0.0;
    double build_stage_2_ = 0.0;

    size_t is_face_visible_calls_ = 0;
    size_t get_face_calls_ = 0;
    size_t set_face_calls_ = 0;
    size_t get_texture_calls_ = 0;
    size_t compare_quad_calls_ = 0;

    size_t amount_of_mesh_generated_ = 1;

    size_t horizontal_render_distance_ = 16;
    size_t vertical_render_distance_ = 16;
};
"./Core\\Initializer.cpp"
#include "../Level/Chunk/Block/Blocks.h"
#include "../Level/Entity/Entities.h"
#include "../Level/Item/Items.h"
#include "../Utils/LogUtils.h"
#include "Initializer.h"
#include "../Level/Item/ItemTextureAtlas.h"
#include "../Level/Entity/Entity.h"
#include "../Level/TerrainGeneration/Generators/GeneratorType.h"
#include "Options/Option.h"
#include "../Level/TerrainGeneration/Biome/BiomeProvider.h"

LogUtils g_logger;
Options g_app_options;
BlockList g_blocks;
EntitiesList g_entity_list;
ItemList g_items;
ItemTextureAtlas g_item_atlas;
GeneratorType g_generators;

int AmountEntityDestroy = 0;

void Initialize() {
    
}
"./Core\\Initializer.h"
#pragma once

void Initialize();
"./Core\\Options\\Option.cpp"
#include "Option.h"
#include "../../FileManager/Files.h"
#include "../../Utils/LogUtils.h"

Options::Options() {
    SetOptionNameTable();

    //Set values from option file
    if (!FileManager::CheckFile("options.txt")) {
        GenerateOptionFile();
        return; //check if option file exist
    }

    File file = FileManager::GetFile("options.txt");

    std::vector<std::string> tokens = file.GetToken(':');

    ProcessTokens(tokens);
}

bool Options::SetValue(std::string name, std::string value) {
    size_t val = stoll(value);

    if (!option_name_.count(name)) {
        g_logger.LogError("Options::SetValue", "Unknown option: " + name);
        return false;
    }

    *option_name_[name] = val;
    return true;
}

void Options::ProcessTokens(std::vector<std::string> tokens) {
    bool success = true;

    for (int i = 0; i < (tokens.size() / 2); i++) {
        std::string name = tokens[2 * i];
        std::string val = tokens[2 * i + 1];
        g_logger.LogDebug("Options::ProcessTokens", name + ":" + val);
        if (!SetValue(name, val)) {
            success = false;
        }
    }
    //Regenerate file if it has an error in it
    if (!success) {
        FileManager::DeleteFile("options.txt");
        GenerateOptionFile();
    }
}

void Options::SetOptionNameTable() {
    option_name_["HorizontalRenderDistance"] = &horizontal_render_distance_;
    option_name_["VerticalRenderDistance"] = &vertical_render_distance_;
    option_name_["WorldGenThreads"] = &world_gen_threads_;
    option_name_["MeshThreads"] = &mesh_threads_;
    option_name_["GraphicsScale"] = &graphics_scale_;
    option_name_["TransparentBufferSize"] = &transparent_buffer_size_;
    option_name_["SolidBufferSize"] = &solid_buffer_size_;
    option_name_["LightEngineThreads"] = &light_engine_threads_;
}

void Options::GenerateOptionFile() { //Generate file if deleted
    FileManager::CreateFile("options.txt");

    std::ofstream file("options.txt");

    for (const auto& option : option_name_) {
        std::string str = option.first + ":" + std::to_string((*option.second));
        file << str << "\n";
    }

    file.close();
    g_logger.LogDebug("Options::GenerateOptionFile", "Generated option file");
}
"./Core\\Options\\Option.h"
#pragma once
#include "../../Level/Typenames.h"

class Options {
public:
    size_t vertical_render_distance_ = 8;
    size_t horizontal_render_distance_ = 16;
    size_t world_gen_threads_ = 6;
    size_t mesh_threads_ = 6;
    size_t graphics_scale_ = 2;
    size_t transparent_buffer_size_ = 1000000000;
    size_t solid_buffer_size_ = 2000000000;
    size_t light_engine_threads_ = 2;

    Options();
private:

    bool SetValue(std::string name, std::string value);

    void ProcessTokens(std::vector<std::string> tokens);

    void SetOptionNameTable();

    void GenerateOptionFile(); //Generate file if deleted

    FastHashMap<std::string, size_t*> option_name_; //name -> ptr

} extern g_app_options;
"./Core\\Registry\\Registry.h"
#pragma once
#include <unordered_map>
#include <string>
#include <exception>
#include "../../Level/Typenames.h"

template <class K, class V> 
class Registry {
public:
    V GetValue(K key);
    K GetKey(int id);
    int GetId(K key);
    void Register(int id, K key, V value);
private:
    FastHashMap<K, V> hashmap_;
    FastHashMap<K, int> get_id_by_key_;
    FastHashMap<int, K> get_key_by_id_;
};

template <class K, class V>
inline V Registry<K, V>::GetValue(K key) {
    if (!hashmap_.count(key)) {
        throw std::exception("Cannot return value because key doesn't exist");
    }
    return hashmap_[key];
}

template <class K, class V>
inline K Registry<K,V>::GetKey(int id) {
    if (!get_key_by_id_.count(id)) {
        throw std::exception("Cannot return key because ID doesn't exist");
    }
    return get_key_by_id_[id];
}

template <class K, class V>
inline int Registry<K, V>::GetId(K key) {
    if (!get_id_by_key_.count(key)) {
        throw std::exception("Cannot return ID because key doesn't exist");
    }
    return get_id_by_key_[key];
}

template <class K, class V>
inline void Registry<K, V>::Register(int id, K key, V value) {
    hashmap_.emplace(key, value);
    get_id_by_key_.emplace(key, id);
    get_key_by_id_.emplace(id, key);
}
"./Core\\Registry\\ResourceLocation.cpp"
#include "ResourceLocation.h"
#include "../../FileManager/Files.h"

void ResourceLocation::SetResourceLocation(std::string name) {
    std::vector<std::string> tokens = Tokenize(name, ':');

    if (tokens.size() != 2) {
        throw std::exception("Invalid resource location");
    }

    namespace_ = tokens[0];
    path_ = tokens[1];
}

std::string ResourceLocation::GetPath() {
    return path_;
}

ResourceLocation::ResourceLocation() {}
ResourceLocation::ResourceLocation(std::string name) : path_(name) {}
"./Core\\Registry\\ResourceLocation.h"
#pragma once
#include <string>

struct ResourceLocation {
    const std::string namespace_divider_ = ":";
    std::string default_namespace_ = "minecraft";
    std::string path_ = "";
    std::string namespace_ = "";

    std::string GetPath();
    void SetResourceLocation(std::string name);

    ResourceLocation();
    ResourceLocation(std::string name);
};
"./FileManager\\Files.cpp"
#include <filesystem>
#include "Files.h"

std::vector<std::string> Tokenize(std::string str, char divider) {
    std::vector<std::string> tokens = {};
    int l = 0, r = 0;
    while (r < str.size()) {
        // Shift right ptr to the first non-divider character

        while (r < str.size() && str[r] != divider) r++;
        tokens.push_back(str.substr(l, r));
        l = r + 1;
        r++;
    }

    return tokens;
}

File::File() = default;

File::File(std::string dir) {
    Open(dir);
}

void File::Open(std::string dir) {
    dir_ = dir;
    file_.open(dir_);
}

void File::Close() {
    file_.close();
}

std::vector<std::string> File::GetToken(char divider) {

    std::ifstream f(dir_);

    std::vector<std::string> tokens = {};

    std::string line;

    while (std::getline(f, line)) {

        std::vector<std::string> lineTokens = Tokenize(line, divider);
        tokens.insert(tokens.end(), lineTokens.begin(), lineTokens.end());
    }

    return tokens;
}

bool FileManager::CheckFolder(const char* dir) {
    struct stat buf;
    return stat(dir, &buf) == 0;
}

bool FileManager::CreateFolder(const char* name) {
    if (CheckFolder(name)) {
        return false; //Already exist
    }

    return (mkdir(name) == 0);
}

//Return true of file exist and false if it doesn't
bool FileManager::CheckFile(const char* dir) {
    return std::filesystem::exists(dir);

}

bool FileManager::CheckFile(std::string dir) {
    return CheckFile(dir.c_str());
}

void FileManager::CreateFile(std::string name, std::string dir) {
    std::string d = "";

    if (dir == "N/A")
        d = name;
    else
        d = (dir + "//" + name);
    std::ofstream file(d.c_str());
    file.close();
}

File FileManager::GetFile(std::string name, std::string dir) {
    std::string d = "";

    if (dir == "N/A")
        d = name;
    else
        d = (dir + "//" + name);


    return File(d);
}

void FileManager::DeleteFile(std::string name, std::string dir) {
    std::string d = "";

    if (dir == "N/A")
        d = name;
    else
        d = (dir + "//" + name);

    remove(d.c_str());
}
"./FileManager\\Files.h"
#pragma once

#include <sys/stat.h>
#include <direct.h>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

std::vector<std::string> Tokenize(std::string str, char divider);

class File{
public:

    std::ifstream file_;
    std::string dir_ = "";

    File();
    File(std::string dir);

    void Open(std::string dir);

    void Close();

    std::vector<std::string> GetToken(char divider);
};

class FileManager {
public:
    static bool CheckFolder(const char* dir);

    static bool CreateFolder(const char* name);

    //Return true of file exist and false if it doesn't
    static bool CheckFile(const char* dir);

    static bool CheckFile(std::string dir);

    static void CreateFile(std::string name, std::string dir = "N/A");

    static File GetFile(std::string name, std::string dir = "N/A");

    static void DeleteFile(std::string name, std::string dir = "N/A");
};
"./Level\\Chunk\\Block\\Block.cpp"
#include "Block.h"
#include "../../../RenderEngine/BlockModel/BlockModels.h"

BlockType::BlockType(bool transparent, bool solid, bool fluid) {
    transparency_ = transparent;
    is_solid_ = solid;
    is_fluid_ = fluid;
}

BlockType::BlockType() = default;

Block::Block() = default;
Block::~Block() = default;
"./Level\\Chunk\\Block\\Block.h"
#pragma once
#include <vector>
#include <string>
#include <memory>

#include "Texture/BlockTexture.h" // TODO: Remove this later
#include "../../Typenames.h"

class Dimension;
class BlockTexture;

namespace Model {
    struct BlockModel;
}

struct BlockType {

    BlockType(bool transparent, bool solid, bool fluid);

    BlockType();

    bool is_fluid_ = false;
    bool transparency_ = false;
    bool is_solid_ = false;
};

struct Block {
    BlockID id_ = NULL;
    std::unique_ptr<Model::BlockModel> block_model_data_ = nullptr;
    std::unique_ptr<BlockTexture> texture_ = nullptr;
    std::unique_ptr<BlockType> properties_ = nullptr;

    std::string block_name_ = "";

    Block();
    virtual ~Block();

    virtual void Tick(const BlockPos& pos, Dimension* currentWorld) = 0;
};
"./Level\\Chunk\\Block\\Blocks.cpp"
#include "Blocks.h"
#include "Type/BlockTypes.h"
#include <nlohmann/json.hpp>
#include "../../../FileManager/Files.h"
#include <fstream>
#include "../../../RenderEngine/BlockModel/ModelLoader.h"
#include "../../../RenderEngine/BlockModel/BlockModels.h"
#include <iostream>
#include <sys/types.h>
#include <filesystem>
#include <string>
#include "../../../RenderEngine/OpenGL/Texture/Types/TextureAtlas.h"

// TODO : Implement model caching
using json = nlohmann::json;

BlockID BlockList::RegisterBlock(std::string blockName, Material* material, bool transparency, bool solid, bool isFluid) {
    BlockID id = static_cast<BlockID>(block_type_data_.size());

    Block* block = material->BuildNewBlockType();

    // MaterialType Type = material->type;

    block->id_ = id;
    block->properties_ = std::make_unique<BlockType>(transparency, solid, isFluid);
    block->texture_ = std::make_unique<BlockTexture>();
    block->block_name_ = blockName;

    block_type_data_.emplace_back(block);

    block_id_name_data_[blockName] = id;

    g_logger.LogInfo("BlockList::RegisterBlock", "Registered new block (ID): " + std::to_string(id));
    delete material; // replace w/ unique ptr later
    return id;
}

void BlockList::AddAssets(std::string namespaceIn) {
    try {
        std::vector<std::string> allOtherBlocks{};
        std::string path = "assets/"+ namespaceIn + "/models/block";

        for (const auto& entry : std::filesystem::recursive_directory_iterator(path)) {
            if (entry.is_directory()) continue;
            std::string name = namespaceIn + ":" + entry.path().filename().string().substr(0, entry.path().filename().string().length() - 5);//epic one liner
            if (block_id_name_data_.count(name)) {
                continue;
            }

            allOtherBlocks.push_back(name);
        }

        for (std::string& name : allOtherBlocks) {
            RegisterBlock(name, new MaterialNone(), false, true, false);
        }

    }
    catch (std::filesystem::filesystem_error& e) {
        g_logger.LogError("BlockList::AddAssets", e.what());
    }
}


void BlockList::InitializeBlockModels()  {
    //add every single block  in the assets bc why not
    //try {
    //    for (const auto& entry : std::filesystem::directory_iterator("assets")) {
    //        if (!entry.is_directory()) continue;
    //        std::string name = entry.path().filename().string();//epic one liner
    //        if (!strcmp(name.c_str(), "shaders")) continue;
    //        AddAssets(name);
    //    }

    //}
    //catch (std::filesystem::filesystem_error& e) {
    //    g_logger.LogError("File System", e.what());
    //}

    FastHashMap<std::string, size_t> textureIds;
    FastHashMap<size_t, size_t> textureRepeatCount;
    FastHashMap<size_t, bool> textureTransparency;
    FastHashMap<size_t, bool> textureSeeThrough;
 
    //It will first go through the block models and create the models without loading the texture
    for (const auto& [name, ID] : block_id_name_data_) {
        auto tokens = Tokenize(name, ':');

        std::unique_ptr<Model::BlockModel> model = getBlockModel("block/" + tokens.back(), tokens.front());
        model->is_initialized_ = true;
        GetBlockType(ID)->block_model_data_ = std::move(model);
    }

    //Bake all of the texture variables next

    for (auto& block : block_type_data_) {
        if (block->block_model_data_ == NULL) continue;
        block->block_model_data_->FlattenVariables();
    }

    //Bake all rotations into the UV
    for (auto& block : block_type_data_) {
        if (block->block_model_data_ == NULL) continue;
        block->block_model_data_->BakeTextureRotation();
    }

    //Generate all the textures now
    for (auto& block  : block_type_data_) {
        if (block->block_model_data_ == NULL) continue;

        for (auto& element : block->block_model_data_->elements_) {
            for (int i = 0; i < 6; i++) {
                const  std::string& path = element.faces_[i].reference_texture_;
                if (path.length() == 0) continue;

                //Check if it is loaded already
                if (textureIds.count(path)) {
                    element.faces_[i].texture_id_ = textureIds[path];
                    element.faces_[i].texture_count_ = textureRepeatCount[element.faces_[i].texture_id_];
                    element.faces_[i].has_transparency_ = textureTransparency[element.faces_[i].texture_id_];
                    element.faces_[i].is_see_through_ = textureSeeThrough[element.faces_[i].texture_id_];
                    continue; //Exits
                }

                auto Tokens = Tokenize(path, ':');

                //Load texture
                std::string TexFile = "assets/" + Tokens.back() + "/textures/" + Tokens.front() + ".png";

                size_t numLayersBefore = block_texture_atlas_->GetBlockCount();

                // glm::vec4 uv{};

                bool transparency = false;
                bool isSeeThrough = false;

                std::optional<RawTextureData> d = block_texture_atlas_->AddTextureToAtlas(TexFile, transparency, isSeeThrough);

                if (!d.has_value()) {
                    g_logger.LogError("BlockList::InitializeBlockModel", "Unable to load texture");
                    continue;
                }

                textureIds[path] = numLayersBefore + 1;
                textureRepeatCount[numLayersBefore + 1] = block_texture_atlas_->GetBlockCount() - numLayersBefore;
                textureTransparency[numLayersBefore + 1] = transparency;
                textureSeeThrough[numLayersBefore + 1] = isSeeThrough;


                element.faces_[i].texture_id_ = textureIds[path];
                element.faces_[i].texture_count_ = textureRepeatCount[element.faces_[i].texture_id_];
                element.faces_[i].has_transparency_ = transparency;
                element.faces_[i].is_see_through_ = isSeeThrough;
            }
        }
    }


    for (int i = 0; i < block_type_data_.size(); i++) {
        Model::BlockModel model;

        if (block_type_data_[i]->block_model_data_ != NULL) {
            model = *block_type_data_[i]->block_model_data_;
        }
        model.texture_variable_.clear();
        block_model_data_.emplace_back(model);
    }
}

void BlockList::Initialize() {
    block_texture_atlas_ = std::make_unique<TextureAtlas>();
    block_texture_atlas_->Gen();
    block_texture_atlas_->SetSize(16 * 512, 16 * 512);

    InitializeBlockModels();

    block_texture_atlas_->UploadToGPU();
}

BlockList::BlockList() : block_texture_atlas_{ std::make_unique<TextureAtlas>() } {

}

BlockList::~BlockList() {
    CleanUp();
}

void BlockList::CleanUp() {
    for (const auto& obj : block_type_data_) {
        delete obj;
    }

    block_type_data_.clear();
}

Block* BlockList::GetBlockType(BlockID id) {
    return block_type_data_[id];
}

const Model::BlockModel& BlockList::GetBlockModelDereferenced(BlockID id) {
    return block_model_data_[id];
}
"./Level\\Chunk\\Block\\Blocks.h"
#pragma once
#include <memory>
#include <vector>

#include "../../Typenames.h"
#include "Material/BlockMaterial.h"

class TextureAtlas;

namespace Model {
    struct BlockModel;
}

class BlockList{
private:
    FastHashMap<std::string, BlockID> block_id_name_data_;
    int block_type_count_ = 0;

    void InitializeBlockModels();
    void AddAssets(std::string namespaceIn);
public:
    std::vector<Block*> block_type_data_;
    std::vector<Model::BlockModel> block_model_data_;

    std::unique_ptr<TextureAtlas> block_texture_atlas_;


    BlockID AIR = RegisterBlock("minecraft:air", new MaterialNone(), true, false, false);
    BlockID NULL_BLOCK = RegisterBlock("minecraft:null", new MaterialNone(), false, false, false);
    BlockID STONE = RegisterBlock("minecraft:stone", new MaterialNone(), false, true, false);
    BlockID DIRT = RegisterBlock("minecraft:dirt", new MaterialDirt(), false, true, false);
    BlockID WATER = RegisterBlock("minecraft:water", new MaterialFluid(5), true, false, true);
    BlockID LAVA = RegisterBlock("minecraft:lava", new MaterialFluid(5), true, false, true);
    BlockID GRASS = RegisterBlock("minecraft:grass_block", new MaterialGrass(0.1, 0.1), false, true, false);
    BlockID SAND = RegisterBlock("minecraft:sand", new MaterialGravity(), false, true, false);
    BlockID OAK_LOG = RegisterBlock("minecraft:oak_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_OAK_LOG = RegisterBlock("minecraft:stripped_oak_log", new MaterialNone(), false, true, false);
    BlockID OAK_PLANKS = RegisterBlock("minecraft:oak_planks", new MaterialNone(), false, true, false);
    BlockID ACACIA_PLANKS = RegisterBlock("minecraft:acacia_planks", new MaterialNone(), false, true, false);
    BlockID BAMBOO_PLANKS = RegisterBlock("minecraft:bamboo_planks", new MaterialNone(), false, true, false);
    BlockID BIRCH_PLANKS = RegisterBlock("minecraft:birch_planks", new MaterialNone(), false, true, false);
    BlockID CHERRY_PLANKS = RegisterBlock("minecraft:cherry_planks", new MaterialNone(), false, true, false);
    BlockID CRIMSON_PLANKS = RegisterBlock("minecraft:crimson_planks", new MaterialNone(), false, true, false);
    BlockID DARK_OAK_PLANKS = RegisterBlock("minecraft:dark_oak_planks", new MaterialNone(), false, true, false);
    BlockID JUNGLE_PLANKS = RegisterBlock("minecraft:jungle_planks", new MaterialNone(), false, true, false);
    BlockID MANGROVE_PLANKS = RegisterBlock("minecraft:mangrove_planks", new MaterialNone(), false, true, false);
    BlockID SPRUCE_PLANKS = RegisterBlock("minecraft:spruce_planks", new MaterialNone(), false, true, false);
    BlockID WARPED_PLANKS = RegisterBlock("minecraft:warped_planks", new MaterialNone(), false, true, false);
    BlockID OAK_WOOD = RegisterBlock("minecraft:oak_wood", new MaterialNone(), false, true, false);
    BlockID ACACIA_WOOD = RegisterBlock("minecraft:acacia_wood", new MaterialNone(), false, true, false);
    BlockID BIRCH_WOOD = RegisterBlock("minecraft:birch_wood", new MaterialNone(), false, true, false);
    BlockID CHERRY_WOOD = RegisterBlock("minecraft:cherry_wood", new MaterialNone(), false, true, false);
    BlockID DARK_OAK_WOOD = RegisterBlock("minecraft:dark_oak_wood", new MaterialNone(), false, true, false);
    BlockID JUNGLE_WOOD = RegisterBlock("minecraft:jungle_wood", new MaterialNone(), false, true, false);
    BlockID MANGROVE_WOOD = RegisterBlock("minecraft:mangrove_wood", new MaterialNone(), false, true, false);
    BlockID SPRUCE_WOOD = RegisterBlock("minecraft:spruce_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_OAK_WOOD = RegisterBlock("minecraft:stripped_oak_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_ACACIA_WOOD = RegisterBlock("minecraft:stripped_acacia_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_BIRCH_WOOD = RegisterBlock("minecraft:stripped_birch_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_CHERRY_WOOD = RegisterBlock("minecraft:stripped_cherry_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_DARK_OAK_WOOD = RegisterBlock("minecraft:stripped_dark_oak_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_JUNGLE_WOOD = RegisterBlock("minecraft:stripped_jungle_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_MANGROVE_WOOD = RegisterBlock("minecraft:stripped_mangrove_wood", new MaterialNone(), false, true, false);
    BlockID STRIPPED_SPRUCE_WOOD = RegisterBlock("minecraft:stripped_spruce_wood", new MaterialNone(), false, true, false);
    BlockID BRICKS = RegisterBlock("minecraft:bricks", new MaterialNone(), false, true, false);
    BlockID STONE_BRICKS = RegisterBlock("minecraft:stone_bricks", new MaterialNone(), false, true, false);
    BlockID CRACKED_STONE_BRICKS = RegisterBlock("minecraft:cracked_stone_bricks", new MaterialNone(), false, true, false);
    BlockID CHISELED_STONE_BRICKS = RegisterBlock("minecraft:chiseled_stone_bricks", new MaterialNone(), false, true, false);
    BlockID MOSSY_STONE_BRICKS = RegisterBlock("minecraft:mossy_stone_bricks", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_BRICKS = RegisterBlock("minecraft:deepslate_bricks", new MaterialNone(), false, true, false);
    BlockID CRACKED_DEEPSLATE_BRICKS = RegisterBlock("minecraft:cracked_deepslate_bricks", new MaterialNone(), false, true, false);
    BlockID TUFF_BRICKS = RegisterBlock("minecraft:tuff_bricks", new MaterialNone(), false, true, false);
    BlockID CHISELED_TUFF_BRICKS = RegisterBlock("minecraft:chiseled_tuff_bricks", new MaterialNone(), false, true, false);
    BlockID MUD_BRICKS = RegisterBlock("minecraft:mud_bricks", new MaterialNone(), false, true, false);
    BlockID PRISMARINE_BRICKS = RegisterBlock("minecraft:prismarine_bricks", new MaterialNone(), false, true, false);
    BlockID NETHER_BRICKS = RegisterBlock("minecraft:nether_bricks", new MaterialNone(), false, true, false);
    BlockID CRACKED_NETHER_BRICKS = RegisterBlock("minecraft:cracked_nether_bricks", new MaterialNone(), false, true, false);
    BlockID CHISELED_NETHER_BRICKS = RegisterBlock("minecraft:chiseled_nether_bricks", new MaterialNone(), false, true, false);
    BlockID RED_NETHER_BRICKS = RegisterBlock("minecraft:red_nether_bricks", new MaterialNone(), false, true, false);
    BlockID POLISHED_BLACKSTONE_BRICK = RegisterBlock("minecraft:polished_blackstone_bricks", new MaterialNone(), false, true, false);
    BlockID CRACKED_POLISHED_BLACKSTONE_BRICK = RegisterBlock("minecraft:cracked_polished_blackstone_bricks", new MaterialNone(), false, true, false);
    BlockID END_STONE_BRICKS = RegisterBlock("minecraft:end_stone_bricks", new MaterialNone(), false, true, false);
    BlockID COBBLESTONE = RegisterBlock("minecraft:cobblestone", new MaterialNone(), false, true, false);
    BlockID BLUE_STAINED_GLASS = RegisterBlock("minecraft:blue_stained_glass", new MaterialNone(), true, true, false);
    BlockID GREEN_STAINED_GLASS = RegisterBlock("minecraft:green_stained_glass", new MaterialNone(), true, true, false);
    BlockID BLACK_STAINED_GLASS = RegisterBlock("minecraft:black_stained_glass", new MaterialNone(), true, true, false);
    BlockID BROWN_STAINED_GLASS = RegisterBlock("minecraft:brown_stained_glass", new MaterialNone(), true, true, false);
    BlockID CYAN_STAINED_GLASS = RegisterBlock("minecraft:cyan_stained_glass", new MaterialNone(), true, true, false);
    BlockID GRAY_STAINED_GLASS = RegisterBlock("minecraft:gray_stained_glass", new MaterialNone(), true, true, false);
    BlockID LIGHT_BLUE_STAINED_GLASS = RegisterBlock("minecraft:light_blue_stained_glass", new MaterialNone(), true, true, false);
    BlockID LIGHT_GRAY_STAINED_GLASS = RegisterBlock("minecraft:light_gray_stained_glass", new MaterialNone(), true, true, false);
    BlockID LIME_STAINED_GLASS = RegisterBlock("minecraft:lime_stained_glass", new MaterialNone(), true, true, false);
    BlockID MAGENTA_STAINED_GLASS = RegisterBlock("minecraft:magenta_stained_glass", new MaterialNone(), true, true, false);
    BlockID ORANGE_STAINED_GLASS = RegisterBlock("minecraft:orange_stained_glass", new MaterialNone(), true, true, false);
    BlockID PINK_STAINED_GLASS = RegisterBlock("minecraft:pink_stained_glass", new MaterialNone(), true, true, false);
    BlockID PURPLE_STAINED_GLASS = RegisterBlock("minecraft:purple_stained_glass", new MaterialNone(), true, true, false);
    BlockID RED_STAINED_GLASS = RegisterBlock("minecraft:red_stained_glass", new MaterialNone(), true, true, false);
    BlockID WHITE_STAINED_GLASS = RegisterBlock("minecraft:white_stained_glass", new MaterialNone(), true, true, false);
    BlockID YELLOW_STAINED_GLASS = RegisterBlock("minecraft:yellow_stained_glass", new MaterialNone(), true, true, false);
    BlockID WHITE_WOOL = RegisterBlock("minecraft:white_wool", new MaterialNone(), false, true, false);
    BlockID BLACK_WOOL = RegisterBlock("minecraft:black_wool", new MaterialNone(), false, true, false);
    BlockID BLUE_WOOL = RegisterBlock("minecraft:blue_wool", new MaterialNone(), false, true, false);
    BlockID BROWN_WOOL = RegisterBlock("minecraft:brown_wool", new MaterialNone(), false, true, false);
    BlockID CYAN_WOOL = RegisterBlock("minecraft:cyan_wool", new MaterialNone(), false, true, false);
    BlockID GRAY_WOOL = RegisterBlock("minecraft:gray_wool", new MaterialNone(), false, true, false);
    BlockID GREEN_WOOL = RegisterBlock("minecraft:green_wool", new MaterialNone(), false, true, false);
    BlockID LIGHT_BLUE_WOOL = RegisterBlock("minecraft:light_blue_wool", new MaterialNone(), false, true, false);
    BlockID LIGHT_GRAY_WOOL = RegisterBlock("minecraft:light_gray_wool", new MaterialNone(), false, true, false);
    BlockID LIME_WOOL = RegisterBlock("minecraft:lime_wool", new MaterialNone(), false, true, false);
    BlockID MAGENTA_WOOL = RegisterBlock("minecraft:magenta_wool", new MaterialNone(), false, true, false);
    BlockID ORANGE_WOOL = RegisterBlock("minecraft:orange_wool", new MaterialNone(), false, true, false);
    BlockID PINK_WOOL = RegisterBlock("minecraft:pink_wool", new MaterialNone(), false, true, false);
    BlockID PURPLE_WOOL = RegisterBlock("minecraft:purple_wool", new MaterialNone(), false, true, false);
    BlockID RED_WOOL = RegisterBlock("minecraft:red_wool", new MaterialNone(), false, true, false);
    BlockID YELLOW_WOOL = RegisterBlock("minecraft:yellow_wool", new MaterialNone(), false, true, false);
    BlockID WHITE_TERRACOTTA = RegisterBlock("minecraft:white_terracotta", new MaterialNone(), false, true, false);
    BlockID BLACK_TERRACOTTA = RegisterBlock("minecraft:black_terracotta", new MaterialNone(), false, true, false);
    BlockID BLUE_TERRACOTTA = RegisterBlock("minecraft:blue_terracotta", new MaterialNone(), false, true, false);
    BlockID BROWN_TERRACOTTA = RegisterBlock("minecraft:brown_terracotta", new MaterialNone(), false, true, false);
    BlockID CYAN_TERRACOTTA = RegisterBlock("minecraft:cyan_terracotta", new MaterialNone(), false, true, false);
    BlockID GRAY_TERRACOTTA = RegisterBlock("minecraft:gray_terracotta", new MaterialNone(), false, true, false);
    BlockID GREEN_TERRACOTTA = RegisterBlock("minecraft:green_terracotta", new MaterialNone(), false, true, false);
    BlockID LIGHT_BLUE_TERRACOTTA = RegisterBlock("minecraft:light_blue_terracotta", new MaterialNone(), false, true, false);
    BlockID LIGHT_GRAY_TERRACOTTA = RegisterBlock("minecraft:light_gray_terracotta", new MaterialNone(), false, true, false);
    BlockID LIME_TERRACOTTA = RegisterBlock("minecraft:lime_terracotta", new MaterialNone(), false, true, false);
    BlockID MAGENTA_TERRACOTTA = RegisterBlock("minecraft:magenta_terracotta", new MaterialNone(), false, true, false);
    BlockID ORANGE_TERRACOTTA = RegisterBlock("minecraft:orange_terracotta", new MaterialNone(), false, true, false);
    BlockID PINK_TERRACOTTA = RegisterBlock("minecraft:pink_terracotta", new MaterialNone(), false, true, false);
    BlockID PURPLE_TERRACOTTA = RegisterBlock("minecraft:purple_terracotta", new MaterialNone(), false, true, false);
    BlockID RED_TERRACOTTA = RegisterBlock("minecraft:red_terracotta", new MaterialNone(), false, true, false);
    BlockID YELLOW_TERRACOTTA = RegisterBlock("minecraft:yellow_terracotta", new MaterialNone(), false, true, false);
    BlockID WHITE_GLAZED_TERRACOTTA = RegisterBlock("minecraft:white_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID BLACK_GLAZED_TERRACOTTA = RegisterBlock("minecraft:black_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID BLUE_GLAZED_TERRACOTTA = RegisterBlock("minecraft:blue_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID BROWN_GLAZED_TERRACOTTA = RegisterBlock("minecraft:brown_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID CYAN_GLAZED_TERRACOTTA = RegisterBlock("minecraft:cyan_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID GRAY_GLAZED_TERRACOTTA = RegisterBlock("minecraft:gray_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID GREEN_GLAZED_TERRACOTTA = RegisterBlock("minecraft:green_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID LIGHT_BLUE_GLAZED_TERRACOTTA = RegisterBlock("minecraft:light_blue_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID LIGHT_GRAY_GLAZED_TERRACOTTA = RegisterBlock("minecraft:light_gray_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID LIME_GLAZED_TERRACOTTA = RegisterBlock("minecraft:lime_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID MAGENTA_GLAZED_TERRACOTTA = RegisterBlock("minecraft:magenta_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID ORANGE_GLAZED_TERRACOTTA = RegisterBlock("minecraft:orange_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID PINK_GLAZED_TERRACOTTA = RegisterBlock("minecraft:pink_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID PURPLE_GLAZED_TERRACOTTA = RegisterBlock("minecraft:purple_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID RED_GLAZED_TERRACOTTA = RegisterBlock("minecraft:red_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID YELLOW_GLAZED_TERRACOTTA = RegisterBlock("minecraft:yellow_glazed_terracotta", new MaterialNone(), false, true, false);
    BlockID TERRACOTTA = RegisterBlock("minecraft:terracotta", new MaterialNone(), false, true, false);
    BlockID WHITE_CONCRETE = RegisterBlock("minecraft:white_concrete", new MaterialNone(), false, true, false);
    BlockID BLACK_CONCRETE = RegisterBlock("minecraft:black_concrete", new MaterialNone(), false, true, false);
    BlockID BLUE_CONCRETE = RegisterBlock("minecraft:blue_concrete", new MaterialNone(), false, true, false);
    BlockID BROWN_CONCRETE = RegisterBlock("minecraft:brown_concrete", new MaterialNone(), false, true, false);
    BlockID CYAN_CONCRETE = RegisterBlock("minecraft:cyan_concrete", new MaterialNone(), false, true, false);
    BlockID GRAY_CONCRETE = RegisterBlock("minecraft:gray_concrete", new MaterialNone(), false, true, false);
    BlockID GREEN_CONCRETE = RegisterBlock("minecraft:green_concrete", new MaterialNone(), false, true, false);
    BlockID LIGHT_BLUE_CONCRETE = RegisterBlock("minecraft:light_blue_concrete", new MaterialNone(), false, true, false);
    BlockID LIGHT_GRAY_CONCRETE = RegisterBlock("minecraft:light_gray_concrete", new MaterialNone(), false, true, false);
    BlockID LIME_CONCRETE = RegisterBlock("minecraft:lime_concrete", new MaterialNone(), false, true, false);
    BlockID MAGENTA_CONCRETE = RegisterBlock("minecraft:magenta_concrete", new MaterialNone(), false, true, false);
    BlockID ORANGE_CONCRETE = RegisterBlock("minecraft:orange_concrete", new MaterialNone(), false, true, false);
    BlockID PINK_CONCRETE = RegisterBlock("minecraft:pink_concrete", new MaterialNone(), false, true, false);
    BlockID PURPLE_CONCRETE = RegisterBlock("minecraft:purple_concrete", new MaterialNone(), false, true, false);
    BlockID RED_CONCRETE = RegisterBlock("minecraft:red_concrete", new MaterialNone(), false, true, false);
    BlockID YELLOW_CONCRETE = RegisterBlock("minecraft:yellow_concrete", new MaterialNone(), false, true, false);
    BlockID WHITE_CONCRETE_POWDER = RegisterBlock("minecraft:white_concrete_powder", new MaterialNone(), false, true, false); //FIX POWDERS LATER
    BlockID BLACK_CONCRETE_POWDER = RegisterBlock("minecraft:black_concrete_powder", new MaterialNone(), false, true, false);
    BlockID BLUE_CONCRETE_POWDER = RegisterBlock("minecraft:blue_concrete_powder", new MaterialNone(), false, true, false);
    BlockID BROWN_CONCRETE_POWDER = RegisterBlock("minecraft:brown_concrete_powder", new MaterialNone(), false, true, false);
    BlockID CYAN_CONCRETE_POWDER = RegisterBlock("minecraft:cyan_concrete_powder", new MaterialNone(), false, true, false);
    BlockID GRAY_CONCRETE_POWDER = RegisterBlock("minecraft:gray_concrete_powder", new MaterialNone(), false, true, false);
    BlockID GREEN_CONCRETE_POWDER = RegisterBlock("minecraft:green_concrete_powder", new MaterialNone(), false, true, false);
    BlockID LIGHT_BLUE_CONCRETE_POWDER = RegisterBlock("minecraft:light_blue_concrete_powder", new MaterialNone(), false, true, false);
    BlockID LIGHT_GRAY_CONCRETE_POWDER = RegisterBlock("minecraft:light_gray_concrete_powder", new MaterialNone(), false, true, false);
    BlockID LIME_CONCRETE_POWDER = RegisterBlock("minecraft:lime_concrete_powder", new MaterialNone(), false, true, false);
    BlockID MAGENTA_CONCRETE_POWDER = RegisterBlock("minecraft:magenta_concrete_powder", new MaterialNone(), false, true, false);
    BlockID ORANGE_CONCRETE_POWDER = RegisterBlock("minecraft:orange_concrete_powder", new MaterialNone(), false, true, false);
    BlockID PINK_CONCRETE_POWDER = RegisterBlock("minecraft:pink_concrete_powder", new MaterialNone(), false, true, false);
    BlockID PURPLE_CONCRETE_POWDER = RegisterBlock("minecraft:purple_concrete_powder", new MaterialNone(), false, true, false);
    BlockID RED_CONCRETE_POWDER = RegisterBlock("minecraft:red_concrete_powder", new MaterialNone(), false, true, false);
    BlockID YELLOW_CONCRETE_POWDER = RegisterBlock("minecraft:yellow_concrete_powder", new MaterialNone(), false, true, false);
    BlockID PODZOL = RegisterBlock("minecraft:podzol", new MaterialNone(), false, true, false);
    BlockID MYCELIUM = RegisterBlock("minecraft:mycelium", new MaterialNone(), false, true, false);
    BlockID DIRT_PATH = RegisterBlock("minecraft:dirt_path", new MaterialNone(), false, true, false);
    BlockID COARSE_DIRT = RegisterBlock("minecraft:coarse_dirt", new MaterialNone(), false, true, false);
    BlockID ROOTED_DIRT = RegisterBlock("minecraft:rooted_dirt", new MaterialNone(), false, true, false);
    BlockID FARMLAND = RegisterBlock("minecraft:farmland", new MaterialNone(), false, true, false);
    BlockID FARMLAND_MOIST = RegisterBlock("minecraft:farmland_moist", new MaterialNone(), false, true, false);
    BlockID MUD = RegisterBlock("minecraft:mud", new MaterialNone(), false, true, false);
    BlockID CLAY = RegisterBlock("minecraft:clay", new MaterialNone(), false, true, false);
    BlockID GRAVEL = RegisterBlock("minecraft:gravel", new MaterialNone(), false, true, false); //Change to falling block later
    BlockID RED_SAND = RegisterBlock("minecraft:red_sand", new MaterialNone(), false, true, false); //Change to falling block later
    BlockID ICE = RegisterBlock("minecraft:ice", new MaterialNone(), true, true, false);
    BlockID BLUE_ICE = RegisterBlock("minecraft:blue_ice", new MaterialNone(), false, true, false);
    BlockID SNOW_BLOCK = RegisterBlock("minecraft:snow_block", new MaterialNone(), false, true, false);
    BlockID MOSS_BLOCK = RegisterBlock("minecraft:moss_block", new MaterialNone(), false, true, false);
    BlockID GRANITE = RegisterBlock("minecraft:granite", new MaterialNone(), false, true, false);
    BlockID DIORITE = RegisterBlock("minecraft:diorite", new MaterialNone(), false, true, false);
    BlockID ANDESITE = RegisterBlock("minecraft:andesite", new MaterialNone(), false, true, false);
    BlockID CALCITE = RegisterBlock("minecraft:calcite", new MaterialNone(), false, true, false);
    BlockID DRIPSTONE_BLOCK = RegisterBlock("minecraft:dripstone_block", new MaterialNone(), false, true, false);
    BlockID PRISMARINE = RegisterBlock("minecraft:prismarine", new MaterialNone(), false, true, false);
    BlockID MAGMA = RegisterBlock("minecraft:magma_block", new MaterialNone(), false, true, false); //special properties
    BlockID OBSIDIAN = RegisterBlock("minecraft:obsidian", new MaterialNone(), false, true, false);
    BlockID CRYING_OBSIDIAN = RegisterBlock("minecraft:crying_obsidian", new MaterialNone(), false, true, false);
    BlockID NETHERRACK = RegisterBlock("minecraft:netherrack", new MaterialNone(), false, true, false);
    BlockID CRIMSON_NYLIUM = RegisterBlock("minecraft:crimson_nylium", new MaterialNone(), false, true, false);
    BlockID WARPED_NYLIUM = RegisterBlock("minecraft:warped_nylium", new MaterialNone(), false, true, false);
    BlockID SOUL_SAND = RegisterBlock("minecraft:soul_sand", new MaterialNone(), false, true, false);
    BlockID SOUL_SOIL = RegisterBlock("minecraft:soul_soil", new MaterialNone(), false, true, false);
    BlockID BONE_BLOCK = RegisterBlock("minecraft:bone_block", new MaterialNone(), false, true, false);
    BlockID BLACKSTONE = RegisterBlock("minecraft:blackstone", new MaterialNone(), false, true, false);
    BlockID BASALT = RegisterBlock("minecraft:basalt", new MaterialNone(), false, true, false);
    BlockID SMOOTH_BASALT = RegisterBlock("minecraft:smooth_basalt", new MaterialNone(), false, true, false);
    BlockID END_STONE = RegisterBlock("minecraft:end_stone", new MaterialNone(), false, true, false);
    BlockID COAL_ORE = RegisterBlock("minecraft:coal_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_COAL_ORE = RegisterBlock("minecraft:deepslate_coal_ore", new MaterialNone(), false, true, false);
    BlockID IRON_ORE = RegisterBlock("minecraft:iron_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_IRON_ORE = RegisterBlock("minecraft:deepslate_iron_ore", new MaterialNone(), false, true, false);
    BlockID COPPER_ORE = RegisterBlock("minecraft:copper_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_COPPER_ORE = RegisterBlock("minecraft:deepslate_copper_ore", new MaterialNone(), false, true, false);
    BlockID GOLD_ORE = RegisterBlock("minecraft:gold_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_GOLD_ORE = RegisterBlock("minecraft:deepslate_gold_ore", new MaterialNone(), false, true, false);
    BlockID REDSTONE_ORE = RegisterBlock("minecraft:redstone_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_REDSTONE_ORE = RegisterBlock("minecraft:deepslate_redstone_ore", new MaterialNone(), false, true, false);
    BlockID EMERALD_ORE = RegisterBlock("minecraft:emerald_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_EMERALD_ORE = RegisterBlock("minecraft:deepslate_emerald_ore", new MaterialNone(), false, true, false);
    BlockID LAPIS_ORE = RegisterBlock("minecraft:lapis_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_LAPIS_ORE = RegisterBlock("minecraft:deepslate_lapis_ore", new MaterialNone(), false, true, false);
    BlockID DIAMOND_ORE = RegisterBlock("minecraft:diamond_ore", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_DIAMOND_ORE = RegisterBlock("minecraft:deepslate_diamond_ore", new MaterialNone(), false, true, false);
    BlockID NETHER_GOLD_ORE = RegisterBlock("minecraft:nether_gold_ore", new MaterialNone(), false, true, false);
    BlockID NETHER_QUARTZ_ORE = RegisterBlock("minecraft:nether_quartz_ore", new MaterialNone(), false, true, false);
    BlockID ANCIENT_DEBRIS = RegisterBlock("minecraft:ancient_debris", new MaterialNone(), false, true, false);
    BlockID RAW_IRON_BLOCK = RegisterBlock("minecraft:raw_iron_block", new MaterialNone(), false, true, false);
    BlockID RAW_COPPER_BLOCK = RegisterBlock("minecraft:raw_copper_block", new MaterialNone(), false, true, false);
    BlockID RAW_GOLD_BLOCK = RegisterBlock("minecraft:raw_gold_block", new MaterialNone(), false, true, false);
    BlockID GLOWSTONE = RegisterBlock("minecraft:glowstone", new MaterialNone(), false, true, false);
    BlockID AMETHYST_BLOCK = RegisterBlock("minecraft:amethyst_block", new MaterialNone(), false, true, false);
    BlockID BUDDING_AMETHYST = RegisterBlock("minecraft:budding_amethyst", new MaterialNone(), false, true, false);
    BlockID SPRUCE_LOG = RegisterBlock("minecraft:spruce_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_SPRUCE_LOG = RegisterBlock("minecraft:stripped_spruce_log", new MaterialNone(), false, true, false);
    BlockID BIRCH_LOG = RegisterBlock("minecraft:birch_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_BIRCH_LOG = RegisterBlock("minecraft:stripped_birch_log", new MaterialNone(), false, true, false);
    BlockID JUNGLE_LOG = RegisterBlock("minecraft:jungle_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_JUNGLE_LOG = RegisterBlock("minecraft:stripped_jungle_log", new MaterialNone(), false, true, false);
    BlockID ACACIA_LOG = RegisterBlock("minecraft:acacia_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_ACACIA_LOG = RegisterBlock("minecraft:stripped_acacia_log", new MaterialNone(), false, true, false);
    BlockID DARK_OAK_LOG = RegisterBlock("minecraft:dark_oak_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_DARK_OAK_LOG = RegisterBlock("minecraft:stripped_dark_oak_log", new MaterialNone(), false, true, false);
    BlockID CHERRY_LOG = RegisterBlock("minecraft:cherry_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_CHERRY_LOG = RegisterBlock("minecraft:stripped_cherry_log", new MaterialNone(), false, true, false);
    BlockID MANGROVE_LOG = RegisterBlock("minecraft:mangrove_log", new MaterialNone(), false, true, false);
    BlockID STRIPPED_MANGROVE_LOG = RegisterBlock("minecraft:stripped_mangrove_log", new MaterialNone(), false, true, false);
    BlockID CRIMSON_STEM = RegisterBlock("minecraft:crimson_stem", new MaterialNone(), false, true, false);
    BlockID STRIPPED_CRIMSON_STEM = RegisterBlock("minecraft:stripped_crimson_stem", new MaterialNone(), false, true, false);
    BlockID WARPED_STEM = RegisterBlock("minecraft:warped_stem", new MaterialNone(), false, true, false);
    BlockID STRIPPED_WARPED_STEM = RegisterBlock("minecraft:stripped_warped_stem", new MaterialNone(), false, true, false);
    BlockID MANGROVE_ROOTS = RegisterBlock("minecraft:mangrove_roots", new MaterialNone(), true, true, false);
    BlockID MUDDY_MANGROVE_ROOTS = RegisterBlock("minecraft:muddy_mangrove_roots", new MaterialNone(), false, true, false);
    BlockID MUSHROOM_STEM = RegisterBlock("minecraft:mushroom_stem", new MaterialNone(), false, true, false);
    BlockID BROWN_MUSHROOM_BLOCK = RegisterBlock("minecraft:brown_mushroom_block", new MaterialNone(), false, true, false);
    BlockID RED_MUSHROOM_BLOCK = RegisterBlock("minecraft:red_mushroom_block", new MaterialNone(), false, true, false);
    BlockID NETHER_WART_BLOCK = RegisterBlock("minecraft:nether_wart_block", new MaterialNone(), false, true, false);
    BlockID WARPED_WART_BLOCK = RegisterBlock("minecraft:warped_wart_block", new MaterialNone(), false, true, false);
    BlockID SHROOMLIGHT = RegisterBlock("minecraft:shroomlight", new MaterialNone(), false, true, false);
    BlockID DRIED_KELP_BLOCK = RegisterBlock("minecraft:dried_kelp_block", new MaterialNone(), false, true, false);
    BlockID TUBE_CORAL_BLOCK = RegisterBlock("minecraft:tube_coral_block", new MaterialNone(), false, true, false);
    BlockID BRAIN_CORAL_BLOCK = RegisterBlock("minecraft:brain_coral_block", new MaterialNone(), false, true, false);
    BlockID BUBBLE_CORAL_BLOCK = RegisterBlock("minecraft:bubble_coral_block", new MaterialNone(), false, true, false);
    BlockID FIRE_CORAL_BLOCK = RegisterBlock("minecraft:fire_coral_block", new MaterialNone(), false, true, false);
    BlockID HORN_CORAL_BLOCK = RegisterBlock("minecraft:horn_coral_block", new MaterialNone(), false, true, false);
    BlockID DEAD_TUBE_CORAL_BLOCK = RegisterBlock("minecraft:dead_tube_coral_block", new MaterialNone(), false, true, false);
    BlockID DEAD_BRAIN_CORAL_BLOCK = RegisterBlock("minecraft:dead_brain_coral_block", new MaterialNone(), false, true, false);
    BlockID DEAD_BUBBLE_CORAL_BLOCK = RegisterBlock("minecraft:dead_bubble_coral_block", new MaterialNone(), false, true, false);
    BlockID DEAD_FIRE_CORAL_BLOCK = RegisterBlock("minecraft:dead_fire_coral_block", new MaterialNone(), false, true, false);
    BlockID DEAD_HORN_CORAL_BLOCK = RegisterBlock("minecraft:dead_horn_coral_block", new MaterialNone(), false, true, false);
    BlockID SPONGE = RegisterBlock("minecraft:sponge", new MaterialNone(), false, true, false);
    BlockID WET_SPONGE = RegisterBlock("minecraft:wet_sponge", new MaterialNone(), false, true, false);
    BlockID MELON = RegisterBlock("minecraft:melon", new MaterialNone(), false, true, false);
    BlockID PUMPKIN = RegisterBlock("minecraft:pumpkin", new MaterialNone(), false, true, false);
    BlockID CARVED_PUMPKIN = RegisterBlock("minecraft:carved_pumpkin", new MaterialNone(), false, true, false);
    BlockID JACK_O_LANTERN = RegisterBlock("minecraft:jack_o_lantern", new MaterialNone(), false, true, false);
    BlockID HAY_BALE = RegisterBlock("minecraft:hay_block", new MaterialNone(), false, true, false);
    BlockID BEE_NEST = RegisterBlock("minecraft:bee_nest", new MaterialNone(), false, true, false);
    BlockID HONEYCOMB_BLOCK = RegisterBlock("minecraft:honeycomb_block", new MaterialNone(), false, true, false);
    BlockID OCHRE_FROGLIGHT = RegisterBlock("minecraft:ochre_froglight", new MaterialNone(), false, true, false);
    BlockID VERDANT_FROGLIGHT = RegisterBlock("minecraft:verdant_froglight", new MaterialNone(), false, true, false);
    BlockID PEARLESCENT_FROGLIGHT = RegisterBlock("minecraft:pearlescent_froglight", new MaterialNone(), false, true, false);
    BlockID SCULK = RegisterBlock("minecraft:sculk", new MaterialNone(), false, true, false);
    BlockID SCULK_CATALYST = RegisterBlock("minecraft:sculk_catalyst", new MaterialNone(), false, true, false);
    BlockID BEDROCK = RegisterBlock("minecraft:bedrock", new MaterialNone(), false, true, false);
    BlockID SPRUCE_LEAVES = RegisterBlock("minecraft:spruce_leaves", new MaterialNone(), true, true, false);
    BlockID BIRCH_LEAVES = RegisterBlock("minecraft:birch_leaves", new MaterialNone(), true, true, false);
    BlockID JUNGLE_LEAVES = RegisterBlock("minecraft:jungle_leaves", new MaterialNone(), true, true, false);
    BlockID ACACIA_LEAVES = RegisterBlock("minecraft:acacia_leaves", new MaterialNone(), true, true, false);
    BlockID DARK_OAK_LEAVES = RegisterBlock("minecraft:dark_oak_leaves", new MaterialNone(), true, true, false);
    BlockID MANGROVE_LEAVES = RegisterBlock("minecraft:mangrove_leaves", new MaterialNone(), true, true, false);
    BlockID CHERRY_LEAVES = RegisterBlock("minecraft:cherry_leaves", new MaterialNone(), true, true, false);
    BlockID AZALEA_LEAVES = RegisterBlock("minecraft:azalea_leaves", new MaterialNone(), true, true, false);
    BlockID FLOWERING_AZALEA_LEAVES = RegisterBlock("minecraft:flowering_azalea_leaves", new MaterialNone(), true, true, false);
    BlockID OAK_LEAF = RegisterBlock("minecraft:oak_leaves", new MaterialNone(), true, true, false);
    BlockID SEA_LANTERN = RegisterBlock("minecraft:sea_lantern", new MaterialNone(), false, true, false);
    BlockID REDSTONE_LAMP = RegisterBlock("minecraft:redstone_lamp", new MaterialNone(), false, true, false);
    BlockID CRAFTING_TABLE = RegisterBlock("minecraft:crafting_table", new MaterialNone(), false, true, false);
    BlockID COPPER_BULB = RegisterBlock("minecraft:copper_bulb", new MaterialNone(), false, true, false);
    BlockID EXPOSED_COPPER_BULB = RegisterBlock("minecraft:exposed_copper_bulb", new MaterialNone(), false, true, false);
    BlockID OXIDIZED_COPPER_BULB = RegisterBlock("minecraft:oxidized_copper_bulb", new MaterialNone(), false, true, false);
    BlockID WEATHERED_COPPER_BULB = RegisterBlock("minecraft:weathered_copper_bulb", new MaterialNone(), false, true, false);
    BlockID COPPER_GRATE = RegisterBlock("minecraft:copper_grate", new MaterialNone(), true, true, false);
    BlockID EXPOSED_COPPER_GRATE = RegisterBlock("minecraft:exposed_copper_grate", new MaterialNone(), true, true, false);
    BlockID OXIDIZED_COPPER_GRATE = RegisterBlock("minecraft:oxidized_copper_grate", new MaterialNone(), true, true, false);
    BlockID WEATHERED_COPPER_GRATE = RegisterBlock("minecraft:weathered_copper_grate", new MaterialNone(), true, true, false);
    BlockID CUT_COPPER = RegisterBlock("minecraft:cut_copper", new MaterialNone(), false, true, false);
    BlockID EXPOSED_CUT_COPPER = RegisterBlock("minecraft:exposed_cut_copper", new MaterialNone(), false, true, false);
    BlockID OXIDIZED_CUT_COPPER = RegisterBlock("minecraft:oxidized_cut_copper", new MaterialNone(), false, true, false);
    BlockID WEATHERED_CUT_COPPER = RegisterBlock("minecraft:weathered_cut_copper", new MaterialNone(), false, true, false);
    BlockID CHISELED_COPPER = RegisterBlock("minecraft:chiseled_copper", new MaterialNone(), false, true, false);
    BlockID EXPOSED_CHISELED_COPPER = RegisterBlock("minecraft:exposed_chiseled_copper", new MaterialNone(), false, true, false);
    BlockID OXIDIZED_CHISELED_COPPER = RegisterBlock("minecraft:oxidized_chiseled_copper", new MaterialNone(), false, true, false);
    BlockID WEATHERED_CHISELED_COPPER = RegisterBlock("minecraft:weathered_chiseled_copper", new MaterialNone(), false, true, false);
    BlockID WARPED_HYPHAE = RegisterBlock("minecraft:warped_hyphae", new MaterialNone(), false, true, false);
    BlockID STRIPPED_WARPED_HYPHAE = RegisterBlock("minecraft:stripped_warped_hyphae", new MaterialNone(), false, true, false);
    BlockID CRIMSON_HYPHAE = RegisterBlock("minecraft:crimson_hyphae", new MaterialNone(), false, true, false);
    BlockID STRIPPED_CRIMSON_HYPHAE = RegisterBlock("minecraft:stripped_crimson_hyphae", new MaterialNone(), false, true, false);
    BlockID MOSSY_COBBLESTONE = RegisterBlock("minecraft:mossy_cobblestone", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE = RegisterBlock("minecraft:deepslate", new MaterialNone(), false, true, false);
    BlockID COBBLED_DEEPSLATE = RegisterBlock("minecraft:cobbled_deepslate", new MaterialNone(), false, true, false);
    BlockID CHISELED_DEEPSLATE = RegisterBlock("minecraft:chiseled_deepslate", new MaterialNone(), false, true, false);
    BlockID POLISHED_DEEPSLATE = RegisterBlock("minecraft:polished_deepslate", new MaterialNone(), false, true, false);
    BlockID DEEPSLATE_TILES = RegisterBlock("minecraft:deepslate_tiles", new MaterialNone(), false, true, false);
    BlockID CRACKED_DEEPSLATE_TILES = RegisterBlock("minecraft:deepslate_tiles", new MaterialNone(), false, true, false);
    BlockID REINFORCED_DEEPSLATE = RegisterBlock("minecraft:reinforced_deepslate", new MaterialNone(), false, true, false);
    BlockID TUFF = RegisterBlock("minecraft:tuff", new MaterialNone(), false, true, false);
    BlockID CHISELED_TUFF = RegisterBlock("minecraft:chiseled_tuff", new MaterialNone(), false, true, false);
    BlockID POLISHED_TUFF = RegisterBlock("minecraft:polished_tuff", new MaterialNone(), false, true, false);
    BlockID PACKED_MUD = RegisterBlock("minecraft:packed_mud", new MaterialNone(), false, true, false);
    BlockID SANDSTONE = RegisterBlock("minecraft:sandstone", new MaterialNone(), false, true, false);
    BlockID CHISELED_SANDSTONE = RegisterBlock("minecraft:chiseled_sandstone", new MaterialNone(), false, true, false);
    BlockID SMOOTH_SANDSTONE = RegisterBlock("minecraft:smooth_sandstone", new MaterialNone(), false, true, false);
    BlockID CUT_SANDSTONE = RegisterBlock("minecraft:cut_sandstone", new MaterialNone(), false, true, false);
    BlockID RED_SANDSTONE = RegisterBlock("minecraft:red_sandstone", new MaterialNone(), false, true, false);
    BlockID CHISELED_RED_SANDSTONE = RegisterBlock("minecraft:chiseled_red_sandstone", new MaterialNone(), false, true, false);
    BlockID SMOOTH_RED_SANDSTONE = RegisterBlock("minecraft:smooth_red_sandstone", new MaterialNone(), false, true, false);
    BlockID CUT_RED_SANDSTONE = RegisterBlock("minecraft:cut_red_sandstone", new MaterialNone(), false, true, false);
    BlockID DARK_PRISMARINE = RegisterBlock("minecraft:dark_prismarine", new MaterialNone(), false, true, false);
    BlockID PURPUR_BLOCK = RegisterBlock("minecraft:purpur_block", new MaterialNone(), false, true, false);
    BlockID PURPUR_PILLAR = RegisterBlock("minecraft:purpur_pillar", new MaterialNone(), false, true, false);
    BlockID COAL_BLOCK = RegisterBlock("minecraft:coal_block", new MaterialNone(), false, true, false);
    BlockID IRON_BLOCK = RegisterBlock("minecraft:iron_block", new MaterialNone(), false, true, false);
    BlockID GOLD_BLOCK = RegisterBlock("minecraft:gold_block", new MaterialNone(), false, true, false);
    BlockID REDSTONE_BLOCK = RegisterBlock("minecraft:redstone_block", new MaterialNone(), false, true, false);
    BlockID EMERALD_BLOCK = RegisterBlock("minecraft:emerald_block", new MaterialNone(), false, true, false);
    BlockID LAPIS_BLOCK = RegisterBlock("minecraft:lapis_block", new MaterialNone(), false, true, false);
    BlockID DIAMOND_BLOCK = RegisterBlock("minecraft:diamond_block", new MaterialNone(), false, true, false);
    BlockID NETHERITE_BLOCK = RegisterBlock("minecraft:netherite_block", new MaterialNone(), false, true, false);
    BlockID QUARTZ_BLOCK = RegisterBlock("minecraft:quartz_block", new MaterialNone(), false, true, false);
    BlockID CHISELED_QUARTZ_BLOCK = RegisterBlock("minecraft:chiseled_quartz_block", new MaterialNone(), false, true, false);
    BlockID QUARTZ_PILLAR = RegisterBlock("minecraft:quartz_pillar", new MaterialNone(), false, true, false);
    BlockID SMOOTH_QUARTZ = RegisterBlock("minecraft:smooth_quartz", new MaterialNone(), false, true, false);

    BlockID ANVIL = RegisterBlock("minecraft:anvil", new MaterialNone(), false, true, false);

    void Initialize();

    BlockList();
    ~BlockList();

    void CleanUp();

    Block* GetBlockType(BlockID id);

    const Model::BlockModel& GetBlockModelDereferenced(BlockID id);

    BlockID RegisterBlock(std::string blockName, Material* material, bool transparency, bool solid, bool isFluid);

} ;

extern BlockList g_blocks;
"./Level\\Chunk\\Block\\Material\\BlockMaterial.cpp"
#include "BlockMaterial.h"
#include "../Type/BlockTypes.h"

Material::~Material() = default;

MaterialNone::MaterialNone() {
    type_ = MATERIAL_NONE;
}

Block* MaterialNone::BuildNewBlockType() {
    return static_cast<Block*>(new DefaultBlock());
}

MaterialFluid::MaterialFluid(int spreadRate) { //Spreadrate in ticks
    type_ = MATERIAL_FLUID;

    spread_ = spreadRate;
}

Block* MaterialFluid::BuildNewBlockType() {
    Fluid* fluid = new Fluid;
    fluid->properties_.spread_rate_ = spread_;

    return static_cast<Block*>(fluid);
}

MaterialGrass::MaterialGrass(double spreadChance, double breakChance) {
    type_ = MATERIAL_GRASS;
    spread_chance_ = spreadChance;
    break_chance_ = breakChance;
}

Block* MaterialGrass::BuildNewBlockType() {
    GrassBlock* grass = new GrassBlock;
    grass->properties_.break_chance_ = break_chance_;
    grass->properties_.spread_chance_ = spread_chance_;

    return static_cast<Block*>(grass);
}

MaterialDirt::MaterialDirt() {
    type_ = MATERIAL_DIRT;
}

Block* MaterialDirt::BuildNewBlockType() {
    DirtBlock* dirt = new DirtBlock();

    return static_cast<Block*>(dirt);
}

MaterialGravity::MaterialGravity() {
    type_ = MATERIAL_GRAVITY;
}

Block* MaterialGravity::BuildNewBlockType() {
    GravityBlock* gravity = new GravityBlock();

    return static_cast<Block*>(gravity);
}
"./Level\\Chunk\\Block\\Material\\BlockMaterial.h"
#pragma once

struct Block;

enum MaterialType {
    MATERIAL_DIRT, MATERIAL_GRASS, MATERIAL_FLUID, MATERIAL_NONE, MATERIAL_GRAVITY
};

struct Material {
    MaterialType type_ = MATERIAL_NONE;

    virtual ~Material();

    virtual Block* BuildNewBlockType() = 0;
};

struct MaterialNone : Material {
    MaterialNone();

    Block* BuildNewBlockType() override;
};

struct MaterialFluid : Material {
    int spread_ = 1;

    MaterialFluid(int spreadRate);

    Block* BuildNewBlockType() override;
};

struct MaterialDirt : Material {
    MaterialDirt();

    Block* BuildNewBlockType() override;
};

struct MaterialGrass : Material {
    double spread_chance_ = 0.001;
    double break_chance_ = 0.001;

    MaterialGrass(double spreadChance, double breakChance);

    Block* BuildNewBlockType() override;
};

struct MaterialGravity : Material {
    MaterialGravity();

    Block* BuildNewBlockType() override;
};
"./Level\\Chunk\\Block\\Texture\\BlockTexture.cpp"
#include "BlockTexture.h"
#include "../../../Typenames.h"

void BlockTexture::SetFaceFront(int texId) {
    texture_index_[FRONT] = texId;
}
void BlockTexture::SetFaceBack(int texId) {
    texture_index_[BACK] = texId;
}
void BlockTexture::SetFaceWest(int texId) {
    texture_index_[RIGHT] = texId;
}
void BlockTexture::SetFaceEast(int texId) {
    texture_index_[LEFT] = texId;
}
void BlockTexture::SetFaceTop(int texId) {
    texture_index_[TOP] = texId;
}
void BlockTexture::SetFaceBottom(int texId) {
    texture_index_[BOTTOM] = texId;
}
void BlockTexture::SetFacesCustom(int texId, int TexNum, int side0, int side1, int side2, int side3, int side4, int side5) {

    if (side0 != 0xFF) {
        texture_index_[side0] = texId;
        texture_num_index_[side0] = TexNum;
    }

    if (side1 != 0xFF) {
        texture_index_[side1] = texId;
        texture_num_index_[side1] = TexNum;
    }

    if (side2 != 0xFF) {
        texture_index_[side2] = texId;
        texture_num_index_[side2] = TexNum;
    }

    if (side3 != 0xFF) {
        texture_index_[side3] = texId;
        texture_num_index_[side3] = TexNum;
    }

    if (side4 != 0xFF) {
        texture_index_[side4] = texId;
        texture_num_index_[side4] = TexNum;
    }

    if (side5 != 0xFF) {
        texture_index_[side5] = texId;
        texture_num_index_[side5] = TexNum;
    }
}

void BlockTexture::SetParticle(int tex) {
    particle_ = tex;
}

int BlockTexture::GetParticle() {
    return particle_;
}

int BlockTexture::GetFace(int side) {
    return texture_index_[side];
}

int& BlockTexture::operator[](int i) {
    return texture_index_[i];
}

int BlockTexture::GetNumTextures(int side) {
    return texture_num_index_[side];
}
"./Level\\Chunk\\Block\\Texture\\BlockTexture.h"
#pragma once

class BlockTexture {
public:
    void SetFaceFront(int texId);
    void SetFaceBack(int texId);
    void SetFaceWest(int texId);
    void SetFaceEast(int texId);
    void SetFaceTop(int texId);
    void SetFaceBottom(int texId);
    void SetFacesCustom(int texId, int TexNum, int side0 = 0xFF, int side1 = 0xFF, int side2 = 0xFF, int side3 = 0xFF, int side4 = 0xFF, int side5 = 0xFF);

    void SetParticle(int tex);

    int GetParticle();

    int GetFace(int side);

    int& operator[](int i);

    int GetNumTextures(int side);

private:
    int texture_index_[6]{ 0 };
    int texture_num_index_[6]{ 0 };
    int particle_ = 0;
};
"./Level\\Chunk\\Block\\Type\\BlockTypes.h"
#pragma once
#include "Dirt.h"
#include "Fluid.h"
#include "Grass.h"
#include "GravityBlock.h"
#include "DefaultBlock.h"
"./Level\\Chunk\\Block\\Type\\DefaultBlock.cpp"
#include "DefaultBlock.h"
#include "../../../../Level/Dimension/Dimension.h"

void DefaultBlock::Tick(const BlockPos& pos, Dimension* currentWorld) {
    (void)currentWorld;
    (void)pos;
}
"./Level\\Chunk\\Block\\Type\\DefaultBlock.h"
#pragma once
#include "../Block.h"
#include "../../../Typenames.h"

class Dimension;

struct DefaultBlock : Block {

    void Tick(const BlockPos& pos, Dimension* currentWorld) override;
};
"./Level\\Chunk\\Block\\Type\\Dirt.cpp"
#include "Dirt.h"
#include "../../../../Level/Dimension/Dimension.h"

void DirtBlock::Tick(const BlockPos& pos, Dimension* currentWorld) {
    (void)currentWorld;
    (void)pos;
}
"./Level\\Chunk\\Block\\Type\\Dirt.h"
#pragma once
#include "../Block.h"
#include "../../../Typenames.h"

class Dimension;

struct DirtBlock : Block {

    void Tick(const BlockPos& pos, Dimension* currentWorld) override;
};
"./Level\\Chunk\\Block\\Type\\Fluid.cpp"
#include "Fluid.h"
#include "../../../../Level/Dimension/Dimension.h"
#include "../../../Event/EventHandler.h"

void Fluid::Tick(const BlockPos& pos, Dimension* currentWorld) {
    for (int side = 0; side < 6; side++) {
        BlockPos newPos = pos;

        newPos.incrementSide(side, 1);

        if (side == 3) { // y_up direction
            continue;
        }

        BlockID block = currentWorld->world_interactions_.GetBlock(pos);

        if (block != g_blocks.AIR) {
            continue;
        }

        if (block == g_blocks.WATER) {
            continue;
        }

        if (currentWorld->CheckTickUsed(g_event_handler.BlockPlace, pos)) {
            return;
        }

        currentWorld->TickUsed(g_event_handler.BlockPlace, pos);

        Event::BlockEvent blockEvent{ newPos, g_blocks.WATER, g_event_handler.BlockPlace };
        currentWorld->event_manager_.AddEvent(blockEvent);

    }
}
"./Level\\Chunk\\Block\\Type\\Fluid.h"
#pragma once
#include "../Block.h"
#include "../../../Typenames.h"

class Dimension;

struct FluidProperties {
    int spread_rate_ = 1; // Ticks for fluid to spread
};

struct Fluid : Block {

    FluidProperties properties_;

    void Tick(const BlockPos& pos, Dimension* currentWorld) override;
};
"./Level\\Chunk\\Block\\Type\\Grass.cpp"
#include "Grass.h"
#include "../../../Dimension/Dimension.h"
#include "../../../Event/EventHandler.h"
#include "../../../../Utils/Math/Probability/Probability.h"

void GrassBlock::Tick(const BlockPos& pos, Dimension* currentWorld) {
    //Checks if ticking block changes 
    if (currentWorld->world_interactions_.GetBlock(pos) != g_blocks.GRASS) {
        return;
    }

    BlockPos newPos = pos;
    newPos.y += 1;

    bool blockOnTopOfGrass = (currentWorld->world_interactions_.GetBlock(newPos) != g_blocks.AIR);

    bool isGrassDestroyed = false;

    if (blockOnTopOfGrass) {
        isGrassDestroyed = GrassDestroyTick(currentWorld, pos);
    }

    //If grass destroyed tick ends
    if (isGrassDestroyed) {
        return;
    }

    bool onlySurroundedByGrass = GrassSpreadTick(currentWorld, pos);

    if (onlySurroundedByGrass && (!blockOnTopOfGrass)) {
        return;
    }

    Event::BlockEvent grassSpread{ pos, g_blocks.GRASS, g_event_handler.BlockTick };
    currentWorld->event_manager_.AddEvent(grassSpread);
}

bool GrassBlock::GrassDestroyTick(Dimension* currentWorld, const BlockPos& pos) {
    //Chance it -doesn't break-
    if (TestProbability(1 - properties_.break_chance_)) {
        return false;
    }

    currentWorld->world_interactions_.SetBlock(g_blocks.DIRT, pos);

    return true;
}

bool GrassBlock::GrassSpreadTick(Dimension* currentWorld, const BlockPos& pos) {
    bool dirtExposed = false;

    for (int x1 = -1; x1 <= 1; x1++) {
        for (int z1 = -1; z1 <= 1; z1++) {
            if (x1 == 0 && z1 == 0) {
                continue;
            }

            for (int y1 = -1; y1 <= 1; y1++) {

                BlockPos newPos = pos;
                newPos.x += x1;
                newPos.y += y1;
                newPos.z += z1;

                //Checks if block is dirt
                if (currentWorld->world_interactions_.GetBlock(newPos) != g_blocks.DIRT) {
                    continue;
                }

                //Checks if there isnt any block above
                newPos.y += 1;
                if (currentWorld->world_interactions_.GetBlock(newPos) != g_blocks.AIR) {
                    continue;
                }
                newPos.y -= 1;

                //Chance it spread
                if (TestProbability(properties_.spread_chance_)) {

                    Event::BlockEvent blockEvent{ newPos,g_blocks.GRASS, g_event_handler.BlockPlace };
                    currentWorld->event_manager_.AddEvent(blockEvent);

                    continue;
                }

                dirtExposed = true;
            }
        }
    }

    return !dirtExposed;
}
"./Level\\Chunk\\Block\\Type\\Grass.h"
#pragma once
#include "../Block.h"
#include "../../../Typenames.h"

class Dimension;

struct GrassProperties {
    double spread_chance_ = 0.001;
    double break_chance_ = 0.001;
};

struct GrassBlock : Block {

    GrassProperties properties_;

    void Tick(const BlockPos& pos, Dimension* currentWorld) override;

    bool GrassDestroyTick(Dimension* currentWorld, const BlockPos& pos);

    //return true if there is no exposed dirt blocks surrounding it
    // TODO: refactor code
    bool GrassSpreadTick(Dimension* currentWorld, const BlockPos& pos);
};
"./Level\\Chunk\\Block\\Type\\GravityBlock.cpp"
#include "GravityBlock.h"
#include "../../../Dimension/Dimension.h"
#include "../../../Event/EventHandler.h"
#include "../../../Entity/Entities.h"

void GravityBlock::Tick(const BlockPos& pos, Dimension* currentWorld) {
    BlockPos belowPos = pos;
    belowPos.y -= 1;
    bool isBlockSupported = g_blocks.GetBlockType(currentWorld->world_interactions_.GetBlock(belowPos))->properties_->is_solid_;

    if (!isBlockSupported) {
        Event::BlockEvent destroyBlock{ pos, g_blocks.AIR, g_event_handler.BlockPlace };
        Event::EntityEvent summonSand;

        summonSand.id_ = g_event_handler.SummonEntity;
        summonSand.pos_ = pos;
        summonSand.entity_type_ = g_entity_list.SAND_GRAVITY_BLOCK;

        currentWorld->event_manager_.AddEvent(destroyBlock);
        currentWorld->event_manager_.AddEvent(summonSand);
    }
}
"./Level\\Chunk\\Block\\Type\\GravityBlock.h"
#pragma once
#include "../Block.h"
#include "../../../Typenames.h"

class Dimension;

struct GravityBlock : Block {

    void Tick(const BlockPos& pos, Dimension* currentWorld) override;
};
"./Level\\Chunk\\Chunk.cpp"
#include "Chunk.h"

Chunk::Chunk() = default;
Chunk::~Chunk() = default;

void Chunk::UpdateGen() {
    for (int side = 0; side < 6; side++) {
        int axis_ = side >> 1;
        int face = side & 0b1;

        if (neighbors_[side] == nullptr)
            continue;

        if (neighbors_[side]->outside_block_to_place_[axis_ * 2 + (!face)].size() == 0) {
            continue;
        }

        std::vector<SetBlockRelative> blocks = neighbors_[side]->outside_block_to_place_[axis_ * 2 + (!face)];

        neighbors_[side]->outside_block_to_place_[axis_ * 2 + (!face)].clear();

        for (int i = 0; i < blocks.size(); i++) {
            SetBlock(blocks[i].block_, blocks[i].x_, blocks[i].y_, blocks[i].z_);
        }

        blocks.clear();
    }
}
"./Level\\Chunk\\Chunk.h"
#pragma once
#include "ChunkData.h"

enum TerrainType {
    SUPERFLAT, FASTTERRAIN, MOUNTAINS, DEBUG_WORLD, MATH_WORLD, DEBUG_WORLD_2
};

class Chunk : public ChunkContainer {
public:
    Chunk();
    ~Chunk();
    void UpdateGen();
};
"./Level\\Chunk\\ChunkColumn.cpp"
#include "ChunkColumn.h"

Heightmap& ChunkColumn::GetHeightmap() {
    return column_heightmap_;
}

void ChunkColumn::ReplaceLightContainer(int y, std::unique_ptr<ChunkLightingContainer> c) {
    if (column_[y] == nullptr) {
        throw std::exception("Couldn't place lighting");
    }

    column_[y]->lighting_->ReplaceData(c->getData());
}

ChunkColumn::ChunkColumn() {
    column_.resize(32);
    light_dirty_.resize(32, false);
    column_heightmap_.Init();
}

void ChunkColumn::AddChunk(std::unique_ptr<Chunk> chunk, int relativeHeightLevel) {
    column_[relativeHeightLevel] = std::move(chunk);
    UpdateHeightmap(relativeHeightLevel);
}

void ChunkColumn::UpdateChunk(int relativeHeightLevel) {
    UpdateHeightmap(relativeHeightLevel);
}

Chunk* ChunkColumn::GetChunk(int heightLevel) const {
    return column_[heightLevel].get();
}

int16_t ChunkColumn::FindSurfaceHeight(int x, int z, int startingChunk) const {
    for (int16_t currChunk = startingChunk; currChunk >= 0; --currChunk) {
        const std::unique_ptr<Chunk>& curr = column_[currChunk];

        if (curr == nullptr) continue;

        for (int y = 15; y >= 0; y--) {
            if (curr->GetBlockUnsafe(x, y, z) != g_blocks.AIR) {
                return currChunk * 16 + y;
            }
        }
    }
    return -1;
}

int16_t ChunkColumn::FindSurfaceHeightSingleChunk(int height, int x, int z) const {
    const std::unique_ptr<Chunk>& chunk = column_[height];
    if (chunk == nullptr) return -1;
    for (int y = 15; y >= 0; y--) {
        if (chunk->GetBlockUnsafe(x, y, z) != g_blocks.AIR) return y;
    }
    return -1;
}

void ChunkColumn::UpdateHeightmapSingleBlock(int height, BlockID block, int x, int y, int z) {
    int currHeight = column_heightmap_.Get(z, y);

    //tmp
    for (int i = 0; i <= height; i++) {
        if (column_[i] != nullptr) {
            light_dirty_[i] = true;
        }
    }

    if (height * 16 + y < currHeight) {
        return;
    }

    if (block == g_blocks.AIR) {
        if (currHeight == height) {
            int16_t surfaceLevel = FindSurfaceHeight(x, z, height);
            if (surfaceLevel == -1) {
                surfaceLevel = 0;
            }
            column_heightmap_.Edit(x, z, surfaceLevel);
        }
    }
    else {
        column_heightmap_.Edit(x, z, height * 16 + y);
    }
}

void ChunkColumn::UpdateHeightmap(int height) {
    for (uint8_t x = 0; x < 16; x++) {
        for (uint8_t z = 0; z < 16; z++) {
            int16_t surfaceLevel = FindSurfaceHeight(x, z, static_cast<uint8_t>(height));
            surfaceLevel = (surfaceLevel != -1) * surfaceLevel;
            column_heightmap_.Edit(x, z, surfaceLevel);
        }
    }

    for (int i = 0; i <= height; i++) {
        if (column_[i] != nullptr) {
            light_dirty_[i] = true;
        }
    }
}
"./Level\\Chunk\\ChunkColumn.h"
#pragma once
#include "Chunk.h"
#include "Lighting/ChunkLighting.h"
#include "../../Utils/Containers/BitStorage.h"
#include "Heightmap/Heightmap.h"
#include <glm/vec2.hpp>
#include <intrin.h>

// TODO: Rework this refactor ChunkColumnPos system
class ChunkColumn { //Helps with stuff like lighting
private:
    std::vector<std::unique_ptr<Chunk>> column_;
    Heightmap column_heightmap_;
    // glm::ivec2 Position;
public:
    std::vector<bool> light_dirty_;

    Heightmap& GetHeightmap();

    void ReplaceLightContainer(int y, std::unique_ptr<ChunkLightingContainer> c);

    ChunkColumn();

    void AddChunk(std::unique_ptr<Chunk> chunk, int relativeHeightLevel);

    void UpdateChunk(int relativeHeightLevel);

    Chunk* GetChunk(int heightLevel) const;

    int16_t FindSurfaceHeight(int x, int z, int startingChunk = 31) const;

    /*
    Input is the y axis where the chunk is located at and the x and z block position relative to the chunk
    */

    int16_t FindSurfaceHeightSingleChunk(int height, int x, int z) const;

    void UpdateHeightmapSingleBlock(int height, BlockID block, int x, int y, int z);

    void UpdateHeightmap(int height);
}; 
"./Level\\Chunk\\ChunkData.cpp"
#include "ChunkData.h"

static const int NeighborOffset[6] = {
      -16, 16,-16, 16,-16, 16
};

// TODO: Make this readable and safe
BlockID ChunkContainer::GetBlock(int x, int y, int z) const {
    if (!((x | y | z) >> 4)) { //check if it is in the chunk
        return block_storage_.GetBlock(x, y, z);
    }

    int dx = ((x >> 31) & 0b1) + 0;
    int dy = ((y >> 31) & 0b1) + 2;
    int dz = ((z >> 31) & 0b1) + 4;

    if (neighbors_[dx] && (x >> 4)) return neighbors_[dx]->GetBlock(x + NeighborOffset[dx], y, z );
    if (neighbors_[dy] && (y >> 4)) return neighbors_[dy]->GetBlock(x, y + NeighborOffset[dy], z );
    if (neighbors_[dz] && (z >> 4)) return neighbors_[dz]->GetBlock(x, y, z + NeighborOffset[dz]);

    return g_blocks.AIR;
}

BlockID ChunkContainer::GetBlockUnsafe(int x, int y, int z) const {
    return block_storage_.GetBlockUnsafe(x, y, z);
}

void ChunkContainer::SetBlock(BlockID block, int x, int y, int z) {
    if (!((x | y | z) >> 4)) { //check if it is in the chunk
        SetBlockUnsafe(block, x, y, z);
        return;
    }

    int dx = ((x >> 31) & 0b1) + 0;
    int dy = ((y >> 31) & 0b1) + 2;
    int dz = ((z >> 31) & 0b1) + 4;

    if (x >> 4) {
        outside_block_to_place_[dx].emplace_back(block, x + NeighborOffset[dx], y, z);
        return;
    }
    if (y >> 4) {
        outside_block_to_place_[dy].emplace_back(block, x, y + NeighborOffset[dy], z);
        return;
    }
    if (z >> 4) {
        outside_block_to_place_[dz].emplace_back(block, x, y, z + NeighborOffset[dz]);
        return;
    }
}

void ChunkContainer::SetBlockUnsafe(BlockID block, int x, int y, int z) {
    block_storage_.SetBlockUnsafe(block, (uint32_t)x, (uint32_t)y, (uint32_t)z);

    is_empty_ = false;
}

void ChunkContainer::SetPosition(int x, int y, int z) {
    position_.set(x, y, z);
}

ChunkContainer* ChunkContainer::GetNeighbor(unsigned int side) const {
    return neighbors_[side];
}

void ChunkContainer::SetNeighbor(ChunkContainer* Neighbor, unsigned int Side) {
    neighbors_[Side] = Neighbor;
}

void ChunkContainer::ClearNeighbors() {
    for (int i = 0; i < 6; i++) {
        neighbors_[i] = nullptr;
    }
}

void ChunkContainer::Use() {
    while (in_use_) {};
    in_use_ = true;
}

void ChunkContainer::Unuse() {
    in_use_ = false;
}
"./Level\\Chunk\\ChunkData.h"
#pragma once

#ifndef CHUNKDATA_H
#define CHUNKDATA_H

#include <glm/vec3.hpp>
#include "../TerrainGeneration/Structures/Structure.h"
#include "Lighting/ChunkLighting.h"
#include "../Typenames.h"
#include "ChunkPos/ChunkPos.h"
#include "Palette.h"



class ChunkContainer {
private:
    std::atomic<bool> in_use_ = false;

    Palette block_storage_;
public:
    ChunkPos position_;
    std::vector<SetBlockRelative> outside_block_to_place_[6]{};
    ChunkContainer* neighbors_[6]{ nullptr };
    std::unique_ptr<ChunkLightingContainer> lighting_;
    std::atomic<bool> is_empty_ = true;

    ChunkContainer() {
        lighting_ = std::make_unique<ChunkLightingContainer>();
    }
    
    void SetNeighbor(ChunkContainer* neighbor, unsigned int side);

    void ClearNeighbors();

    BlockID GetBlock(int x, int y, int z) const;
    BlockID GetBlockUnsafe(int x, int y, int z) const;

    void SetBlock(BlockID block, int x, int y, int z);
    void SetBlockUnsafe(BlockID block, int x, int y, int z);

    void Use();
    void Unuse();

    ChunkContainer* GetNeighbor(unsigned int side) const;
    
    void SetPosition(int x, int y, int z);
};

#endif
"./Level\\Chunk\\ChunkPos\\ChunkPos.cpp"
#include "ChunkPos.h"

std::string std::to_string(const ChunkPos& obj) {
    return "[" + to_string(obj.x) + "," + to_string(obj.y) + "," + to_string(obj.z) + "]";
}
"./Level\\Chunk\\ChunkPos\\ChunkPos.h"
#pragma once

#ifndef CHUNK_POS_H
#define CHUNK_POS_H

#include <cmath>
#include <iostream>
#include <xhash>
#include <cctype>
#include <string>

#include "../../../Utils/LogUtils.h"

class ChunkPos {
public:
    int x, y, z;

    template <typename T>
    ChunkPos(T px, T py, T pz) {
        set(static_cast<int>(px), static_cast<int>(py), static_cast<int>(pz));
    }

    ChunkPos(const ChunkPos& m) {
        x = m.x;
        y = m.y;
        z = m.z;
    }

    ChunkPos() {
        x = 0;
        y = 0;
        z = 0;
    }

    void set(int px, int py, int pz) {
        x = px;
        y = py;
        z = pz;
    }

    void incrementSide(int side, int val) {
        reinterpret_cast<int*>(this)[side >> 1] += (1 - 2 * (side & 1)) * val;
    }

    int& operator[](int i) {
        return reinterpret_cast<int*>(this)[i];
    }

    void operator=(const ChunkPos& other) {
        x = other.x;
        y = other.y;
        z = other.z;
    }

    ChunkPos operator-(const ChunkPos& other) const {
        return ChunkPos{ x - other.x, y - other.y, z - other.z };
    }

    ChunkPos operator+(const ChunkPos& other) const {
        return ChunkPos{ x + other.x, y + other.y, z + other.z };
    }

    template <typename T> 
    ChunkPos operator*(const T& other) const {
        return ChunkPos{ x * other, y * other, z * other };
    }

    template <typename T> 
    ChunkPos operator/(const T& other) const {
        return ChunkPos{ x / other, y / other, z / other };
    }

    template <typename T>
    ChunkPos operator<<(const T& other) const {
        static_assert(std::is_integral<T>::value, "Integral required.");
        return ChunkPos{ x << other, y << other, z << other };
    }

    template <typename T>
    ChunkPos operator>>(const T& other) const {
        static_assert(std::is_integral<T>::value, "Integral required.");
        return ChunkPos{ x >> other, y >> other, z >> other };
    }

    template <typename T>
    ChunkPos operator&(const T& other) const {
        static_assert(std::is_integral<T>::value, "Integral required.");
        return ChunkPos{ x & other, y & other, z & other };
    }

    template <typename T>
    ChunkPos operator^(const T& other) const {
        static_assert(std::is_integral<T>::value, "Integral required.");
        return ChunkPos{ x ^ other, y ^ other, z ^ other };
    }

    template <typename T>
    ChunkPos operator|(const T& other) const {
        static_assert(std::is_integral<T>::value, "Integral required.");
        return ChunkPos{ x | other, y | other, z | other };
    }

    template <typename T>
    ChunkPos& operator<<=(const T& other) {
        static_assert(std::is_integral<T>::value, "Integral required.");
        x <<= other;
        x <<= other;
        x <<= other;
        return *this;
    }

    template <typename T>
    ChunkPos& operator>>=(const T& other) {
        static_assert(std::is_integral<T>::value, "Integral required.");
        x >>= other;
        x >>= other;
        x >>= other;
        return *this;
    }

    template <typename T>
    ChunkPos& operator&=(const T& other) {
        static_assert(std::is_integral<T>::value, "Integral required.");
        x &= other;
        x &= other;
        x &= other;
        return *this;
    }

    template <typename T>
    ChunkPos& operator^=(const T& other) {
        static_assert(std::is_integral<T>::value, "Integral required.");
        x ^= other;
        x ^= other;
        x ^= other;
        return *this;
    }

    template <typename T>
    ChunkPos& operator|=(const T& other) {
        static_assert(std::is_integral<T>::value, "Integral required.");
        x |= other;
        x |= other;
        x |= other;
        return *this;
    }

    template <typename T> 
    void operator*=(const T& other) {
        x *= other;
        y *= other;
        z *= other;
    }

    friend std::ostream& operator<<(std::ostream& os, const ChunkPos& m) {
        return os << '[' << m.x << ',' << m.y << ',' << m.z << ']';
    }

    friend std::string operator+(const char* str, const ChunkPos& m) {
        std::string s = std::string(str) + "[" + std::to_string(m.x) + "," + std::to_string(m.y) + "," + std::to_string(m.z) + "]";
        return s;
    }

    // for HashMaps and HashSets

    bool operator==(const ChunkPos& other) const {
        return x == other.x && y == other.y && z == other.z;
    }

    size_t hash() const {
        size_t h = 2166136261u;  // FNV offset basis
        h ^= static_cast<size_t>(x);
        h *= 16777619u;  // FNV prime
        h ^= static_cast<size_t>(y);
        h *= 16777619u;
        h ^= static_cast<size_t>(z);
        h *= 16777619u;
        return h;
    }
};

namespace std {
    template<>
    struct hash<ChunkPos> {
        size_t operator()(const ChunkPos& obj) const {
            return obj.hash();
        }
    };

    string to_string(const ChunkPos& obj);
}

using RegionPos = ChunkPos;
using TallChunkPos = ChunkPos;
using ChunkColumnPos = ChunkPos;
using BlockPos = ChunkPos;
using LocalBlockPos = ChunkPos;

#endif
"./Level\\Chunk\\Heightmap\\Heightmap.cpp"
#include "Heightmap.h"
#include <new> 
#include <iostream>

Heightmap::Heightmap() = default;
Heightmap::~Heightmap() = default;

void Heightmap::Edit(int x, int z, int height) {
    data_[x * 16 + z] = height;
}

uint16_t Heightmap::Get(int x, int z) const {
    return data_[x * 16 + z];
}

std::vector<uint16_t> Heightmap::GetData() const {
    return data_;
}

void Heightmap::Init() {
    data_.resize(256);
    is_init_ = true;
}

void Heightmap::Clear() {
    data_.clear();
}
"./Level\\Chunk\\Heightmap\\Heightmap.h"
#pragma once
#include <vector>
/*

heightmap for chunk column 32 * 16 = 512 blocks columns 9 bits per column

16 x 16 * 9 = 2304 bits = 36 uint64_t
*/

class Heightmap {
private:
    std::vector<uint16_t> data_;
    bool is_init_ = false;
public:
    Heightmap();
    ~Heightmap();

    void Edit(int x, int z, int height);

    uint16_t Get(int x, int z) const;

    void Init();
    void Clear();

    std::vector<uint16_t> GetData() const;
};
"./Level\\Chunk\\Lighting\\ChunkLighting.cpp"
#include "ChunkLighting.h"

ChunkLightingContainer::ChunkLightingContainer() {
    ResetLighting();
}

ChunkLightingContainer::~ChunkLightingContainer() = default;

uint64_t* ChunkLightingContainer::getData() {
    return data_;
}

void ChunkLightingContainer::ReplaceData(uint64_t* src) {
    memcpy(data_, src, sizeof(uint64_t) * 256);
}

void ChunkLightingContainer::EditLight(int x, int y, int z, unsigned char lightingInfo) {
    data_[(x << 4) | (z)] &= (~(0b1111ULL << (y << 2)));

    data_[(x << 4) | (z)] |= ((uint64_t)lightingInfo << (y << 2));
}

uint8_t ChunkLightingContainer::GetLighting(int x, int y, int z) const {
    return (data_[(x << 4) | (z)] >> (y << 2)) & 0b1111;
}

void ChunkLightingContainer::ResetLighting() {
    memset((uint8_t*)data_, MaxLightLevel | (MaxLightLevel << 4), 256 * 8); //8 = sizeof uint64_t
}

void ChunkLightingContainer::ResetLightingCustom(uint8_t lvl) {
    memset((uint8_t*)data_, lvl | (lvl << 4), 256 * 8); //8 = sizeof uint64_t
}
"./Level\\Chunk\\Lighting\\ChunkLighting.h"
#pragma once
#include <cctype>

#include "../../Typenames.h"

class ChunkLightingContainer { //Contains all lighting infomation for solid blocks
private:
    uint64_t data_[256]{}; //x z y
public:

    static const unsigned char MaxLightLevel = 15;
    ChunkPos position_;

    ChunkLightingContainer();
    ~ChunkLightingContainer();

    uint64_t* getData();

    void ReplaceData(uint64_t* src);

    void EditLight(int x, int y, int z, unsigned char LightingInfo);

    uint8_t GetLighting(int x, int y, int z) const;

    void ResetLighting();

    void ResetLightingCustom(uint8_t lvl);

};
"./Level\\Chunk\\Palette.h"
#pragma once
#include <vector>
#include "../Typenames.h"
#include "../../Utils/Containers/NBitVector.h"
#include "Block/Blocks.h"
/*
* The palette class is used to store the block data in a compressed state in a chunk
* Each chunk has up to 4096 unique blocks so it attempts to store it in up to 12 bits per blocks
 */

//TODO: for a large amount of unique block, use stack / hashmap
class Palette { 
private:

    using PaletteIndex = uint16_t;
    using StorageBit = uint64_t;

    static constexpr int CHUNK_DIM = 16;
    static constexpr int CHUNK_SIZE = CHUNK_DIM * CHUNK_DIM * CHUNK_DIM; // 4096
    static constexpr int MIN_BIT_WIDTH = 1; // Minimum bits

    static constexpr int MAX_BIT_WIDTH = 12;

    int current_bit_width_;
    int unique_blocks_count_ = 1; // Initialize with only air blocks

    int d1 = 0, d2 = 0;

    NBitVector<StorageBit> data_;

    // BlockID -> Block, int_16 -> num of that block
    std::vector<std::pair<BlockID, int16_t>> palette_entries_;

    constexpr static int GetBitWidth(unsigned int n) {
        int bitWidth = std::bit_width(n);
        return std::max(bitWidth, MIN_BIT_WIDTH);
    }

    constexpr static size_t GetIndex(int x, int y, int z) {
        return x * CHUNK_DIM * CHUNK_DIM + y * CHUNK_DIM + z;
    }

    void Shrink() {
        int newBitWidth = GetBitWidth(unique_blocks_count_);
        NBitVector<StorageBit> newData(CHUNK_SIZE, newBitWidth);

        // Repack

        std::vector<std::pair<BlockID, int16_t>> newBlockToPaletteIndex(unique_blocks_count_);
        std::vector<PaletteIndex> newPaletteIndex(palette_entries_.size(), 0);

        // 2 pointers

        PaletteIndex curr = 0;
        for (int i = 0; i < palette_entries_.size(); ++i) {
            if (palette_entries_[i].second == 0) continue;
            newBlockToPaletteIndex[curr] = palette_entries_[i];
            newPaletteIndex[i] = curr;
            curr++;
        }

        for (int i = 0; i < CHUNK_SIZE; ++i) {
            PaletteIndex currVal = static_cast<PaletteIndex>(data_.Get(i));
            PaletteIndex newVal = newPaletteIndex[currVal];
            newData.Set(i, newVal);
        }

        data_ = newData;
        current_bit_width_ = newBitWidth;

        // refactor palette block index
        palette_entries_ = newBlockToPaletteIndex;
    }

    void Grow() {
        int newBitWidth = GetBitWidth(unique_blocks_count_);
        NBitVector<StorageBit> newData(CHUNK_SIZE, newBitWidth);
        current_bit_width_ = newBitWidth;
        for (int i = 0; i < CHUNK_SIZE; ++i) {
            newData.Set(i, data_.Get(i));
        }

        data_ = newData;
    }

    void Resize() {
        int newBitWidth = GetBitWidth(unique_blocks_count_);
        // Plus 1 to avoid frequent resizing
        if (newBitWidth == current_bit_width_ || newBitWidth + 1 == current_bit_width_) return;

        if (newBitWidth + 1 < current_bit_width_) { 
            Shrink();
        }
        else {
            Grow();
        }
    }

    PaletteIndex GetOrAddPaletteIndex(BlockID block) {
        PaletteIndex firstZero = 0;
        bool foundZero = false;
        for (PaletteIndex i = 0; i < palette_entries_.size(); i++) {
            if (palette_entries_[i].first == block) {
                return i;
            }
            if (palette_entries_[i].second == 0) {
                foundZero = true;
                firstZero = i;
            }
        }

        //d1++;
        
        if (foundZero) {
            palette_entries_[firstZero].first = block;
            return firstZero;
        }
        //d2++;

        palette_entries_.emplace_back(block, static_cast<int16_t>(0));
        Resize();
        PaletteIndex newIndex = static_cast<PaletteIndex>(palette_entries_.size() - 1);

        return newIndex;
    }

public:
    Palette() : current_bit_width_{MIN_BIT_WIDTH} , data_{ CHUNK_SIZE, current_bit_width_ } {
        palette_entries_.emplace_back(g_blocks.AIR, static_cast<uint16_t>(CHUNK_SIZE));
    }
    ~Palette() = default;
    Palette(Palette&&) noexcept = default;
    Palette& operator=(const Palette&) = default;
    Palette& operator=(Palette&&) noexcept = default;

    BlockID GetBlock(int x, int y, int z) const {
        if (x < 0 || x >= CHUNK_DIM || y < 0 || y >= CHUNK_DIM || z < 0 || z >= CHUNK_DIM) {
            throw std::out_of_range("Palette::GetBlock - Invalid palette index");
        }

        PaletteIndex idx = static_cast<PaletteIndex>(data_.Get(GetIndex(x, y, z)));

        if (idx >= palette_entries_.size()) throw std::runtime_error("Palette::GetBlock - Error in getting BlockID");

        return palette_entries_[idx].first;
    }

    BlockID GetBlockUnsafe(int x, int y, int z) const {
        PaletteIndex idx = static_cast<PaletteIndex>(data_.GetUnsafe(GetIndex(x, y, z)));
        return palette_entries_[idx].first;
    }

    void SetBlock(BlockID block, int x, int y, int z) {
        if (x < 0 || x >= CHUNK_DIM || y < 0 || y >= CHUNK_DIM || z < 0 || z >= CHUNK_DIM) {
            throw std::out_of_range("Palette::GetBlock - Invalid palette index");
        }

        // Look at original block
        PaletteIndex oldPaletteIdx = static_cast<PaletteIndex>(data_.Get(GetIndex(x, y, z)));
        if (oldPaletteIdx >= palette_entries_.size() || palette_entries_[oldPaletteIdx].second <= 0) {
            throw std::runtime_error("Palette::SetBlock - Corrupt old palette index found in data.");
        }

        palette_entries_[oldPaletteIdx].second--;

        BlockID oldBlockId = palette_entries_[oldPaletteIdx].first;

        bool uniqueCountChanged = false;
        if (block == oldBlockId) {
            return;
        }

        if (palette_entries_[oldPaletteIdx].second == 0) {
            unique_blocks_count_--;
            uniqueCountChanged = !uniqueCountChanged;
        }

        PaletteIndex idx = GetOrAddPaletteIndex(block);
        if (palette_entries_[idx].second++ == 0) {
            unique_blocks_count_++;
            uniqueCountChanged = !uniqueCountChanged;
        }

        data_.Set(GetIndex(x, y, z), idx);
        if (uniqueCountChanged) {
            Resize();
        }
    }

    void SetBlockUnsafe(BlockID block, int x, int y, int z) {
        // Look at original block
        PaletteIndex oldPaletteIdx = static_cast<PaletteIndex>(data_.GetUnsafe(GetIndex(x, y, z)));
        if (oldPaletteIdx >= palette_entries_.size() || palette_entries_[oldPaletteIdx].second <= 0) {
            throw std::runtime_error("Palette::SetBlock - Corrupt old palette index found in data.");
        }
        palette_entries_[oldPaletteIdx].second--;
        BlockID oldBlockId = palette_entries_[oldPaletteIdx].first;
        bool uniqueCountChanged = false;
        if (block == oldBlockId) {
            return;
        }

        if (palette_entries_[oldPaletteIdx].second == 0) {
            unique_blocks_count_--;
            uniqueCountChanged = !uniqueCountChanged;
        }

        PaletteIndex idx = GetOrAddPaletteIndex(block);
        if (palette_entries_[idx].second++ == 0) {
            unique_blocks_count_++;
            uniqueCountChanged = !uniqueCountChanged;
        }

        data_.Set(GetIndex(x, y, z), idx);
        if (uniqueCountChanged) {
            Resize();
        }
    }
};
"./Level\\Chunk\\TallChunk.cpp"
#include "TallChunk.h"

TallChunk::TallChunk() {
    chunk_sub_column_.resize(16);
    for (int i = 0; i < 16; i++) chunk_sub_column_[i] = std::make_unique<Chunk>();
}

void TallChunk::SetPosition(int x, int y, int z) { // confusing y -> tall chunk pos
    y = y * 16;
    for (int i = 0; i < 16; i++) {
        chunk_sub_column_[i]->SetPosition(x, y + i, z);
    }
}

int TallChunk::GetYPosition() {
    return chunk_sub_column_[0]->position_.y;
}

int TallChunk::GetXPosition() {
    return chunk_sub_column_[0]->position_.x;
}

int TallChunk::GetZPosition() {
    return chunk_sub_column_[0]->position_.z;
}

void TallChunk::SetBlockUnsafe(int x, int y, int z, BlockID block) {
    int ChunkIndex = y / 16;
    chunk_sub_column_[ChunkIndex]->SetBlockUnsafe(block, x, y & 0b1111, z);
}

BlockID TallChunk::GetBlockUnsafe(int x, int y, int z) {
    int ChunkIndex = y / 16;
    return chunk_sub_column_[ChunkIndex]->GetBlockUnsafe(x, y & 0b1111, z);
}
"./Level\\Chunk\\TallChunk.h"
#pragma once
#include "Chunk.h"

struct TallChunk {
    std::vector<std::unique_ptr<Chunk>> chunk_sub_column_;

    TallChunk();

    void SetPosition(int x, int y, int z);

    int GetYPosition();

    int GetXPosition();

    int GetZPosition();

    void SetBlockUnsafe(int x, int y, int z, BlockID block);

    BlockID GetBlockUnsafe(int x, int y, int z);
};
"./Level\\Collusion\\CollusionTest.cpp"

#include "../../Utils/Math/vectorOperations.h"

"./Level\\DataContainer\\ChunkMapData.cpp"
#include "ChunkMapData.h"


bool ChunkMap::EraseChunk(const ChunkPos& pos) { 
    const std::unique_ptr<Region>& reg = GetRegion(pos);

    // TODO: Fix me

    if (reg != nullptr) {
        reg->EraseChunkGlobalPos(pos.x, pos.y, pos.z);
        return true;
    }
    return false;
}


bool ChunkMap::SetBlockGlobal(BlockID block, const BlockPos& pos) {
    // TODO: Make it so BlockPos has a method to convert to chunk position location
    ChunkPos chunkPos = pos >> 4;
    BlockPos localPos = pos & 0b1111;

    if (!CheckRegion(chunkPos)) return false;

    const std::unique_ptr<Region>& reg = GetRegion(chunkPos);

    ChunkPos regionLocalPos = chunkPos & 0b11111;

    Chunk* chunk = reg->GetChunk(regionLocalPos.x, regionLocalPos.y, regionLocalPos.z);

    if (chunk != nullptr) {
        chunk->Use();
        chunk->SetBlockUnsafe(block, localPos.x, localPos.y, localPos.z);
        chunk->is_empty_ = false;
        chunk->Unuse();

        //Set lighting update to dirty
            
        ChunkColumn* col = reg->GetChunkColumn(regionLocalPos.x, regionLocalPos.z);
        col->UpdateHeightmapSingleBlock(regionLocalPos.y, block, localPos.z, localPos.y, localPos.z);

        return true;
    }

    return false;
}

bool ChunkMap::CheckChunk(const ChunkPos& pos) const {
    if (!CheckRegion(pos)) return g_blocks.AIR;
    const std::unique_ptr<Region>& reg = GetRegion(pos);

    return reg->CheckChunkGlobalPos(pos.x, pos.y, pos.z);
}

BlockID ChunkMap::GetBlockGlobal(const BlockPos& pos) {
    //c[3] is the position of the chunk
    //l[3] is the local position of a block inside a chunk

    ChunkPos chunkPos = pos >> 4;

    if (!CheckRegion(chunkPos)) return g_blocks.AIR;

    BlockPos localBlockPos = pos & 0b1111;

    const std::unique_ptr<Region>& reg = GetRegion(chunkPos);

    // TODO: Fix me
    Chunk* chunk = reg->GetChunkGlobalPos(chunkPos.x, chunkPos.y, chunkPos.z);

    if (chunk == nullptr) {
        return g_blocks.AIR;
    }

    BlockID block = chunk->GetBlock(localBlockPos.x, localBlockPos.y, localBlockPos.z);

    return block;
}

Chunk* ChunkMap::GetChunk(const ChunkPos& pos) const {
    if (!CheckRegion(pos)) return nullptr;
    const std::unique_ptr<Region>& reg = GetRegion(pos);

    return reg->GetChunkGlobalPos(pos.x, pos.y, pos.z);
}

ChunkColumn* ChunkMap::GetColumn(const ChunkColumnPos& pos) const {
    if (!CheckRegion(pos)) return nullptr;
    const std::unique_ptr<Region>& reg = GetRegion(pos);

    return reg->GetChunkColumnGlobalPos(pos.x, pos.z);
}

void ChunkMap::InsertChunk(std::unique_ptr<Chunk> chunk) {
    const ChunkPos& pos = chunk->position_;
    
    int x = pos.x;
    int y = pos.y;
    int z = pos.z;

    RegionPos regionPos = pos >> 5;

    if (!CheckRegion(pos)) {
        live_region_[regionPos] = std::make_unique<Region>();
    }

    const std::unique_ptr<Region>& reg = GetRegion(pos);

    for (int axis_ = 0; axis_ < 3; axis_++) {
        for (int face = 0; face < 2; face++) {
            ChunkPos posNeighbor = chunk->position_;
            posNeighbor.incrementSide(axis_ * 2 + face, 1);
            
            if (CheckChunk(posNeighbor)) {
                chunk->SetNeighbor(static_cast<ChunkContainer*>(GetChunk(posNeighbor)), axis_ * 2 + face);
                GetChunk(posNeighbor)->SetNeighbor(static_cast<ChunkContainer*>(chunk.get()), axis_ * 2 - face + 1);
                GetChunk(posNeighbor)->Use();
                GetChunk(posNeighbor)->UpdateGen();
                GetChunk(posNeighbor)->Unuse();
            }
        }
    }

    chunk->Use();
    chunk->UpdateGen();
    chunk->Unuse();

    reg->AddChunkGlobalPos(std::move(chunk), x, y, z);
}

bool ChunkMap::CheckRegion(const ChunkPos& pos) const {
    // TODO: Use a different class for region pos 
    RegionPos regPos = pos >> 5;

    FastHashMap<RegionPos, std::unique_ptr<Region>>::const_iterator it = live_region_.find(regPos);

    if (it == live_region_.end()) {
        return false;
    }
    else {
        return true;
    }
}

const std::unique_ptr<Region>& ChunkMap::GetRegion(const ChunkPos& pos) const {
    // TODO: Use a different class for region pos 
    RegionPos regPos = pos >> 5;

    FastHashMap<RegionPos, std::unique_ptr<Region>>::const_iterator it = live_region_.find(regPos);

    if (it == live_region_.end()) {
        throw std::runtime_error("Tried to get invalid region");
    }

    return it->second;
}
//_____________________________________________________

Region::Region() {
    region_.resize(32 * 32);
}

Region::~Region() {
    region_.clear();
}

void Region::AddChunk(std::unique_ptr<Chunk> chunk, int x, int y, int z) {
    if (region_[x * 32 + z] == nullptr) {
        region_[x * 32 + z] = std::make_unique<ChunkColumn>();
    }
    region_[x * 32 + z]->AddChunk(std::move(chunk), y);
}

void Region::EraseChunk(int x, int y, int z) {
    ChunkColumn* c = region_[x * 32 + z].get();
    if (c == nullptr) return;
    if (c->GetChunk(y) == nullptr) return;

    c->GetChunk(y)->ClearNeighbors();

    region_[x * 32 + z] = nullptr;
}

bool Region::CheckChunk(int x, int y, int z) const {
    if (!CheckChunkColumn(x, z)) {
        return false;
    }
    return region_[x * 32 + z]->GetChunk(y) != nullptr;
}

Chunk* Region::GetChunk(int x, int y, int z) const {
    if (region_[x * 32 + z] != nullptr) {
        return region_[x * 32 + z]->GetChunk(y);
    }
    return nullptr;
}

void Region::AddChunkGlobalPos(std::unique_ptr<Chunk> chunk, int x, int y, int z) {
    int regCX = x & 0b11111;
    int regCY = y & 0b11111;
    int regCZ = z & 0b11111;

    AddChunk(std::move(chunk), regCX, regCY, regCZ);
}

void Region::EraseChunkGlobalPos(int x, int y, int z) {
    int regCX = x & 0b11111;
    int regCY = y & 0b11111;
    int regCZ = z & 0b11111;

    EraseChunk(regCX, regCY, regCZ);
}

bool Region::CheckChunkGlobalPos(int x, int y, int z) const {
    int regCX = x & 0b11111;
    int regCY = y & 0b11111;
    int regCZ = z & 0b11111;

    return CheckChunk(regCX, regCY, regCZ);
}

Chunk* Region::GetChunkGlobalPos(int x, int y, int z) const {
    int regCX = x & 0b11111;
    int regCY = y & 0b11111;
    int regCZ = z & 0b11111;

    return GetChunk(regCX, regCY, regCZ);
}

ChunkColumn* Region::GetChunkColumn(int x, int z) const {
    return region_[x * 32 + z].get();
}

ChunkColumn* Region::GetChunkColumnGlobalPos(int x, int z) const {
    int regCX = x & 0b11111;
    int regCZ = z & 0b11111;

    return GetChunkColumn(regCX, regCZ);
}

bool Region::CheckChunkColumn(int x, int z) const {
    return region_[x * 32 + z] != nullptr;
}
bool Region::CheckChunkColumnGlobalPos(int x, int z) const {
    int regCX = x & 0b11111;
    int regCZ = z & 0b11111;

    return CheckChunkColumn(regCX, regCZ);
}
"./Level\\DataContainer\\ChunkMapData.h"
#pragma once
#include <vector>
#include "../Chunk/Chunk.h"
#include "../Chunk/ChunkColumn.h"

typedef unsigned long long int RegionID;

struct Region { //32x32x32 Chunk Region
    //ChunkColumn* region_[32 * 32]{ nullptr };
    std::vector<std::unique_ptr<ChunkColumn>> region_;
    Region();
    ~Region();

    void AddChunk(std::unique_ptr<Chunk> chunk, int x, int y, int z);
    void AddChunkGlobalPos(std::unique_ptr<Chunk> chunk, int x, int y, int z);

    void EraseChunk(int x, int y, int z);
    void EraseChunkGlobalPos(int x, int y, int z);

    bool CheckChunk(int x, int y, int z) const;
    bool CheckChunkGlobalPos(int x, int y, int z) const;

    Chunk* GetChunk(int x, int y, int z) const;
    Chunk* GetChunkGlobalPos(int x, int y, int z) const;

    ChunkColumn* GetChunkColumn(int x, int z) const;
    ChunkColumn* GetChunkColumnGlobalPos(int x, int z) const;

    bool CheckChunkColumn(int x, int z) const;
    bool CheckChunkColumnGlobalPos(int x, int z) const;

    uint64_t access_count_ = 0;
};

class ChunkMap {
public:

    ChunkColumn* GetColumn(const ChunkPos& pos) const;

    bool CheckChunk(const ChunkPos& pos) const;

    BlockID GetBlockGlobal(const BlockPos& pos);

    bool SetBlockGlobal(BlockID block, const BlockPos& pos);

    void InsertChunk(std::unique_ptr<Chunk> chunk);

    bool EraseChunk(const ChunkPos& pos);

    Chunk* GetChunk(const ChunkPos& pos) const;
private:
    //Input position is the chunk position
    const std::unique_ptr<Region>& GetRegion(const ChunkPos& pos) const;
    bool CheckRegion(const ChunkPos& pos) const;

    FastHashMap<RegionPos, std::unique_ptr<Region>> live_region_;
};
"./Level\\DataContainer\\EntityContainer.h"
#pragma once
#include "../Entity/Entity.h"
#include <mutex>

class EntityContainer { //Manages all entities in world
private:
    FastHashMap<EntityUUID, Entity*> entities_;
    FastHashSet<EntityUUID> removed_entity_;
    std::mutex entity_lock_;
    EntityUUID unique_id_ = 0;
    int entity_count_ = 0;
public:
    void AddEntities(Entity& e) {
        e.properties_.entity_uuid_ = unique_id_;
        entities_.emplace(unique_id_, &e);
        unique_id_++;
        entity_count_++;
    }

    void AddEntities(Entity* e) {
        e->properties_.entity_uuid_ = unique_id_;
        entities_.emplace(unique_id_, e);
        unique_id_++;
        entity_count_++;
    }

    int GetEntityCount() const {
        return entity_count_;
    }

    FastHashMap<EntityUUID, EntityProperty> ClientGetEntityUpdate() { //change this to past on a vector later
        FastHashMap<EntityUUID, EntityProperty> updatedData;

        for (auto& entity : entities_) {
            if (entity.second->is_dirty_)  {
                entity.second->is_dirty_ = false;
                updatedData.emplace(entity.second->properties_.entity_uuid_, entity.second->properties_);
            }
        }

        return updatedData;
    }

    void RemoveEntity(EntityUUID entityId) {
        delete entities_[entityId];
        entities_.erase(entityId);
        std::lock_guard<std::mutex> lock{ entity_lock_ };
        removed_entity_.emplace(entityId);
        entity_count_--;
    }

    FastHashSet<EntityUUID> getRemovedEntities() {
        std::lock_guard<std::mutex> lock{ entity_lock_ };
        return std::move(removed_entity_);
    }

    Entity* GetEntity(EntityUUID entityId) {
        if (entities_.count(entityId))
            return entities_[entityId];
        return nullptr;
    }

    void Tick(Dimension* dimension) {
        for (auto& entity : entities_) {
            entity.second->Tick(dimension);
        }
    }

};
"./Level\\Dimension\\Dimension.h"
#pragma once
#include "DimensionProperties.h"
#include "../DataContainer/EntityContainer.h"
#include "../Event/EventSystem.h"
#include "../Event/EventHandler.h"
#include "../TerrainGeneration/Generator.h"
#include "../TerrainGeneration/Generators/GeneratorType.h"
#include "../World/World.h"
#include "../World/WorldInteraction/WorldInteractions.h"
#include "../World/WorldParameters.h"
#include "../../Core/Options/Option.h"

class Dimension {
private:
    World* world_;
    DimensionProperties properties_;
    WorldParameters world_settings_;
    
    FastHashMap<int, FastHashSet<ChunkPos>> tick_usage_;

protected:
    WorldGeneratorID generator_type_;

    void Start(DimensionProperties properties) {
        world_ = new World;
        world_->Initialize();
        properties_ = properties;
        world_settings_.horizontal_ticking_distance_ = g_app_options.horizontal_render_distance_;
        world_settings_.vertical_ticking_distance_ = g_app_options.vertical_render_distance_;

        world_interactions_.init(world_, world_settings_);


        if (g_generators.GetGenerator(generator_type_)->use_tall_chunks_) {
            world_interactions_.UseTallGeneration();
        }
        
    }
public:
    WorldInteractions world_interactions_;
    EventSystem event_manager_;
    const int tick_rate_ = 20; //TODO: tmp fix

    Dimension(WorldGeneratorID generatorTypeIn = g_generators.DEBUG) {
        generator_type_ = generatorTypeIn;
        world_ = nullptr;
    }

    WorldGeneratorID GetGeneratorType() {
        return generator_type_;
    }
    
    // TODO: Use custom block classd

    bool CheckTickUsed(EventID id, const BlockPos& pos) {//temp sol
        return tick_usage_[id].count(pos);
    }

    void TickUsed(EventID id, const BlockPos& pos) {//temp solution
        tick_usage_[id].insert(pos);
    }

    void Initialize(DimensionProperties p) { //Generate new world
        Start(p);
    }

    virtual void Tick() { 
        
    }

    void EventTick() {
        std::unique_ptr<std::vector<Event::Event>>& EventQueue = event_manager_.GetQueue();

        for (size_t i = 0; i < EventQueue->size(); i++) {
            const Event::Event& e = EventQueue->at(i);
            switch (e.type_) {
            case Event::NULL_EVENT:
                break;
            case Event::BLOCK_EVENT:
            {
                const Event::BlockEvent& blockEvent = std::get<Event::BlockEvent>(e.event_data_);
                if (CheckTickUsed(blockEvent.id_, blockEvent.pos_)) {
                    continue;
                }
                TickUsed(blockEvent.id_, blockEvent.pos_);
                break;
            }
            case Event::ENTITY_EVENT:
            {
                const Event::EntityEvent& entityEvent = std::get<Event::EntityEvent>(e.event_data_);
                if ((entityEvent.unique_id_ != 0) && CheckTickUsed(entityEvent.unique_id_, entityEvent.pos_)) {
                    continue;
                }
                // TODO: tmp fix rework this later
                if ((entityEvent.unique_id_ != 0)) {
                    TickUsed(static_cast<EventID>(entityEvent.entity_uuid_), entityEvent.pos_);
                }
                break;
            }
            default:
                throw std::exception("Not handled yet!");
            }

            g_event_handler.ExecuteEvent(e, this);
        }

        EventQueue->clear();
        event_manager_.Swap();

        tick_usage_.clear();

        //Tick all entities

        world_->entities_->Tick(this);
    }
};
"./Level\\Dimension\\DimensionProperties.h"
#pragma once
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>

struct DimensionProperties {
    DimensionProperties() {

    }
};
"./Level\\Dimension\\Dimensions\\Overworld.h"
#pragma once
#include "../Dimension.h"

class OverworldDimension : public Dimension {
public:
    OverworldDimension() : Dimension(g_generators.MOUNTAINS) {}

    void Tick() override {

    }
};
"./Level\\Entity\\Collusion\\Hitbox.h"
#pragma once
#include <glm/vec3.hpp>

struct AABB {
    glm::vec3 size_ = glm::dvec3(0.f,0.f,0.f);
    glm::vec3 offset_ = glm::dvec3(0.f,0.f,0.f);
};
"./Level\\Entity\\Entities.cpp"
#include "Entities.h"

#include "Type/Types.h"

#include <fstream>
#include <nlohmann/json.hpp>
#include <iostream>

using json = nlohmann::json;

EntitiesList::EntitiesList() {

}

EntityTypeID EntitiesList::RegisterEntity(std::string EntityName, EntityTypeEnums type_) {
    EntityTypeID ID = static_cast<EntityTypeID>(entity_type_list_.size());
    EntityType* newEntity = nullptr;

    switch (type_) {
    case ENTITY_PASSIVE:
        newEntity = static_cast<EntityType*>(new Passive());
        break;
    case ENTITY_FALLING_BLOCK:
        newEntity = static_cast<EntityType*>(new FallingBlock());
        break;
    case ENTITY_HOSTILE:
        newEntity = static_cast<EntityType*>(new Hostile());
        break;
    }

    if (newEntity == nullptr) {
        throw std::exception("Error!");
    }

    newEntity->entity_name_ = EntityName;

    g_logger.LogInfo("EntitiesList::RegisterEntity", "Registered new entity: " + EntityName + " | EntityID: " + std::to_string(ID));

    newEntity->id_ = ID;

    entity_type_list_.emplace_back(newEntity);
    EntityNameID[EntityName] = ID;

    return ID;

}


void EntitiesList::InitializeModels() {
    std::ifstream file("assets/EntityShape.json");
    
    json data = json::parse(file);

    for (auto& b : data.items()) {
        EntityTypeID entityType = EntityNameID[b.key()];

        json::iterator d = b.value().begin();

        if (d.value().is_string()) {
            g_logger.LogInfo("EntitiesList::InitializeModels", "Entity: " + b.key() + " | Texture Loading: " + (std::string)d.value());
            RawTextureData TexData;
            TexData.Load(((std::string)d.value()).c_str());
            entity_type_list_[entityType]->texture_.Gen();
            entity_type_list_[entityType]->texture_.Load(TexData);
        }

        d++;

        glm::vec3 hitboxSize(d.value().at(0), d.value().at(1), d.value().at(2));

        entity_type_list_[entityType]->ChangeHitboxSize(hitboxSize);
        
        d++; 

        for (auto& SubData : d.value().items()) {
            json::iterator it = SubData.value().begin();

            glm::vec3 offset(it.value().at(0), it.value().at(1), it.value().at(2));

            it++;

            glm::vec3 shapeSize(it.value().at(0), it.value().at(1), it.value().at(2));

            it++;

            Model::RectangularPrism* model = entity_type_list_[entityType]->render_model_.AddRectangle(shapeSize, offset);

            for (auto& ShapeUV : it.value().items()) {
                json::iterator uv_iterator = ShapeUV.value().begin();

                std::vector<int> uvFaces = {};

                for (auto& uvFace : uv_iterator.value().items()) {
                    int s = 0xFF;

                    std::string texSide = uvFace.value();

                    if (!strcmp(texSide.c_str(), "FRONT"))
                        s = FRONT;
                    if (!strcmp(texSide.c_str(), "BACK"))
                        s = BACK;
                    if (!strcmp(texSide.c_str(), "LEFT"))
                        s = LEFT;
                    if (!strcmp(texSide.c_str(), "RIGHT"))
                        s = RIGHT;
                    if (!strcmp(texSide.c_str(), "TOP"))
                        s = TOP;
                    if (!strcmp(texSide.c_str(), "BOTTOM"))
                        s = BOTTOM;

                    uvFaces.push_back(s);
                }

                uv_iterator++;
                
                glm::vec2 pts[2]{};

                int index = 0;

                for (auto& UV_Points : uv_iterator.value().items()) { //iterate though uv points
                    pts[1 - index] = glm::vec2((float)UV_Points.value().at(0), 1.f - (float)UV_Points.value().at(1));
                    index++;
                }

                for (int& face : uvFaces) {
                    model->uv_map_[face].p0_ = pts[0];
                    model->uv_map_[face].p1_ = pts[1];
                }
            }
        }
    }
}

void EntitiesList::Initialize() {
    InitializeModels();
}

EntityType* EntitiesList::GetEntity(EntityTypeID id) {
    return entity_type_list_[id];
}
"./Level\\Entity\\Entities.h"
#pragma once

#include "Type/EntityType.h"

#include <deque>


enum EntityTypeEnums {
    ENTITY_PASSIVE, ENTITY_HOSTILE, ENTITY_FALLING_BLOCK
};

class EntitiesList {
private:
    int entity_type_count_ = 0;
    FastHashMap<std::string, EntityTypeID> EntityNameID;
public:
    EntitiesList();

    void InitializeModels();
    void Initialize();
    EntityTypeID RegisterEntity(std::string entityName, EntityTypeEnums type_);
    EntityType* GetEntity(EntityTypeID id);

    std::vector<EntityType*> entity_type_list_;

    EntityTypeID HUMAN = RegisterEntity("human", ENTITY_PASSIVE);
    EntityTypeID PLAYER = RegisterEntity("player", ENTITY_PASSIVE);
    EntityTypeID ZOMBIE = RegisterEntity("zombie", ENTITY_HOSTILE);
    EntityTypeID SAND_GRAVITY_BLOCK = RegisterEntity("sand", ENTITY_FALLING_BLOCK);

};

extern EntitiesList g_entity_list;


"./Level\\Entity\\Entity.cpp"
#include "Entity.h"
#include "Entities.h"

Entity::Entity() {

}

void Entity::Tick(Dimension* dimension) {
    g_entity_list.entity_type_list_[properties_.type_]->Tick(this, dimension);
}
"./Level\\Entity\\Entity.h"
#pragma once
#include "Properties/EntityProperties.h"
#include "../Typenames.h"
#include "../Item/Inventory/EntityInventory.h"

extern int AmountEntityDestroy;

class Dimension;

struct Entity  {
    
    EntityProperty properties_; //Provide properties such as position, acceleration, etc.

    bool is_dirty_ = true;

    Entity();
    void Tick(Dimension* dimension);
};
"./Level\\Entity\\Mobs\\Player.h"
#pragma once
#include "../Type/EntityType.h"

class Player : public Entity {
public:
    EntityInventory entity_inventory_;

    Player() {
        properties_.is_chunk_loader_ = true;
    }

private:
};
"./Level\\Entity\\Properties\\EntityProperties.h"
#pragma once
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>

#include "../../Typenames.h"

struct EntityProperty {
    EntityProperty() = default;
    EntityProperty(const EntityProperty&) = default;
    ~EntityProperty() = default;

    glm::vec3 velocity_ = glm::vec3(0.f, 0.f, 0.f);
    glm::vec3 position_ = glm::vec3(0.f, 0.f, 0.f);
    glm::vec3 acceleration_ = glm::vec3(0.f, 0.f, 0.f);
    glm::vec2 rotation_ = glm::vec2(0.f, 0.f);

    float max_speed_ = 50;

    bool on_ground_ = false;

    bool is_chunk_loader_ = false;

    EntityUUID entity_uuid_ = NULL;
    EntityTypeID type_ = NULL; //State what type of entity is it. Zombie? Human??

    bool operator==(const EntityProperty& other) {
        return entity_uuid_ == other.entity_uuid_;
    }
};

namespace std {
    template <>
    struct hash<EntityProperty> {
        size_t operator ()(const EntityProperty& e) const {
            return hash<EntityTypeID>{}(e.entity_uuid_);
        }
    };
    
}
"./Level\\Entity\\Type\\EntityType.h"
#pragma once
#include "../../Typenames.h"
#include "../Collusion/Hitbox.h"
#include "../../../RenderEngine/EntityRenderer/Models/EntityModel.h"
#include "../Entity.h"
#include "../../../RenderEngine/OpenGL/Texture/Types/Texture2D.h"

class Dimension;

class EntityType {
public:
    
    EntityType() {

    }
    
    void ChangeHitboxSize(glm::vec3 size) {
        hitbox_.size_ = size;
    }

    void ChangeHitboxSize(float x, float y, float z) {
        hitbox_.size_ = glm::vec3(x, y, z);
    }

    AABB& GetHitbox() {
        return hitbox_;
    }

    virtual void Tick(Entity* entity, Dimension* dimension) = 0;

    EntityTypeID id_ = NULL;

    EntityModel render_model_;

    Texture2D texture_;

    std::string entity_name_;

private:
    
    AABB hitbox_;
};


"./Level\\Entity\\Type\\FallingBlock.cpp"
#include "FallingBlock.h"
#include "../../Dimension/Dimension.h"
#include "../../Entity/Entity.h"

void FallingBlock::Tick(Entity* entity, Dimension* dimension) {
    //    std::cout << entity->Properties.Velocity.y << "\n";
    float mspt = 1.0f / static_cast<float>(dimension->tick_rate_);

    //Physics

    //Logger.LogInfo("Sand", std::to_string(entity->Properties.Position.y));

    entity->properties_.acceleration_.y = -dimension->world_interactions_.settings_->gravity_;

    entity->properties_.velocity_ += entity->properties_.acceleration_ * mspt;

    int distanceCheck = (int)ceil(abs(entity->properties_.velocity_.y * mspt));

    float collusionDistance = dimension->world_interactions_.collusions_->GetDistanceUntilCollusionSingleDirection(entity->properties_.position_, NY, distanceCheck + 1);

    float timeTillCollusion = abs(collusionDistance / entity->properties_.velocity_.y);

    bool collideWithGround = false;

    if ((timeTillCollusion < mspt) && (collusionDistance != -1.f)) {
        entity->properties_.position_[1] += entity->properties_.velocity_[1] * (float)timeTillCollusion;
        entity->properties_.velocity_[1] = 0.f;
        entity->properties_.acceleration_[1] = 0.f;

        collideWithGround = true;
    }
    else {
        entity->properties_.position_[1] += entity->properties_.velocity_[1] * mspt;
    }
    entity->is_dirty_ = true;

    if (collideWithGround) {
        Event::BlockEvent addBlock{ BlockPos{
                                        (int)entity->properties_.position_.x,
                                        (int)entity->properties_.position_.y,
                                        (int)entity->properties_.position_.z},
                                    g_blocks.SAND, g_event_handler.BlockPlace };
        dimension->event_manager_.AddEvent(addBlock);

        Event::EntityEvent removeEntity;
        removeEntity.id_ = g_event_handler.RemoveEntity;
        removeEntity.entity_uuid_ = entity->properties_.entity_uuid_;
        removeEntity.unique_id_ = 50;

        dimension->event_manager_.AddEvent(removeEntity);
    }
}
"./Level\\Entity\\Type\\FallingBlock.h"
#pragma once
#include "EntityType.h"

class Entity;
class Dimension;

class FallingBlock : public EntityType {
    void Tick(Entity* entity, Dimension* dimension) override;
};
"./Level\\Entity\\Type\\Hostile.cpp"
#include "Hostile.h"
#include "../../Dimension/Dimension.h"
#include "../../Entity/Entity.h"

void Hostile::Tick(Entity* entity, Dimension* dimension) {
    (void)entity;
    (void)dimension;
}
"./Level\\Entity\\Type\\Hostile.h"
#pragma once
#include "EntityType.h"

class Entity;
class Dimension;

class Hostile : public EntityType {
    void Tick(Entity* entity, Dimension* dimension) override;
};
"./Level\\Entity\\Type\\Passive.cpp"
#include "Passive.h"
#include "../../Dimension/Dimension.h"
#include "../../Entity/Entity.h"

void Passive::Tick(Entity* entity, Dimension* dimension) {
    (void)entity;
    (void)dimension;
}
"./Level\\Entity\\Type\\Passive.h"
#pragma once
#include "EntityType.h"

class Entity;
class Dimension;

class Passive : public EntityType {
    void Tick(Entity* entity, Dimension* dimension) override;
};
"./Level\\Entity\\Type\\Types.h"
#pragma once

#include "FallingBlock.h"
#include "Hostile.h"
#include "Passive.h"
"./Level\\Event\\BlockEventHandles\\BlockHandles.cpp"
#include "BlockHandles.h"
#include "../EventHandler.h"
#include "../../Chunk/Block/Type/Dirt.h"
#include "../../../Level/Dimension/Dimension.h"

void UpdateSurrounding(const Event::BlockEvent& blockEvent, Dimension* dimension) {
    for (int side = 0; side < 6;  side++) {
        BlockPos newPos = blockEvent.pos_;
        newPos.incrementSide(side, 1);

        BlockID block = dimension->world_interactions_.GetBlock(newPos);

        Event::BlockEvent tickNeighbor{newPos, block, g_event_handler.BlockTick};
        dimension->event_manager_.AddEvent(tickNeighbor);
    }

    Event::BlockEvent tickMain{ blockEvent.pos_, dimension->world_interactions_.GetBlock(blockEvent.pos_), g_event_handler.BlockTick};
    dimension->event_manager_.AddEvent(tickMain);
}

void HandlePlaceBlock(const Event::BlockEvent& blockEvent, Dimension* dimension) {
    dimension->world_interactions_.SetBlock(blockEvent.block_, blockEvent.pos_);
    UpdateSurrounding(blockEvent, dimension);
}

void HandleBlockTick(const Event::BlockEvent& blockEvent, Dimension* dimension) {
    Block* b = g_blocks.GetBlockType(blockEvent.block_);
    b->Tick(blockEvent.pos_, dimension);
}
"./Level\\Event\\BlockEventHandles\\BlockHandles.h"
#pragma once
#include "../../Chunk/Block/Block.h"

class Dimension;

namespace Event {
    struct BlockEvent;
};

void HandlePlaceBlock(const Event::BlockEvent&, Dimension* dimension);
void HandleBlockTick(const Event::BlockEvent&, Dimension* dimension);
"./Level\\Event\\ChunkEventHandles\\ChunkHandles.cpp"
#include "ChunkHandles.h"
#include "../EventHandler.h"

void UpdateLighting(const Event::ChunkEvent& chunkEvent) {

}

void ChunkUpdate(const Event::ChunkEvent& chunkEvent) {

}

void GenerateChunk(const Event::ChunkEvent& chunkEvent) {

}



"./Level\\Event\\ChunkEventHandles\\ChunkHandles.h"
#pragma once
"./Level\\Event\\EntityEventHandles\\EntityHandles.cpp"
#include "EntityHandles.h"
#include "../../Entity/Entities.h"
#include "../../Chunk/Block/Block.h"
#include "../../../Level/Dimension/Dimension.h"

void HandleEntityTick(const Event::EntityEvent& e, Dimension* dimension) { //prob useless
    Entity* entity = dimension->world_interactions_.GetEntity(e.entity_type_);
    entity->Tick(dimension);
}

void HandleEntitySummon(const Event::EntityEvent& e, Dimension* dimension) {
    Entity* entity = new Entity;
    entity->properties_.position_.x = static_cast<float>(e.pos_.x);
    entity->properties_.position_.y = static_cast<float>(e.pos_.y);
    entity->properties_.position_.z = static_cast<float>(e.pos_.z);
    entity->properties_.type_ = e.entity_type_;
    dimension->world_interactions_.AddEntity(entity);
}

void HandleRemoveEntity(const Event::EntityEvent& e, Dimension* dimension) {
    dimension->world_interactions_.KillEntity(e.entity_uuid_);
}
"./Level\\Event\\EntityEventHandles\\EntityHandles.h"
#pragma once
#include "../../Entity/Entity.h"
#include "../../Event/Event.h"

class Dimension;

void HandleEntityTick(const Event::EntityEvent& e, Dimension* dimension);
void HandleEntitySummon(const Event::EntityEvent& e, Dimension* dimension);
void HandleRemoveEntity(const Event::EntityEvent& e, Dimension* dimension);
"./Level\\Event\\Event.h"
#pragma once
#include <variant>

#include "../Entity/Entity.h"
#include "../Typenames.h"
#include "../Chunk/ChunkPos/ChunkPos.h"


constexpr size_t MAX_EVENT_SIZE = 32;


namespace Event {

    struct BlockEvent {
        BlockEvent(BlockPos pos, BlockID block, EventID id, char unique_id = 0) : pos_{ pos }, block_{ block }, id_{ id }, unique_id_{ unique_id } {}
        BlockEvent() {}

        BlockPos pos_; // 12 - 8
        BlockID block_; //1
        EventID id_ = 0; //8
        char unique_id_ = 0;
    };

    struct ChunkEvent {
        ChunkPos pos_;
        EventID id_ = 0;
        char unique_id_ = 0;
    };

    struct EntityEvent {
        BlockPos pos_{0,0,0};
        EntityTypeID entity_type_ = NULL;
        EntityUUID entity_uuid_ = NULL;
        EventID id_ = 0;
        char unique_id_ = 0;
    };

    enum EventType {
        NULL_EVENT,
        BLOCK_EVENT,
        ENTITY_EVENT,
        CHUNK_LOAD_EVENT,
        CHUNK_UNLOAD_EVENT
    };

    struct Event {
        EventType type_ = NULL_EVENT;
        int tick_time_ = 0;

        Event(const Event& other) : type_{ other.type_ },
            tick_time_{ other.tick_time_ },
            event_data_{ other.event_data_ } {}

        Event() {};

        template <typename EventType> 
        Event(const EventType& newEvent) {
            if constexpr (std::is_same_v<EventType, EntityEvent>) {
                type_ = ENTITY_EVENT;
            }
            else if constexpr (std::is_same_v<EventType, ChunkEvent>) {
                type_ = CHUNK_LOAD_EVENT;
            }
            else if constexpr (std::is_same_v<EventType, BlockEvent>) {
                type_ = BLOCK_EVENT;
            }
            else {
                throw std::runtime_error("Invalid event type!");
            }

            event_data_ = newEvent;
        }

        std::variant<BlockEvent, ChunkEvent, EntityEvent, std::monostate> event_data_;
    };

}
"./Level\\Event\\EventHandler.cpp"
#include "EventHandler.h"

void EventHandler::ExecuteEvent(Event::Event event, Dimension* dimension) {
    switch (event.type_) {
    case Event::BLOCK_EVENT:
    {
        const Event::BlockEvent& blockEvent = std::get<Event::BlockEvent>(event.event_data_);
        (*block_event_handles_[blockEvent.id_])(blockEvent, dimension);
        break;
    }
    case Event::ENTITY_EVENT:
    {
        const Event::EntityEvent& entityEvent = std::get<Event::EntityEvent>(event.event_data_);
        (*entity_event_handles_[entityEvent.id_])(entityEvent, dimension);
        break;
    }
    }
}

EventID EventHandler::RegisterBlockEvent(void (*func)(const Event::BlockEvent&, Dimension*)) {
    block_event_handles_[event_count_] = func;
    return event_count_++;
}
EventID EventHandler::RegisterEntityEvent(void (*func)(const Event::EntityEvent&, Dimension*)) {
    entity_event_handles_[event_count_] = func;
    return event_count_++;
}
"./Level\\Event\\EventHandler.h"
#pragma once
#include <stdarg.h>
#include <variant>

#include "Event.h"
#include "../Chunk/Block/Block.h"
#include "BlockEventHandles/BlockHandles.h"
#include "EntityEventHandles/EntityHandles.h"

class EventHandler {
private:
    using EventFunctionTypes = std::variant<
        void (*)(BlockID, const BlockPos&, Dimension*),
        void (*)(Event::EntityEvent, Dimension*)
    >;

    int event_count_ = 0;
    EventID RegisterBlockEvent(void (*func)(const Event::BlockEvent&, Dimension*));

    EventID RegisterEntityEvent(void (*func)(const Event::EntityEvent&, Dimension*));

    FastHashMap<EventID, void (*)(const Event::BlockEvent&, Dimension*)> block_event_handles_;
    FastHashMap<EventID, void (*)(const Event::EntityEvent&, Dimension*)> entity_event_handles_;

public:

    // TODO: Naming scheme exception?
    EventID BlockPlace = RegisterBlockEvent(HandlePlaceBlock);
    EventID BlockTick = RegisterBlockEvent(HandleBlockTick);

    EventID SummonEntity = RegisterEntityEvent(HandleEntitySummon);
    EventID EntityTick = RegisterEntityEvent(HandleEntityTick);
    EventID RemoveEntity = RegisterEntityEvent(HandleRemoveEntity);

    void ExecuteEvent(Event::Event event, Dimension* dimension);


} inline g_event_handler;
"./Level\\Event\\EventSystem.cpp"
#include "EventSystem.h"

std::unique_ptr<std::vector<Event::Event>>& EventSystem::GetQueue() {
    return queue_active_;
}

void EventSystem::Swap() {
    std::unique_ptr<std::vector<Event::Event>> tmp = std::move(queue_active_);
    queue_active_ = std::move(queue_unactive_);
    queue_unactive_ = std::move(tmp);
}
"./Level\\Event\\EventSystem.h"
#pragma once
#include "Event.h"
#include <deque>


class EventSystem {
public:
    
    EventSystem() {
        NullEvent.type_ = Event::NULL_EVENT;

        queue_active_ = std::make_unique<std::vector<Event::Event>>();
        queue_unactive_ = std::make_unique<std::vector<Event::Event>>();

        queue_active_->reserve(UINT16_MAX);
        queue_unactive_->reserve(UINT16_MAX);
    }

    ~EventSystem() {
        queue_active_->clear();
        queue_unactive_->clear();
    }

    //Gets event; if empty, return null event
    std::unique_ptr<std::vector<Event::Event>>& GetQueue();

    template <class EventType> void AddEvent(EventType e) {
        queue_unactive_->emplace_back(e);
    }

    void Swap();

private:
    std::unique_ptr<std::vector<Event::Event>> queue_active_;
    std::unique_ptr<std::vector<Event::Event>> queue_unactive_;

    Event::Event NullEvent;
};
"./Level\\Item\\Inventory\\EntityInventory.h"
#pragma once
#include "Inventory.h"
#include "../../Chunk/Block/Blocks.h"
#include "../../Item/Items.h"
class EntityInventory : public Inventory {
public:
    EntityInventory(int slotCount = 9) {
        Initialize(slotCount);
    }

    int right_hand_slot_ = 0;
    int left_hand_slot_ = 0;

private:
};
"./Level\\Item\\Inventory\\Inventory.cpp"
#include "Inventory.h"

ItemStack Inventory::GetItem(int slot) {
    return storage_[slot];
}

void Inventory::SetSlot(int slot, ItemStack item) {
    storage_[slot] = item;
}

int Inventory::GetSlotCount() {
    return num_slots_;
}

void Inventory::ChangeSlotSize(int slotCount) {
    storage_.resize(slotCount);
    num_slots_ = slotCount;
}

void Inventory::Initialize(int slotCount) {
    num_slots_ = slotCount;
    storage_.resize(slotCount);
}
"./Level\\Item\\Inventory\\Inventory.h"
#pragma once
#include "../../Typenames.h"
#include "../../Chunk/Block/Blocks.h"
#include "../ItemStack.h"
#include <unordered_map>
#include <vector>

class Inventory {
public:

    Inventory(int inventorySize = 0x7FFFFFFF) {
        if (inventorySize == 0x7FFFFFFF)
            return;
        Initialize(inventorySize);
    }

    ~Inventory() {
        storage_.clear();
    }

    ItemStack GetItem(int slot);

    void SetSlot(int slot, ItemStack item);
    
    int GetSlotCount();

    void ChangeSlotSize(int slotCount);

protected:
    void Initialize(int slotCount);

private:
    
    int num_slots_ = 64;
    std::vector<ItemStack> storage_;

};
"./Level\\Item\\Inventory\\PlayerInventory.h"
#pragma once

#include "Inventory.h"
#include "../../Chunk/Block/Blocks.h"
#include "../../Item/Items.h"
class PlayerInventory : public Inventory {
public:
    PlayerInventory() : Inventory{ g_items.GetTotalItemCount() } {}
};
"./Level\\Item\\Item.cpp"
#include "Item.h"
#include "../../RenderEngine/OpenGL/Texture/Texture.h"

BlockID Item::GetBlock() const {
    return properties_.block_;
}

RawTextureData Item::GetTexture() const {
    return RawTextureData();
}

bool Item::CheckIsBlockItem() const {
    return properties_.is_block_item_;
}
"./Level\\Item\\Item.h"
#pragma once
#include "../Typenames.h"

#include <string>

class RawTextureData;

struct ItemProperties {
    int max_stack_ = 64;
    bool is_block_item_ = false;
    BlockID block_ = NULL;
    ItemID id_ = NULL;
    std::string name_ = "";
};

class Item {
public:
    Item() {

    }

    BlockID GetBlock() const;

    RawTextureData GetTexture() const;

    bool CheckIsBlockItem() const;

    ItemProperties properties_;
    
private:

};

"./Level\\Item\\Items.cpp"
#include "Items.h"
#include "Type/BlockItem.h"
#include "../../Utils/LogUtils.h"
#include "../Chunk/Block/Block.h"

Item ItemList::RegisterBlockItem(BlockID block) {
    BlockItem item{ block };
    item.properties_.is_block_item_ = true;
    item.properties_.block_ = block;
    item.properties_.id_ = item_count_;
    item.properties_.name_ = g_blocks.GetBlockType(block)->block_name_;

    item_container_[item_count_] = item;
    block_item_ids_[block] = item_count_;

    item_count_++;
    
    g_logger.LogInfo("ItemList::RegisterBlockItem", "Registered Block Item: " + std::to_string(item_count_) + " | Name: " + item.properties_.name_);

    return item;
}

int ItemList::GetTotalItemCount() {
    return item_count_;
}

Item ItemList::GetItem(ItemID id) {
    return item_container_[id];
}

ItemID ItemList::GetBlockItem(BlockID block) {
    return block_item_ids_[block];
}

void ItemList::RegisterAll() {
    for (BlockID b = 0; b < g_blocks.block_type_data_.size(); b++) {
        if (block_item_ids_.count(b)) continue;

        RegisterBlockItem(b);
    }
}
"./Level\\Item\\Items.h"
#pragma once
#include "Item.h"
#include "../Chunk/Block/Blocks.h"


class ItemList{
private:

    Item RegisterBlockItem(BlockID block);

    int item_count_ = 0;
    
    FastHashMap<BlockID, ItemID> block_item_ids_;

public:
    FastHashMap<ItemID, Item> item_container_;

    Item AIR = RegisterBlockItem(g_blocks.AIR);
    Item STONE = RegisterBlockItem(g_blocks.STONE);
    Item DIRT = RegisterBlockItem(g_blocks.DIRT);
    Item WATER = RegisterBlockItem(g_blocks.WATER);
    Item LAVA = RegisterBlockItem(g_blocks.LAVA);
    Item GRASS = RegisterBlockItem(g_blocks.GRASS);
    Item SAND = RegisterBlockItem(g_blocks.SAND);
    Item OAK_LOG = RegisterBlockItem(g_blocks.OAK_LOG);
    Item STRIPPED_OAK_LOG = RegisterBlockItem(g_blocks.STRIPPED_OAK_LOG);
    Item OAK_LEAF = RegisterBlockItem(g_blocks.OAK_LEAF);
    Item OAK_PLANKS = RegisterBlockItem(g_blocks.OAK_PLANKS);
    Item BAMBOO_PLANKS = RegisterBlockItem(g_blocks.BAMBOO_PLANKS);
    Item ACACIA_PLANKS = RegisterBlockItem(g_blocks.ACACIA_PLANKS);
    Item BIRCH_PLANKS = RegisterBlockItem(g_blocks.BIRCH_PLANKS);
    Item CHERRY_PLANKS = RegisterBlockItem(g_blocks.CHERRY_PLANKS);
    Item CRIMSON_PLANKS = RegisterBlockItem(g_blocks.CRIMSON_PLANKS);
    Item DARK_OAK_PLANKS = RegisterBlockItem(g_blocks.DARK_OAK_PLANKS);
    Item JUNGLE_PLANKS = RegisterBlockItem(g_blocks.JUNGLE_PLANKS);
    Item MANGROVE_PLANKS = RegisterBlockItem(g_blocks.MANGROVE_PLANKS);
    Item SPRUCE_PLANKS = RegisterBlockItem(g_blocks.SPRUCE_PLANKS);
    Item WARPED_PLANKS = RegisterBlockItem(g_blocks.WARPED_PLANKS);
    Item OAK_WOOD = RegisterBlockItem(g_blocks.OAK_WOOD);
    Item ACACIA_WOOD = RegisterBlockItem(g_blocks.ACACIA_WOOD);
    Item BIRCH_WOOD = RegisterBlockItem(g_blocks.BIRCH_WOOD);
    Item CHERRY_WOOD = RegisterBlockItem(g_blocks.CHERRY_WOOD);
    Item DARK_OAK_WOOD = RegisterBlockItem(g_blocks.DARK_OAK_WOOD);
    Item JUNGLE_WOOD = RegisterBlockItem(g_blocks.JUNGLE_WOOD);
    Item MANGROVE_WOOD = RegisterBlockItem(g_blocks.MANGROVE_WOOD);
    Item SPRUCE_WOOD = RegisterBlockItem(g_blocks.SPRUCE_WOOD);
    Item STRIPPED_OAK_WOOD = RegisterBlockItem(g_blocks.STRIPPED_OAK_WOOD);
    Item STRIPPED_ACACIA_WOOD = RegisterBlockItem(g_blocks.STRIPPED_ACACIA_WOOD);
    Item STRIPPED_BIRCH_WOOD = RegisterBlockItem(g_blocks.STRIPPED_BIRCH_WOOD);
    Item STRIPPED_CHERRY_WOOD = RegisterBlockItem(g_blocks.STRIPPED_CHERRY_WOOD);
    Item STRIPPED_DARK_OAK_WOOD = RegisterBlockItem(g_blocks.STRIPPED_DARK_OAK_WOOD);
    Item STRIPPED_JUNGLE_WOOD = RegisterBlockItem(g_blocks.STRIPPED_JUNGLE_WOOD);
    Item STRIPPED_MANGROVE_WOOD = RegisterBlockItem(g_blocks.STRIPPED_MANGROVE_WOOD);
    Item STRIPPED_SPRUCE_WOOD = RegisterBlockItem(g_blocks.STRIPPED_SPRUCE_WOOD);
    Item BRICKS = RegisterBlockItem(g_blocks.BRICKS);
    Item STONE_BRICKS = RegisterBlockItem(g_blocks.STONE_BRICKS);
    Item CRACKED_STONE_BRICKS = RegisterBlockItem(g_blocks.CRACKED_STONE_BRICKS);
    Item CHISELED_STONE_BRICKS = RegisterBlockItem(g_blocks.CHISELED_STONE_BRICKS);
    Item MOSSY_STONE_BRICKS = RegisterBlockItem(g_blocks.MOSSY_STONE_BRICKS);
    Item DEEPSLATE_BRICKS = RegisterBlockItem(g_blocks.DEEPSLATE_BRICKS);
    Item CRACKED_DEEPSLATE_BRICKS = RegisterBlockItem(g_blocks.CRACKED_DEEPSLATE_BRICKS);
    Item TUFF_BRICKS = RegisterBlockItem(g_blocks.TUFF_BRICKS);
    Item CHISELED_TUFF_BRICKS = RegisterBlockItem(g_blocks.CHISELED_TUFF_BRICKS);
    Item MUD_BRICKS = RegisterBlockItem(g_blocks.MUD_BRICKS);
    Item PRISMARINE_BRICKS = RegisterBlockItem(g_blocks.PRISMARINE_BRICKS);
    Item NETHER_BRICKS = RegisterBlockItem(g_blocks.NETHER_BRICKS);
    Item CRACKED_NETHER_BRICKS = RegisterBlockItem(g_blocks.CRACKED_NETHER_BRICKS);
    Item CHISELED_NETHER_BRICKS = RegisterBlockItem(g_blocks.CHISELED_NETHER_BRICKS);
    Item RED_NETHER_BRICKS = RegisterBlockItem(g_blocks.RED_NETHER_BRICKS);
    Item POLISHED_BLACKSTONE_BRICK = RegisterBlockItem(g_blocks.POLISHED_BLACKSTONE_BRICK);
    Item CRACKED_POLISHED_BLACKSTONE_BRICK = RegisterBlockItem(g_blocks.CRACKED_POLISHED_BLACKSTONE_BRICK);
    Item END_STONE_BRICKS = RegisterBlockItem(g_blocks.END_STONE_BRICKS);
    Item COBBLESTONE = RegisterBlockItem(g_blocks.COBBLESTONE);
    Item BLUE_STAINED_GLASS = RegisterBlockItem(g_blocks.BLUE_STAINED_GLASS);
    Item GREEN_STAINED_GLASS = RegisterBlockItem(g_blocks.GREEN_STAINED_GLASS);
    Item BLACK_STAINED_GLASS = RegisterBlockItem(g_blocks.BLACK_STAINED_GLASS);
    Item BROWN_STAINED_GLASS = RegisterBlockItem(g_blocks.BROWN_STAINED_GLASS);
    Item CYAN_STAINED_GLASS = RegisterBlockItem(g_blocks.CYAN_STAINED_GLASS);
    Item GRAY_STAINED_GLASS = RegisterBlockItem(g_blocks.GRAY_STAINED_GLASS);
    Item LIGHT_BLUE_STAINED_GLASS = RegisterBlockItem(g_blocks.LIGHT_BLUE_STAINED_GLASS);
    Item LIGHT_GRAY_STAINED_GLASS = RegisterBlockItem(g_blocks.LIGHT_GRAY_STAINED_GLASS);
    Item LIME_STAINED_GLASS = RegisterBlockItem(g_blocks.LIME_STAINED_GLASS);
    Item MAGENTA_STAINED_GLASS = RegisterBlockItem(g_blocks.MAGENTA_STAINED_GLASS);
    Item AIORANGE_STAINED_GLASSR = RegisterBlockItem(g_blocks.ORANGE_STAINED_GLASS);
    Item PINK_STAINED_GLASS = RegisterBlockItem(g_blocks.PINK_STAINED_GLASS);
    Item PURPLE_STAINED_GLASS = RegisterBlockItem(g_blocks.PURPLE_STAINED_GLASS);
    Item RED_STAINED_GLASS = RegisterBlockItem(g_blocks.RED_STAINED_GLASS);
    Item WHITE_STAINED_GLASS = RegisterBlockItem(g_blocks.WHITE_STAINED_GLASS);
    Item YELLOW_STAINED_GLASS = RegisterBlockItem(g_blocks.YELLOW_STAINED_GLASS);
    Item WHITE_WOOL = RegisterBlockItem(g_blocks.WHITE_WOOL);
    Item BLACK_WOOL = RegisterBlockItem(g_blocks.BLACK_WOOL);
    Item BLUE_WOOL = RegisterBlockItem(g_blocks.BLUE_WOOL);
    Item BROWN_WOOL = RegisterBlockItem(g_blocks.BROWN_WOOL);
    Item CYAN_WOOL = RegisterBlockItem(g_blocks.CYAN_WOOL);
    Item GRAY_WOOL = RegisterBlockItem(g_blocks.GRAY_WOOL);
    Item GREEN_WOOL = RegisterBlockItem(g_blocks.GREEN_WOOL);
    Item LIGHT_BLUE_WOOL = RegisterBlockItem(g_blocks.LIGHT_BLUE_WOOL);
    Item LIGHT_GRAY_WOOL = RegisterBlockItem(g_blocks.LIGHT_GRAY_WOOL);
    Item LIME_WOOL = RegisterBlockItem(g_blocks.LIME_WOOL);
    Item MAGENTA_WOOL = RegisterBlockItem(g_blocks.MAGENTA_WOOL);
    Item ORANGE_WOOL = RegisterBlockItem(g_blocks.ORANGE_WOOL);
    Item PINK_WOOL = RegisterBlockItem(g_blocks.PINK_WOOL);
    Item PURPLE_WOOL = RegisterBlockItem(g_blocks.PURPLE_WOOL);
    Item RED_WOOL = RegisterBlockItem(g_blocks.RED_WOOL);
    Item YELLOW_WOOL = RegisterBlockItem(g_blocks.YELLOW_WOOL);
    Item WHITE_TERRACOTTA = RegisterBlockItem(g_blocks.WHITE_TERRACOTTA);
    Item BLACK_TERRACOTTA = RegisterBlockItem(g_blocks.BLACK_TERRACOTTA);
    Item BLUE_TERRACOTTA = RegisterBlockItem(g_blocks.BLUE_TERRACOTTA);
    Item BROWN_TERRACOTTA = RegisterBlockItem(g_blocks.BROWN_TERRACOTTA);
    Item CYAN_TERRACOTTA = RegisterBlockItem(g_blocks.CYAN_TERRACOTTA);
    Item GRAY_TERRACOTTA = RegisterBlockItem(g_blocks.GRAY_TERRACOTTA);
    Item GREEN_TERRACOTTA = RegisterBlockItem(g_blocks.GREEN_TERRACOTTA);
    Item LIGHT_BLUE_TERRACOTTA = RegisterBlockItem(g_blocks.LIGHT_BLUE_TERRACOTTA);
    Item LIGHT_GRAY_TERRACOTTA = RegisterBlockItem(g_blocks.LIGHT_GRAY_TERRACOTTA);
    Item LIME_TERRACOTTA = RegisterBlockItem(g_blocks.LIME_TERRACOTTA);
    Item MAGENTA_TERRACOTTA = RegisterBlockItem(g_blocks.MAGENTA_TERRACOTTA);
    Item ORANGE_TERRACOTTA = RegisterBlockItem(g_blocks.ORANGE_TERRACOTTA);
    Item PINK_TERRACOTTA = RegisterBlockItem(g_blocks.PINK_TERRACOTTA);
    Item PURPLE_TERRACOTTA = RegisterBlockItem(g_blocks.PURPLE_TERRACOTTA);
    Item RED_TERRACOTTA = RegisterBlockItem(g_blocks.RED_TERRACOTTA);
    Item YELLOW_TERRACOTTA = RegisterBlockItem(g_blocks.YELLOW_TERRACOTTA);
    Item WHITE_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.WHITE_GLAZED_TERRACOTTA);
    Item BLACK_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.BLACK_GLAZED_TERRACOTTA);
    Item BLUE_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.BLUE_GLAZED_TERRACOTTA);
    Item BROWN_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.BROWN_GLAZED_TERRACOTTA);
    Item CYAN_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.CYAN_GLAZED_TERRACOTTA);
    Item GRAY_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.GRAY_GLAZED_TERRACOTTA);
    Item GREEN_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.GREEN_GLAZED_TERRACOTTA);
    Item LIGHT_BLUE_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.LIGHT_BLUE_GLAZED_TERRACOTTA);
    Item LIGHT_GRAY_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.LIGHT_GRAY_GLAZED_TERRACOTTA);
    Item LIME_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.LIME_GLAZED_TERRACOTTA);
    Item MAGENTA_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.MAGENTA_GLAZED_TERRACOTTA);
    Item ORANGE_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.ORANGE_GLAZED_TERRACOTTA);
    Item PINK_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.PINK_GLAZED_TERRACOTTA);
    Item PURPLE_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.PURPLE_GLAZED_TERRACOTTA);
    Item RED_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.RED_GLAZED_TERRACOTTA);
    Item YELLOW_GLAZED_TERRACOTTA = RegisterBlockItem(g_blocks.YELLOW_GLAZED_TERRACOTTA);
    Item TERRACOTTA = RegisterBlockItem(g_blocks.TERRACOTTA);
    Item WHITE_CONCRETE = RegisterBlockItem(g_blocks.WHITE_CONCRETE);
    Item BLACK_CONCRETE = RegisterBlockItem(g_blocks.BLACK_CONCRETE);
    Item BLUE_CONCRETE = RegisterBlockItem(g_blocks.BLUE_CONCRETE);
    Item BROWN_CONCRETE = RegisterBlockItem(g_blocks.BROWN_CONCRETE);
    Item CYAN_CONCRETE = RegisterBlockItem(g_blocks.CYAN_CONCRETE);
    Item GRAY_CONCRETE = RegisterBlockItem(g_blocks.GRAY_CONCRETE);
    Item GREEN_CONCRETE = RegisterBlockItem(g_blocks.GREEN_CONCRETE);
    Item LIGHT_BLUE_CONCRETE = RegisterBlockItem(g_blocks.LIGHT_BLUE_CONCRETE);
    Item LIGHT_GRAY_CONCRETE = RegisterBlockItem(g_blocks.LIGHT_GRAY_CONCRETE);
    Item LIME_CONCRETE = RegisterBlockItem(g_blocks.LIME_CONCRETE);
    Item MAGENTA_CONCRETE = RegisterBlockItem(g_blocks.MAGENTA_CONCRETE);
    Item ORANGE_CONCRETE = RegisterBlockItem(g_blocks.ORANGE_CONCRETE);
    Item PINK_CONCRETE = RegisterBlockItem(g_blocks.PINK_CONCRETE);
    Item PURPLE_CONCRETE = RegisterBlockItem(g_blocks.PURPLE_CONCRETE);
    Item RED_CONCRETE = RegisterBlockItem(g_blocks.RED_CONCRETE);
    Item YELLOW_CONCRETE = RegisterBlockItem(g_blocks.YELLOW_CONCRETE);
    Item WHITE_CONCRETE_POWDER = RegisterBlockItem(g_blocks.WHITE_CONCRETE_POWDER);
    Item BLACK_CONCRETE_POWDER = RegisterBlockItem(g_blocks.BLACK_CONCRETE_POWDER);
    Item BLUE_CONCRETE_POWDER = RegisterBlockItem(g_blocks.BLUE_CONCRETE_POWDER);
    Item BROWN_CONCRETE_POWDER = RegisterBlockItem(g_blocks.BROWN_CONCRETE_POWDER);
    Item CYAN_CONCRETE_POWDER = RegisterBlockItem(g_blocks.CYAN_CONCRETE_POWDER);
    Item GRAY_CONCRETE_POWDER = RegisterBlockItem(g_blocks.GRAY_CONCRETE_POWDER);
    Item GREEN_CONCRETE_POWDER = RegisterBlockItem(g_blocks.GREEN_CONCRETE_POWDER);
    Item LIGHT_BLUE_CONCRETE_POWDER = RegisterBlockItem(g_blocks.LIGHT_BLUE_CONCRETE_POWDER);
    Item LIGHT_GRAY_CONCRETE_POWDER = RegisterBlockItem(g_blocks.LIGHT_GRAY_CONCRETE_POWDER);
    Item LIME_CONCRETE_POWDER = RegisterBlockItem(g_blocks.LIME_CONCRETE_POWDER);
    Item MAGENTA_CONCRETE_POWDER = RegisterBlockItem(g_blocks.MAGENTA_CONCRETE_POWDER);
    Item ORANGE_CONCRETE_POWDER = RegisterBlockItem(g_blocks.ORANGE_CONCRETE_POWDER);
    Item PINK_CONCRETE_POWDER = RegisterBlockItem(g_blocks.PINK_CONCRETE_POWDER);
    Item PURPLE_CONCRETE_POWDER = RegisterBlockItem(g_blocks.PURPLE_CONCRETE_POWDER);
    Item RED_CONCRETE_POWDER = RegisterBlockItem(g_blocks.RED_CONCRETE_POWDER);
    Item YELLOW_CONCRETE_POWDER = RegisterBlockItem(g_blocks.YELLOW_CONCRETE_POWDER);
    Item PODZOL = RegisterBlockItem(g_blocks.PODZOL);
    Item MYCELIUM = RegisterBlockItem(g_blocks.MYCELIUM);
    Item DIRT_PATH = RegisterBlockItem(g_blocks.DIRT_PATH);
    Item COARSE_DIRT = RegisterBlockItem(g_blocks.COARSE_DIRT);
    Item ROOTED_DIRT = RegisterBlockItem(g_blocks.ROOTED_DIRT);
    Item FARMLAND = RegisterBlockItem(g_blocks.FARMLAND);
    Item FARMLAND_MOIST = RegisterBlockItem(g_blocks.FARMLAND_MOIST);
    Item MUD = RegisterBlockItem(g_blocks.MUD);
    Item CLAY = RegisterBlockItem(g_blocks.CLAY);
    Item GRAVEL = RegisterBlockItem(g_blocks.GRAVEL);
    Item RED_SAND = RegisterBlockItem(g_blocks.RED_SAND);
    Item ICE = RegisterBlockItem(g_blocks.ICE);
    Item BLUE_ICE = RegisterBlockItem(g_blocks.BLUE_ICE);
    Item SNOW_BLOCK = RegisterBlockItem(g_blocks.SNOW_BLOCK);
    Item MOSS_BLOCK = RegisterBlockItem(g_blocks.MOSS_BLOCK);
    Item GRANITE = RegisterBlockItem(g_blocks.GRANITE);
    Item DIORITE = RegisterBlockItem(g_blocks.DIORITE);
    Item ANDESITE = RegisterBlockItem(g_blocks.ANDESITE);
    Item CALCITE = RegisterBlockItem(g_blocks.CALCITE);
    Item DRIPSTONE_BLOCK = RegisterBlockItem(g_blocks.DRIPSTONE_BLOCK);
    Item PRISMARINE = RegisterBlockItem(g_blocks.PRISMARINE);
    Item MAGMA = RegisterBlockItem(g_blocks.MAGMA); 
    Item OBSIDIAN = RegisterBlockItem(g_blocks.OBSIDIAN);
    Item CRYING_OBSIDIAN = RegisterBlockItem(g_blocks.CRYING_OBSIDIAN);
    Item NETHERRACK = RegisterBlockItem(g_blocks.NETHERRACK);
    Item CRIMSON_NYLIUM = RegisterBlockItem(g_blocks.CRIMSON_NYLIUM);
    Item WARPED_NYLIUM = RegisterBlockItem(g_blocks.WARPED_NYLIUM);
    Item SOUL_SAND = RegisterBlockItem(g_blocks.SOUL_SAND);
    Item SOUL_SOIL = RegisterBlockItem(g_blocks.SOUL_SOIL);
    Item BONE_BLOCK = RegisterBlockItem(g_blocks.BONE_BLOCK);
    Item BLACKSTONE = RegisterBlockItem(g_blocks.BLACKSTONE);
    Item BASALT = RegisterBlockItem(g_blocks.BASALT);
    Item SMOOTH_BASALT = RegisterBlockItem(g_blocks.SMOOTH_BASALT);
    Item END_STONE = RegisterBlockItem(g_blocks.END_STONE);
    Item COAL_ORE = RegisterBlockItem(g_blocks.COAL_ORE);
    Item DEEPSLATE_COAL_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_COAL_ORE);
    Item IRON_ORE = RegisterBlockItem(g_blocks.IRON_ORE);
    Item DEEPSLATE_IRON_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_IRON_ORE);
    Item COPPER_ORE = RegisterBlockItem(g_blocks.COPPER_ORE);
    Item DEEPSLATE_COPPER_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_COPPER_ORE);
    Item GOLD_ORE = RegisterBlockItem(g_blocks.GOLD_ORE);
    Item DEEPSLATE_GOLD_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_GOLD_ORE);
    Item REDSTONE_ORE = RegisterBlockItem(g_blocks.REDSTONE_ORE);
    Item DEEPSLATE_REDSTONE_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_REDSTONE_ORE);
    Item EMERALD_ORE = RegisterBlockItem(g_blocks.EMERALD_ORE);
    Item DEEPSLATE_EMERALD_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_EMERALD_ORE);
    Item LAPIS_ORE = RegisterBlockItem(g_blocks.LAPIS_ORE);
    Item DEEPSLATE_LAPIS_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_LAPIS_ORE);
    Item DIAMOND_ORE = RegisterBlockItem(g_blocks.DIAMOND_ORE);
    Item DEEPSLATE_DIAMOND_ORE = RegisterBlockItem(g_blocks.DEEPSLATE_DIAMOND_ORE);
    Item NETHER_GOLD_ORE = RegisterBlockItem(g_blocks.NETHER_GOLD_ORE);
    Item NETHER_QUARTZ_ORE = RegisterBlockItem(g_blocks.NETHER_QUARTZ_ORE);
    Item ANCIENT_DEBRIS = RegisterBlockItem(g_blocks.ANCIENT_DEBRIS);
    Item RAW_IRON_BLOCK = RegisterBlockItem(g_blocks.RAW_IRON_BLOCK);
    Item RAW_COPPER_BLOCK = RegisterBlockItem(g_blocks.RAW_COPPER_BLOCK);
    Item RAW_GOLD_BLOCK = RegisterBlockItem(g_blocks.RAW_GOLD_BLOCK);
    Item GLOWSTONE = RegisterBlockItem(g_blocks.GLOWSTONE);
    Item AMETHYST_BLOCK = RegisterBlockItem(g_blocks.AMETHYST_BLOCK);
    Item BUDDING_AMETHYST = RegisterBlockItem(g_blocks.BUDDING_AMETHYST);
    Item SPRUCE_LOG = RegisterBlockItem(g_blocks.SPRUCE_LOG);
    Item STRIPPED_SPRUCE_LOG = RegisterBlockItem(g_blocks.STRIPPED_SPRUCE_LOG);
    Item BIRCH_LOG = RegisterBlockItem(g_blocks.BIRCH_LOG);
    Item STRIPPED_BIRCH_LOG = RegisterBlockItem(g_blocks.STRIPPED_BIRCH_LOG);
    Item JUNGLE_LOG = RegisterBlockItem(g_blocks.JUNGLE_LOG);
    Item STRIPPED_JUNGLE_LOG = RegisterBlockItem(g_blocks.STRIPPED_JUNGLE_LOG);
    Item ACACIA_LOG = RegisterBlockItem(g_blocks.ACACIA_LOG);
    Item STRIPPED_ACACIA_LOG = RegisterBlockItem(g_blocks.STRIPPED_ACACIA_LOG);
    Item DARK_OAK_LOG = RegisterBlockItem(g_blocks.DARK_OAK_LOG);
    Item STRIPPED_DARK_OAK_LOG = RegisterBlockItem(g_blocks.STRIPPED_DARK_OAK_LOG);
    Item CHERRY_LOG = RegisterBlockItem(g_blocks.CHERRY_LOG);
    Item STRIPPED_CHERRY_LOG = RegisterBlockItem(g_blocks.STRIPPED_CHERRY_LOG);
    Item MANGROVE_LOG = RegisterBlockItem(g_blocks.MANGROVE_LOG);
    Item STRIPPED_MANGROVE_LOG = RegisterBlockItem(g_blocks.STRIPPED_MANGROVE_LOG);
    Item CRIMSON_STEM = RegisterBlockItem(g_blocks.CRIMSON_STEM);
    Item STRIPPED_CRIMSON_STEM = RegisterBlockItem(g_blocks.STRIPPED_CRIMSON_STEM);
    Item WARPED_STEM = RegisterBlockItem(g_blocks.WARPED_STEM);
    Item STRIPPED_WARPED_STEM = RegisterBlockItem(g_blocks.STRIPPED_WARPED_STEM);
    Item MANGROVE_ROOTS = RegisterBlockItem(g_blocks.MANGROVE_ROOTS);
    Item MUDDY_MANGROVE_ROOTS = RegisterBlockItem(g_blocks.MUDDY_MANGROVE_ROOTS);
    Item MUSHROOM_STEM = RegisterBlockItem(g_blocks.MUSHROOM_STEM);
    Item SPRUCE_LEAVES = RegisterBlockItem(g_blocks.SPRUCE_LEAVES);
    Item BIRCH_LEAVES = RegisterBlockItem(g_blocks.BIRCH_LEAVES);
    Item JUNGLE_LEAVES = RegisterBlockItem(g_blocks.JUNGLE_LEAVES);
    Item ACACIA_LEAVES = RegisterBlockItem(g_blocks.ACACIA_LEAVES);
    Item DARK_OAK_LEAVES = RegisterBlockItem(g_blocks.DARK_OAK_LEAVES);
    Item MANGROVE_LEAVES = RegisterBlockItem(g_blocks.MANGROVE_LEAVES);
    Item CHERRY_LEAVES = RegisterBlockItem(g_blocks.CHERRY_LEAVES);
    Item AZALEA_LEAVES = RegisterBlockItem(g_blocks.AZALEA_LEAVES);
    Item FLOWERING_AZALEA_LEAVES = RegisterBlockItem(g_blocks.FLOWERING_AZALEA_LEAVES);
    Item BROWN_MUSHROOM_BLOCK = RegisterBlockItem(g_blocks.BROWN_MUSHROOM_BLOCK);
    Item RED_MUSHROOM_BLOCK = RegisterBlockItem(g_blocks.RED_MUSHROOM_BLOCK);
    Item NETHER_WART_BLOCK = RegisterBlockItem(g_blocks.NETHER_WART_BLOCK);
    Item WARPED_WART_BLOCK = RegisterBlockItem(g_blocks.WARPED_WART_BLOCK);
    Item SHROOMLIGHT = RegisterBlockItem(g_blocks.SHROOMLIGHT);
    Item DRIED_KELP_BLOCK = RegisterBlockItem(g_blocks.DRIED_KELP_BLOCK);
    Item TUBE_CORAL_BLOCK = RegisterBlockItem(g_blocks.TUBE_CORAL_BLOCK);
    Item BRAIN_CORAL_BLOCK = RegisterBlockItem(g_blocks.BRAIN_CORAL_BLOCK);
    Item BUBBLE_CORAL_BLOCK = RegisterBlockItem(g_blocks.BUBBLE_CORAL_BLOCK);
    Item FIRE_CORAL_BLOCK = RegisterBlockItem(g_blocks.FIRE_CORAL_BLOCK);
    Item HORN_CORAL_BLOCK = RegisterBlockItem(g_blocks.HORN_CORAL_BLOCK);
    Item DEAD_TUBE_CORAL_BLOCK = RegisterBlockItem(g_blocks.DEAD_TUBE_CORAL_BLOCK);
    Item DEAD_BRAIN_CORAL_BLOCK = RegisterBlockItem(g_blocks.DEAD_BRAIN_CORAL_BLOCK);
    Item DEAD_BUBBLE_CORAL_BLOCK = RegisterBlockItem(g_blocks.DEAD_BUBBLE_CORAL_BLOCK);
    Item DEAD_FIRE_CORAL_BLOCK = RegisterBlockItem(g_blocks.DEAD_FIRE_CORAL_BLOCK);
    Item DEAD_HORN_CORAL_BLOCK = RegisterBlockItem(g_blocks.DEAD_HORN_CORAL_BLOCK);
    Item SPONGE = RegisterBlockItem(g_blocks.SPONGE);
    Item WET_SPONGE = RegisterBlockItem(g_blocks.WET_SPONGE);
    Item MELON = RegisterBlockItem(g_blocks.MELON);
    Item PUMPKIN = RegisterBlockItem(g_blocks.PUMPKIN);
    Item CARVED_PUMPKIN = RegisterBlockItem(g_blocks.CARVED_PUMPKIN);
    Item JACK_O_LANTERN = RegisterBlockItem(g_blocks.JACK_O_LANTERN);
    Item HAY_BALE = RegisterBlockItem(g_blocks.HAY_BALE);
    Item BEE_NEST = RegisterBlockItem(g_blocks.BEE_NEST);
    Item HONEYCOMB_BLOCK = RegisterBlockItem(g_blocks.HONEYCOMB_BLOCK);
    Item OCHRE_FROGLIGHT = RegisterBlockItem(g_blocks.OCHRE_FROGLIGHT);
    Item VERDANT_FROGLIGHT = RegisterBlockItem(g_blocks.VERDANT_FROGLIGHT);
    Item PEARLESCENT_FROGLIGHT = RegisterBlockItem(g_blocks.PEARLESCENT_FROGLIGHT);
    Item SCULK = RegisterBlockItem(g_blocks.SCULK);
    Item SCULK_CATALYST = RegisterBlockItem(g_blocks.SCULK_CATALYST);
    Item BEDROCK = RegisterBlockItem(g_blocks.BEDROCK);
    Item SEA_LANTERN = RegisterBlockItem(g_blocks.SEA_LANTERN);
    Item REDSTONE_LAMP = RegisterBlockItem(g_blocks.REDSTONE_LAMP);
    Item COPPER_BULB = RegisterBlockItem(g_blocks.COPPER_BULB);
    Item EXPOSED_COPPER_BULB = RegisterBlockItem(g_blocks.EXPOSED_COPPER_BULB);
    Item OXIDIZED_COPPER_BULB = RegisterBlockItem(g_blocks.OXIDIZED_COPPER_BULB);
    Item WEATHERED_COPPER_BULB = RegisterBlockItem(g_blocks.WEATHERED_COPPER_BULB);
    Item CRAFTING_TABLE = RegisterBlockItem(g_blocks.CRAFTING_TABLE);
    Item COPPER_GRATE = RegisterBlockItem(g_blocks.COPPER_GRATE);
    Item EXPOSED_COPPER_GRATE = RegisterBlockItem(g_blocks.EXPOSED_COPPER_GRATE);
    Item OXIDIZED_COPPER_GRATE = RegisterBlockItem(g_blocks.OXIDIZED_COPPER_GRATE);
    Item WEATHERED_COPPER_GRATE = RegisterBlockItem(g_blocks.WEATHERED_COPPER_GRATE);
    Item CUT_COPPER = RegisterBlockItem(g_blocks.CUT_COPPER);
    Item EXPOSED_CUT_COPPER = RegisterBlockItem(g_blocks.EXPOSED_CUT_COPPER);
    Item OXIDIZED_CUT_COPPER = RegisterBlockItem(g_blocks.OXIDIZED_CUT_COPPER);
    Item WEATHERED_CUT_COPPER = RegisterBlockItem(g_blocks.WEATHERED_CUT_COPPER);
    Item CHISELED_COPPER = RegisterBlockItem(g_blocks.CHISELED_COPPER);
    Item EXPOSED_CHISELED_COPPER = RegisterBlockItem(g_blocks.EXPOSED_CHISELED_COPPER);
    Item OXIDIZED_CHISELED_COPPER = RegisterBlockItem(g_blocks.OXIDIZED_CHISELED_COPPER);
    Item WEATHERED_CHISELED_COPPER = RegisterBlockItem(g_blocks.WEATHERED_CHISELED_COPPER);
    Item WARPED_HYPHAE = RegisterBlockItem(g_blocks.WARPED_HYPHAE);
    Item STRIPPED_WARPED_HYPHAE = RegisterBlockItem(g_blocks.STRIPPED_WARPED_HYPHAE);
    Item CRIMSON_HYPHAE = RegisterBlockItem(g_blocks.CRIMSON_HYPHAE);
    Item STRIPPED_CRIMSON_HYPHAE = RegisterBlockItem(g_blocks.STRIPPED_CRIMSON_HYPHAE);
    Item MOSSY_COBBLESTONE = RegisterBlockItem(g_blocks.MOSSY_COBBLESTONE);
    Item DEEPSLATE = RegisterBlockItem(g_blocks.DEEPSLATE);
    Item COBBLED_DEEPSLATE = RegisterBlockItem(g_blocks.COBBLED_DEEPSLATE);
    Item CHISELED_DEEPSLATE = RegisterBlockItem(g_blocks.CHISELED_DEEPSLATE);
    Item POLISHED_DEEPSLATE = RegisterBlockItem(g_blocks.POLISHED_DEEPSLATE);
    Item DEEPSLATE_TILES = RegisterBlockItem(g_blocks.DEEPSLATE_TILES);
    Item CRACKED_DEEPSLATE_TILES = RegisterBlockItem(g_blocks.CRACKED_DEEPSLATE_TILES);
    Item REINFORCED_DEEPSLATE = RegisterBlockItem(g_blocks.REINFORCED_DEEPSLATE);
    Item TUFF = RegisterBlockItem(g_blocks.TUFF);
    Item CHISELED_TUFF = RegisterBlockItem(g_blocks.CHISELED_TUFF);
    Item POLISHED_TUFF = RegisterBlockItem(g_blocks.POLISHED_TUFF);
    Item PACKED_MUD = RegisterBlockItem(g_blocks.PACKED_MUD);
    Item SANDSTONE = RegisterBlockItem(g_blocks.SANDSTONE);
    Item CHISELED_SANDSTONE = RegisterBlockItem(g_blocks.CHISELED_SANDSTONE);
    Item SMOOTH_SANDSTONE = RegisterBlockItem(g_blocks.SMOOTH_SANDSTONE);
    Item CUT_SANDSTONE = RegisterBlockItem(g_blocks.CUT_SANDSTONE);
    Item RED_SANDSTONE = RegisterBlockItem(g_blocks.RED_SANDSTONE);
    Item CHISELED_RED_SANDSTONE = RegisterBlockItem(g_blocks.CHISELED_RED_SANDSTONE);
    Item SMOOTH_RED_SANDSTONE = RegisterBlockItem(g_blocks.SMOOTH_RED_SANDSTONE);
    Item CUT_RED_SANDSTONE = RegisterBlockItem(g_blocks.CUT_RED_SANDSTONE);
    Item DARK_PRISMARINE = RegisterBlockItem(g_blocks.DARK_PRISMARINE);
    Item PURPUR_BLOCK = RegisterBlockItem(g_blocks.PURPUR_BLOCK);
    Item PURPUR_PILLAR = RegisterBlockItem(g_blocks.PURPUR_PILLAR);
    Item COAL_BLOCK = RegisterBlockItem(g_blocks.COAL_BLOCK);
    Item IRON_BLOCK = RegisterBlockItem(g_blocks.IRON_BLOCK);
    Item GOLD_BLOCK = RegisterBlockItem(g_blocks.GOLD_BLOCK);
    Item REDSTONE_BLOCK = RegisterBlockItem(g_blocks.REDSTONE_BLOCK);
    Item EMERALD_BLOCK = RegisterBlockItem(g_blocks.EMERALD_BLOCK);
    Item LAPIS_BLOCK = RegisterBlockItem(g_blocks.LAPIS_BLOCK);
    Item DIAMOND_BLOCK = RegisterBlockItem(g_blocks.DIAMOND_BLOCK);
    Item NETHERITE_BLOCK = RegisterBlockItem(g_blocks.NETHERITE_BLOCK);
    Item QUARTZ_BLOCK = RegisterBlockItem(g_blocks.QUARTZ_BLOCK);
    Item CHISELED_QUARTZ_BLOCK = RegisterBlockItem(g_blocks.CHISELED_QUARTZ_BLOCK);
    Item QUARTZ_PILLAR = RegisterBlockItem(g_blocks.QUARTZ_PILLAR);
    Item SMOOTH_QUARTZ = RegisterBlockItem(g_blocks.SMOOTH_QUARTZ);

    Item ANVIL = RegisterBlockItem(g_blocks.ANVIL);
    Item GetItem(ItemID id);

    ItemID GetBlockItem(BlockID block);

    int GetTotalItemCount();

    void RegisterAll();
};

extern ItemList g_items;
"./Level\\Item\\ItemStack.cpp"
#include "ItemStack.h"

bool ItemStack::IsInitialized() {
    return initialized_;
}
"./Level\\Item\\ItemStack.h"
#pragma once

#include "Item.h"

class ItemStack { //Contains additional properties of item such as item count enchantments, etc
public:
    ItemStack() {

    }

    ItemStack(Item item) {
        item_ = item;
        initialized_ = true;
    }

    bool IsInitialized();

    Item item_;
    int item_count_ = 1;
private:
    bool initialized_ = false;

};
"./Level\\Item\\ItemTextureAtlas.cpp"
#include "ItemTextureAtlas.h"

void ItemTextureAtlas::RenderBlockItem(Item item) {
    framebuffer_single_block_render_.BindFBO();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    block_item_renderer_.RenderBlock(item);
    framebuffer_single_block_render_.UnbindFBO();
}

void ItemTextureAtlas::StitchTexture(size_t index, ItemID ItemID) {
    int ratio = atlas_size_ / individual_size_;
    float xCoord = static_cast<float>((index % ratio));
    float yCoord = floor((float)index / (float)ratio);

    //Normalize

    xCoord = xCoord / (float)(ratio);
    yCoord = yCoord / (float)(ratio);

    float Size = 2 / (float)(ratio);

    //Map to NDC

    xCoord = -(xCoord * 2.f - 1.f);
    yCoord = -(yCoord * 2.f - 1.f);

    //Insert Data
    float vertices[] = {
        xCoord - 0.f    ,yCoord - 0.f,    0.f, 1.f,
        xCoord - Size    ,yCoord - 0.f,    1.f, 1.f,
        xCoord - Size    ,yCoord - Size,    1.f, 0.f,
        xCoord - 0.f    ,yCoord - Size,    0.f, 0.f,
    };

    uint32_t indices[] = {
        0, 1, 2,
        2, 3, 0
    };

    ItemUVMapping uvMap;
    uvMap.uv_1_ = glm::vec2((xCoord + 1.f) * 0.5f, (yCoord + 1.f) * 0.5f);
    uvMap.uv_2_ = glm::vec2((xCoord - Size + 1.f) * 0.5f, (yCoord - Size + 1.f) * 0.5f);

    uvMap.uv_1_.y = 1.f - uvMap.uv_1_.y;
    uvMap.uv_2_.y = 1.f - uvMap.uv_2_.y;

    items_uv_map_[ItemID] = uvMap;

    vbo_.InsertData(sizeof(vertices), vertices, GL_STATIC_DRAW);
    ebo_.InsertData(sizeof(indices), indices, GL_STATIC_DRAW);
    //Render
    atlas_framebuffer_.BindFBO();
    stitching_shader_.BindTexture2D(0, framebuffer_single_block_render_.texture_, "ItemTexture");

    glEnable(GL_BLEND);

    vao_.Bind();
    ebo_.Bind();
    glDrawElements(GL_TRIANGLES, sizeof(indices) / sizeof(uint32_t), GL_UNSIGNED_INT, 0);
    vao_.Unbind();
    ebo_.Unbind();

    glDisable(GL_BLEND);
    atlas_framebuffer_.UnbindFBO();
}

void ItemTextureAtlas::Initialize(int atlasItemSize, int individualItemSize) {
    stitching_shader_.Init("assets/shaders/ItemRender/AtlasStitchVert.glsl", "assets/shaders/ItemRender/AtlasStitchFrag.glsl");

    individual_size_ = individualItemSize;
    atlas_size_ = atlasItemSize;

    atlas_framebuffer_.GenBuffer(atlas_size_, atlas_size_, 1, GL_RGBA);
    framebuffer_single_block_render_.GenBuffer(individual_size_, individual_size_, 2, GL_RGBA);

    atlas_.width_ = atlas_size_;
    atlas_.height_ = atlas_size_;
    atlas_.texture_id_ = atlas_framebuffer_.texture_;

    individual_item_.width_ = individual_size_;
    individual_item_.height_ = individual_size_;
    individual_item_.texture_id_ = framebuffer_single_block_render_.texture_;

    vbo_.SetType(GL_ARRAY_BUFFER);
    ebo_.SetType(GL_ELEMENT_ARRAY_BUFFER);

    vbo_.SetUsage(GL_STATIC_DRAW);
    ebo_.SetUsage(GL_STATIC_DRAW);

    vao_.GenArray();
    vbo_.GenBuffer();
    ebo_.GenBuffer();

    vao_.Bind();
    vbo_.Bind();
    vao_.EnableAttriPTR(0, 2, GL_FLOAT, GL_FALSE, 4, 0);
    vao_.EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 4, 2);
    vao_.Unbind();
    vbo_.Unbind();

    block_item_renderer_.Initialize();
}

void ItemTextureAtlas::AddItem(Item item) {
    offsets_[item.properties_.id_] = offsets_.size();
    RenderBlockItem(item);
    StitchTexture(offsets_.size() - 1, item.properties_.id_);
}
"./Level\\Item\\ItemTextureAtlas.h"
#pragma once
#include "../../RenderEngine/OpenGL//Texture/Types/Texture2D.h"
#include "Item.h"
#include <unordered_map>
#include "../../RenderEngine/OpenGL/Framebuffer/Framebuffer.h"
#include "../../RenderEngine/ItemRender/BlockItemRender.h"
#include "../../RenderEngine/OpenGL/Buffers/Buffer.h"
#include "../../RenderEngine/OpenGL/Shader/Shader.h"

#include <glm/vec2.hpp>

struct ItemUVMapping {
    glm::vec2 uv_1_;
    glm::vec2 uv_2_;
};

class ItemTextureAtlas {
    Texture2D individual_item_;

    VertexArray vao_;
    Buffer ebo_;
    Buffer vbo_;

    BlockItemRender block_item_renderer_;
    Shader stitching_shader_;
    int individual_size_ = 0;
    int atlas_size_ = 0;
    TexturedFrameBuffer atlas_framebuffer_;
    TexturedFrameBuffer framebuffer_single_block_render_;

    void RenderBlockItem(Item item);

    void StitchTexture(size_t index, ItemID ItemID);

    
public:
    FastHashMap<int, ItemUVMapping> items_uv_map_;
    
    Texture2D atlas_;

    FastHashMap<ItemID, size_t> offsets_;
    
    void Initialize(int atlasItemSize, int individualItemSize);

    void AddItem(Item item);
};

extern ItemTextureAtlas g_item_atlas;
"./Level\\Item\\Type\\BlockItem.h"
#pragma once

#include "../../Chunk/Block/Blocks.h"
#include "../Item.h"

class BlockItem : public Item {
public:
    BlockItem(BlockID block_) {
        properties_.block_ = block_;
        properties_.is_block_item_ = true;
    }

private:


};
"./Level\\Level.cpp"
#include "Level.h"
#include "LevelLoader.h"
#include "Dimension/Dimensions/Overworld.h"
#include "World/WorldInteraction/WorldLoader.h"

Level::Level() = default;

void Level::Start(int worldGenThreadCount, int light_engine_thread_count_) {
    DimensionProperties properties;
    main_world_ = std::make_unique<OverworldDimension>();
    main_world_->Initialize(properties);
    
    long long Seed = -501575345763903LL;//-501575345763903LL;//-1587754402LL
    level_loader_ = std::make_unique<LevelLoader>();
    level_loader_->Start(worldGenThreadCount, light_engine_thread_count_, main_world_->world_interactions_.worldLoader_->GetWorld(), Seed);
}

void Level::Stop() {
    level_loader_->Stop();
}

void Level::updateDimensions() {
    //Generated Chunks
    level_loader_->SendRequestedChunks(main_world_->world_interactions_.worldLoader_->GetRequestedChunks(), main_world_->GetGeneratorType());
    std::vector<std::unique_ptr<Chunk>> chunks = level_loader_->GetGeneratedChunk();
    main_world_->world_interactions_.AddChunks(std::move(chunks));

    //Updated Light Info
    level_loader_->SendRequestedLightUpdates(std::move(main_world_->world_interactions_.GetRequestedLightUpdates()));
    std::vector<std::unique_ptr<ChunkLightingContainer>> lighting = level_loader_->GetLightingInfomation();
    main_world_->world_interactions_.UpdateLighting(std::move(lighting));
}
"./Level\\Level.h"
#pragma once
#include <memory>

class Dimension;
class LevelLoader;

class Level {
public:
    std::unique_ptr<Dimension> main_world_;
    std::unique_ptr<LevelLoader> level_loader_;

    Level();

    void Start(int worldGenThreadCount, int light_engine_thread_count_);

    void Stop();

    void updateDimensions();
};
"./Level\\LevelLoader.cpp"
#include "LevelLoader.h"
#include "TerrainGeneration/Generator.h"
#include "Lighting/LightEngine.h"
#include "TerrainGeneration/Biome/Biomes.h"
#include "TerrainGeneration/Biome/BiomeProvider.h"

LevelLoader::LevelLoader() : 
    world_generator_{ std::make_unique<ChunkGeneration>() },
    light_engine_{ std::make_unique<LightingEngine>() } {

}
LevelLoader::~LevelLoader() = default;

void LevelLoader::Start(int worldGenThreadCount, int light_engine_thread_count_, WorldAccess* world, long long worldGenSeedIn) {
    Biomes::RegisterBiome();
    BiomeProvider::init(worldGenSeedIn, new ChunkGeneratorSettings);
    world_generator_->Start(worldGenThreadCount, worldGenSeedIn);
    light_engine_->Start(light_engine_thread_count_, world);
}

void LevelLoader::Stop() {
    world_generator_->Stop();
}

size_t LevelLoader::GetChunkCount() {
    return count;
}

void LevelLoader::SendRequestedChunks(std::vector<ChunkPos> requestedChunks, WorldGeneratorID worldGenTypeIn) { //Add option for requested chunks dimension type and generator type later
    //Later this will check on the disk for chunks
    world_generator_->Generate(std::move(requestedChunks), worldGenTypeIn);
}

std::vector<std::unique_ptr<Chunk>> LevelLoader::GetGeneratedChunk() {
    std::vector<std::unique_ptr<Chunk>> out = world_generator_->GetOutput();
    count += out.size();
    return out;
}

void LevelLoader::SendRequestedLightUpdates(std::vector<ChunkColumnPos> requestedLight) {
    //Later this will check on the disk for baked light info
    light_engine_->Generate(std::move(requestedLight));
}

std::vector<std::unique_ptr<ChunkLightingContainer>> LevelLoader::GetLightingInfomation() {
    return light_engine_->GetOutput();
}

size_t LevelLoader::GetLightEngineQueueSize() {
    return light_engine_->GetQueueSize();
}
"./Level\\LevelLoader.h"
#pragma once
#include <memory>

#include "Typenames.h"

class ChunkGeneration;
class LightingEngine;
class ChunkLightingContainer;
class Chunk;

struct WorldAccess;

//Checks if the chunk is stored on disk, if not, asks the world generator to generate the chunks
class LevelLoader { //need to add save to disk later
private:
    size_t count = 0; // TODO: Rename
    std::unique_ptr<ChunkGeneration> world_generator_; //Change this 
    std::unique_ptr<LightingEngine> light_engine_;
public:
    LevelLoader();
    ~LevelLoader();

    void Start(int worldGenThreadCount, int light_engine_thread_count_, WorldAccess* world, long long worldGenSeedIn);

    void Stop();

    size_t GetChunkCount(); // TODO: Rename

    void SendRequestedChunks(std::vector<ChunkPos> requestedChunks, WorldGeneratorID worldGenTypeIn);

    std::vector<std::unique_ptr<Chunk>> GetGeneratedChunk();

    void SendRequestedLightUpdates(std::vector<ChunkColumnPos> requestedLight);

    std::vector<std::unique_ptr<ChunkLightingContainer>> GetLightingInfomation();

    size_t GetLightEngineQueueSize();
};
"./Level\\Lighting\\LightEngine.cpp"
#include "LightEngine.h"
#include "../../Utils/Containers/FIFOQueue.h"
#include "../Chunk/Chunk.h"
#include "../Chunk/ChunkColumn.h"
#include "../Chunk/Heightmap/Heightmap.h"
#include "../Chunk/Lighting/ChunkLighting.h"
#include "../World/WorldDataAccess.h"


static thread_local FixedFIFOQueue<uint16_t> FIFOQueues;

constexpr int8_t DIRECTION_OFFSETS[6][3] = {
    {-1, 0, 0}, {1, 0, 0},  // X: Left, Right
    {0, -1, 0}, {0, 1, 0},  // Y: Down, Up
    {0, 0, -1}, {0, 0, 1}   // Z: Back, Front
};

// Pack light node data into uint16_t
inline uint16_t PackLightNode(uint8_t x, uint8_t y, uint8_t z, uint8_t light) {
    return x | (y << 4) | (z << 8) | (light << 12);
}

// Unpack light node data
inline void UnpackLightNode(uint16_t node, uint8_t& x, uint8_t& y, uint8_t& z, uint8_t& light) {
    x = node & 0xF;
    y = (node >> 4) & 0xF;
    z = (node >> 8) & 0xF;
    light = (node >> 12) & 0xF;
}

void LightingEngine::IncreaseLightLevel(std::unique_ptr<ChunkLightingContainer>& container, uint8_t lvl, int x, int y, int z) {
    uint8_t curr = container->GetLighting(x, y, z);
    if (curr < lvl)
        container->EditLight(x, y, z, lvl);
}

void LightingEngine::LightSpreadSky(Chunk* chunk, std::unique_ptr<ChunkLightingContainer>& container, const Heightmap& heightmap, int ChunkHeight, int x, int y, int z) {
    FIFOQueues.resetData();
    FIFOQueues.push(PackLightNode(x, y, z, 15));

    if (container->GetLighting(x, y, z) >= 15)
        return;

    int i = 0;

    while (!FIFOQueues.IsEmpty()) {
        //Get node
        uint16_t node = FIFOQueues.get();
        uint8_t nodeX, nodeY, nodeZ, nodeLight;

        UnpackLightNode(node, nodeX, nodeY, nodeZ, nodeLight);

        i++;
        int currNX = nodeX;
        int currNY = nodeY + ChunkHeight;
        int currNZ = nodeZ;

        if (heightmap.Get(currNX, currNZ) <= currNY) {
            nodeLight = 15;
        }

        if (container->GetLighting(nodeX, nodeY, nodeZ) >= nodeLight) {
            continue;
        }
        //Set node light level
        IncreaseLightLevel(container, nodeLight, nodeX, nodeY, nodeZ);

        if (chunk->GetBlockUnsafe(nodeX, nodeY, nodeZ) != g_blocks.AIR) {
            continue;
        }

        if (nodeLight == 0) continue;

        //Spread
        for (int side = 0; side < 6; side++) {

            int direction = side >> 1;
            int face = side & 0b1; //1 = Front 0 = Back

            if ((direction == 1) && (face == 1))
                continue; //skip Up direction

            uint8_t nx = nodeX + DIRECTION_OFFSETS[side][0];
            uint8_t ny = nodeY + DIRECTION_OFFSETS[side][1];
            uint8_t nz = nodeZ + DIRECTION_OFFSETS[side][2];

            int8_t newLight = nodeLight - 1;

            //Check if it is in the chunk first
            if (((nx | ny | nz) >> 4))
                continue;

            //Check if the light level is more or less
            int currLvl = container->GetLighting(nx, ny, nz);

            if (currLvl + 2 > newLight)
                continue;

            FIFOQueues.push(PackLightNode(nx, ny, nz, newLight));

        }
    }
}

void LightingEngine::WorkOnChunkSkylight(Chunk* chunk, std::unique_ptr<ChunkLightingContainer>& light, const Heightmap& heightmap, int chunkHeight) {
    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {
            int h = heightmap.Get(x, z) - chunkHeight; // it will try to find pivot points

            if (h >= 16)
                continue;

            LightSpreadSky(chunk, light, heightmap, chunkHeight, x, 15, z);
        }
    }
}

std::vector<std::unique_ptr<ChunkLightingContainer>> LightingEngine::Worker(const ChunkPos& pos) {
    if (!FIFOQueues.IsInitialized())
        FIFOQueues.setSize(LightingEngine::DEFAULT_FIFO_QUEUE_SIZE);

    std::vector<std::unique_ptr<ChunkLightingContainer>> out;
    ChunkColumn* col = LightingEngine::world_->GetColumn(pos);

    if (col == nullptr) return out;

    const Heightmap& heightmap = world_->GetColumnHeightmap(pos);

    int relativeChunkHeight = pos.y & 0b11111;
    int columnYLevel = pos.y - relativeChunkHeight;

    for (int i = 0; i <= relativeChunkHeight; i++) {
        if (!col->light_dirty_[i])
            continue;
        if (col->GetChunk(i) == nullptr)
            continue;


        std::unique_ptr<ChunkLightingContainer> lighting = std::make_unique<ChunkLightingContainer>();
        lighting->ResetLightingCustom(4);
        lighting->position_.set(pos.x, columnYLevel + i, pos.z);

        WorkOnChunkSkylight(col->GetChunk(i), lighting, heightmap, i * 16);

        out.push_back(std::move(lighting));
    }

    return out;
}

void LightingEngine::Generate(std::vector<ChunkPos> tasks) {
    lighting_thread_pool_->SubmitTask(tasks);
}

std::vector<std::unique_ptr<ChunkLightingContainer>> LightingEngine::GetOutput() {
    std::vector<std::unique_ptr<ChunkLightingContainer>> out;
    for (auto& lights : lighting_thread_pool_->GetOutput()) {
        out.insert(out.end(),
            std::make_move_iterator(lights.begin()),
            std::make_move_iterator(lights.end()));
    }
    return out;
}

void LightingEngine::Stop() {
    lighting_thread_pool_->Stop();
}

void LightingEngine::Start(int lightEngineThreadsCount, WorldAccess* w) {
    lighting_thread_pool_ = std::make_unique<ThreadPool<ChunkPos,
        std::vector<std::unique_ptr<ChunkLightingContainer>>,
        LightingEngine::Worker>>(lightEngineThreadsCount, "Light Engine", 100);

    LightingEngine::world_ = w;
}

void LightingEngine::QueueChunk(const ChunkPos& pos) {
    lighting_thread_pool_->SubmitTask(pos);
}

size_t LightingEngine::GetQueueSize() {
    return lighting_thread_pool_->GetQueueSize();
}
"./Level\\Lighting\\LightEngine.h"
#pragma once
#include <memory>

#include "../../Utils/ThreadPool.h"
#include "../Typenames.h"

class ChunkLightingContainer;
class Heightmap;
class Chunk;

struct WorldAccess;



class LightingEngine {
public:
    void Generate(std::vector<ChunkPos> IDs);

    std::vector<std::unique_ptr<ChunkLightingContainer>> GetOutput();

    void Stop();

    void Start(int lightEngineThreadsCount, WorldAccess* w);

    void QueueChunk(const ChunkPos& pos);

    void Scheduler();

    size_t GetQueueSize();

private:
    static std::vector<std::unique_ptr<ChunkLightingContainer>> Worker(const ChunkPos& pos);

    std::unique_ptr<ThreadPool<ChunkPos, std::vector<std::unique_ptr<ChunkLightingContainer>>, LightingEngine::Worker>> lighting_thread_pool_;
    static WorldAccess* world_;

    static void IncreaseLightLevel(std::unique_ptr<ChunkLightingContainer>& container, uint8_t lvl, int x, int y, int z);

    static void LightSpreadSky(Chunk* chunk, std::unique_ptr<ChunkLightingContainer>& container, const Heightmap& heightmap, int chunkHeight, int x, int y, int z);

    static void WorkOnChunkSkylight(Chunk* chunk, std::unique_ptr<ChunkLightingContainer>& light, const Heightmap& heightmap, int chunkHeight);

    static std::vector<std::unique_ptr<ChunkLightingContainer>> SkyLighting(const ChunkPos& id);
    const static size_t DEFAULT_FIFO_QUEUE_SIZE = 32768;
};

inline WorldAccess* LightingEngine::world_ = nullptr;
"./Level\\Server\\Communication\\InternalServer.cpp"
#include "InternalServer.h"
#include "../Server.h"
#include "../../Chunk/ChunkPos/ChunkPos.h"
#include "../../Entity/Mobs/Player.h"
#include "../../Entity/Properties/EntityProperties.h"
#include "../../Event/Event.h"
#include "../../../Core/Options/Option.h"

void InternalServer::startInternalServer(Player* p) {
    server = new Server();
    player = p;

    ServerSettings settings_;
    settings_.gen_thread_count_ = g_app_options.world_gen_threads_;
    settings_.light_engine_thread_count_ = g_app_options.light_engine_threads_;
    settings_.horizontal_ticking_distance_ = g_app_options.horizontal_render_distance_;
    settings_.vertical_ticking_distance_ = g_app_options.vertical_render_distance_;

    server->StartServer(settings_);
    server->Join(*p);
}

void InternalServer::Stop() {
    server->Stop();
}

glm::vec3 InternalServer::GetPlayerCollusionTimes() {
    return server->GetEntityCollusionTime(player->properties_.entity_uuid_);
}

Chunk* InternalServer::GetChunk(const ChunkPos& chunk) {
    return server->GetChunk(chunk);
}

Timer* InternalServer::GetTickClock() {
    return server->GetTimer();
}

double InternalServer::GetMSPT() {
    return server->GetMSPT();
}

void InternalServer::SetPlayer(Player player) {
    server->Join(player);
}

bool InternalServer::CheckPlayerOnGround() {
    return server->CheckEntityOnGround(player->properties_.entity_uuid_);
}

size_t InternalServer::GetChunkCount() {
    return server->GetChunkCount();
}

std::vector<ChunkPos> InternalServer::GetUpdatedChunks() {
    return server->GetUpdatedChunkPos();
}

std::vector<EntityProperty> InternalServer::GetUpdatedEntities() {
    return server->GetUpdatedEntities();
}

std::vector<EntityUUID> InternalServer::GetRemovedEntities() {
    return server->GetRemovedEntities();
}

bool InternalServer::CheckRayIntersection(Ray& ray) {
    return server->GetRayIntersection(ray);
}

BlockID InternalServer::GetBlock(const BlockPos& pos) {
    return server->GetBlock(pos);
}

void InternalServer::SendEvent(Event::Event eventIn) {
    server->SendEvent(eventIn);
}
"./Level\\Server\\Communication\\InternalServer.h"
#pragma once
#include <vector>
#include <glm/vec3.hpp>

#include "../../Typenames.h"

class Player;
class Timer;
class Chunk;
class Server;

struct Ray;
struct EntityProperty;

namespace Event {
    struct Event;
}

class InternalServer {
private:
    Player* player;
public:
    Server* server;

    void startInternalServer(Player* p);

    void Stop();

    glm::vec3 GetPlayerCollusionTimes();

    Chunk* GetChunk(const ChunkPos& chunk);

    Timer* GetTickClock();

    double GetMSPT();

    void SetPlayer(Player player);

    bool CheckPlayerOnGround();

    size_t GetChunkCount();

    std::vector<ChunkPos> GetUpdatedChunks();

    std::vector<EntityProperty> GetUpdatedEntities();

    std::vector<EntityUUID> GetRemovedEntities();

    bool CheckRayIntersection(Ray& ray);

    BlockID GetBlock(const BlockPos& pos);

    void SendEvent(Event::Event pEventIn);

};
"./Level\\Server\\Interfaces\\ClientInterface.h"
#pragma once
#include "../../../Utils/Containers/ConcurrentQueue.h"
#include "../Networking/Packet.h"

/*
* Abstraction for server to client interfacing
*/

class ClientInterface {
protected:
    // Client -> Server queues
    ConcurrentQueue<Packet::PlayerAction> player_action_queue_;
    ConcurrentQueue<Packet::BlockAction> block_action_queue_;
public:
    virtual void SendBlockUpdate(const Packet::BlockUpdate& update) = 0;
    virtual void SendEntitySpawns(const Packet::EntitySpawn& entitySpawn) = 0;
    virtual void SendEntityUpdate(const Packet::EntityUpdate& update) = 0;
    virtual void SendEntityDespawns(const Packet::EntityDespawn& entityDespawn) = 0;
    virtual void SendChunkUpdates(const Packet::ChunkUpdateData& update) = 0;

    bool PollClientPlayerAction(std::vector<Packet::PlayerAction>& playerAction) {
        size_t prevSize = playerAction.size();
        player_action_queue_.PopAll(playerAction);
        return prevSize != playerAction.size();
    }

    bool PollClientBlockAction(std::vector<Packet::BlockAction>& blockAction) {
        size_t prevSize = blockAction.size();
        block_action_queue_.PopAll(blockAction);
        return prevSize != blockAction.size();
    }

    
};
"./Level\\Server\\Interfaces\\InternalInterface.h"
#pragma once
#include "ServerInterface.h"
#include "../../../Utils/LogUtils.h"
#include "../../../Utils/Containers/ConcurrentQueue.h"
#include "ClientInterface.h"

//
class InternalInterface : public ServerInterface, public ClientInterface {
    bool is_connected_ = false;
public:
    InternalInterface() {

    }

    // Client -> Server
    void SendPlayerAction(const Packet::PlayerAction& action) override {
        player_action_queue_.Push(action);
    }

    void SendBlockAction(const Packet::BlockAction& action) override {
        block_action_queue_.Push(action);
    }

    bool IsConnected() {
        return is_connected_;
    }

    void Connect(const std::string& address, int port) override {
        g_logger.LogError("InternalServerInterface::Connect", "This function isn't active!");
    }

    void Disconnect() {

    }

    void Update() {

    }

    // Server -> Client

    void SendBlockUpdate(const Packet::BlockUpdate& update) {
        block_update_queue_.Push(update);
    }

    void SendEntitySpawns(const Packet::EntitySpawn& entitySpawn) {
        entity_spawn_queue_.Push(entitySpawn);
    }

    void SendEntityUpdate(const Packet::EntityUpdate& update) {
        entity_update_queue_.Push(update);
    }

    void SendEntityDespawns(const Packet::EntityDespawn& entityDespawn) {
        entity_despawn_queue_.Push(entityDespawn);
    }

    void SendChunkUpdates(const Packet::ChunkUpdateData& update) {
        chunk_update_queue_.Push(update);
    }
};
"./Level\\Server\\Interfaces\\ServerInterface.h"
#pragma once
#include <vector>
#include "../../../Utils/Containers/ConcurrentQueue.h"
#include "../Networking/Packet.h"
#include <string>

/*
* Abstraction for client to server interfacing
*/
class ServerInterface {
protected:
    // Server -> Client queues
    ConcurrentQueue<Packet::BlockUpdate> block_update_queue_;
    ConcurrentQueue<Packet::EntitySpawn> entity_spawn_queue_;
    ConcurrentQueue<Packet::EntityUpdate> entity_update_queue_;
    ConcurrentQueue<Packet::EntityDespawn> entity_despawn_queue_;
    ConcurrentQueue<Packet::ChunkUpdateData> chunk_update_queue_;
public:
    virtual ~ServerInterface() = default;

    virtual void SendPlayerAction(const Packet::PlayerAction& input) = 0;
    virtual void SendBlockAction(const Packet::BlockAction& action) = 0;

    virtual bool IsConnected() const = 0;
    virtual void Connect(const std::string& address, int port) = 0; // For external server
    virtual void Disconnect() = 0;
    virtual void Update() = 0;

    bool PollBlockUpdates(std::vector<Packet::BlockUpdate>& outUpdates) {
        size_t prevSize = outUpdates.size();
        block_update_queue_.PopAll(outUpdates);
        return prevSize != outUpdates.size();
    }

    bool PollEntitySpawns(std::vector<Packet::EntitySpawn>& outSpawns) {
        size_t prevSize = outSpawns.size();
        entity_spawn_queue_.PopAll(outSpawns);
        return prevSize != outSpawns.size();
    }

    bool PollEntityUpdates(std::vector<Packet::EntityUpdate>& outUpdates) {
        size_t prevSize = outUpdates.size();
        entity_update_queue_.PopAll(outUpdates);
        return prevSize != outUpdates.size();
    }

    bool PollEntityDespawns(std::vector<Packet::EntityDespawn>& outDespawns) {
        size_t prevSize = outDespawns.size();
        entity_despawn_queue_.PopAll(outDespawns);
        return prevSize != outDespawns.size();
    }

    bool PollChunkUpdates(std::vector<Packet::ChunkUpdateData>& outUpdates) {
        size_t prevSize = outUpdates.size();
        chunk_update_queue_.PopAll(outUpdates);
        return prevSize != outUpdates.size();
    }

    
};
"./Level\\Server\\Networking\\Packet.h"
#pragma once

namespace Packet {

    struct PlayerAction {

    };

    struct BlockAction {

    };

    struct EntitySpawn {

    };

    struct EntityDespawn {

    };

    struct EntityUpdate {

    };

    struct BlockUpdate {

    };

    struct ChunkUpdateData {

    };
}
"./Level\\Server\\Server.cpp"
#include "Server.h"
#include "Interfaces/InternalInterface.h"
#include "../Chunk/ChunkPos/ChunkPos.h"
#include "../Dimension/Dimension.h"
#include "../Entity/Properties/EntityProperties.h"
#include "../Level.h"
#include "../LevelLoader.h"
#include "../World/WorldInteraction/WorldLoader.h"
#include "../Timer/Timer.h"
#include "../../Utils/Math/Ray/Ray.h"
#include "../../Utils/Clock.h"

Server::Server() = default;
Server::~Server() = default;

size_t Server::GetChunkCount() {
    return level_->level_loader_->GetChunkCount();
}

double Server::GetMSPT() {
    return mspt_;
}

Timer* Server::GetTimer() {
    return time_.get();
}

std::vector<EntityProperty> Server::GetUpdatedEntities() {
    return level_->main_world_->world_interactions_.GetUpdatedEntities();
}

std::vector<EntityUUID> Server::GetRemovedEntities() {
    return level_->main_world_->world_interactions_.GetRemovedEntities();
}

bool Server::CheckEntityOnGround(EntityUUID id) {
    return level_->main_world_->world_interactions_.collusions_->isEntityOnGround(level_->main_world_->world_interactions_.GetEntity(id));
}

void Server::Join(Entity& entity) {
    level_->main_world_->world_interactions_.summonEntity(entity);
}

std::vector<ChunkPos> Server::GetUpdatedChunkPos() {
    return level_->main_world_->world_interactions_.GetUpdatedChunkPos();
}

Chunk* Server::GetChunk(const ChunkPos& pos) {
    return level_->main_world_->world_interactions_.GetChunk(pos);
}

BlockID Server::GetBlock(const BlockPos& pos) { //Include dimension in parameter later
    return level_->main_world_->world_interactions_.GetBlock(pos);
}

bool Server::GetRayIntersection(Ray& ray) { //Include dimension in paramter later
    return level_->main_world_->world_interactions_.collusions_->CheckRayIntersection(ray);
}

glm::vec3 Server::GetEntityCollusionTime(EntityUUID entity) {
    return level_->main_world_->world_interactions_.collusions_->GetTimeTillCollusion(level_->main_world_->world_interactions_.GetEntity(entity));
}

void Server::StartServer(ServerSettings serverSettings) {
    level_ = std::make_unique<Level>();
    level_->Start(static_cast<int>(serverSettings.gen_thread_count_), static_cast<int>(serverSettings.light_engine_thread_count_));
    time_ = std::make_unique<Timer>();
    stop_ = false;
    settings_ = std::make_unique<ServerSettings>(serverSettings);
    main_server_loop_ = std::thread(&Server::Loop, this);
}

void Server::Stop() {
    stop_ = true;
    main_server_loop_.join();
    level_->Stop();
}

void Server::Loop() {
    g_logger.LogDebug("Server::Loop", "Started main server loop");
    while (!stop_) {
        time_->Set();
        // Process Client -> Server events
        

        Tick();

        mspt_ = time_->GetTimePassed_ms();
        double timeLeft = (1000.0 / (double)settings_->tick_rate_) - mspt_;

        if (timeLeft > 0) {
            timerSleepNotPrecise(static_cast<int>(timeLeft));
        }
    }
    g_logger.LogDebug("Server::Loop", "Shutting down main server loop");
}

void Server::Tick() {
    level_->main_world_->Tick();
    level_->main_world_->EventTick();
    level_->updateDimensions();
    level_->main_world_->world_interactions_.worldLoader_->Load();
}

void Server::SendEvent(const Event::Event& pEventIn) {
    level_->main_world_->event_manager_.AddEvent(pEventIn);
}

void Server::SetInternalConnection(InternalInterface* interface) {
    client_interface_ = static_cast<ClientInterface*>(interface);
}

void Server::ProcessPacket() {
    // Process player actions
    
}
"./Level\\Server\\Server.h"
#pragma once
#include <thread>
#include <vector>
#include <glm/vec3.hpp>

#include "../Typenames.h"

// TODO: Currently default to main dimension for now (change this later)
class ClientInterface;
class InternalInterface;
class Timer;
class Level;
class Chunk;
class Entity;

struct Ray;
struct EntityProperty;

namespace Event {
    struct Event;
}

struct ServerSettings {
    size_t gen_thread_count_ = 8;
    size_t light_engine_thread_count_ = 2;
    size_t tick_rate_ = 20;
    size_t horizontal_ticking_distance_ = 10;
    size_t vertical_ticking_distance_ = 8;

    ServerSettings() = default;
    ServerSettings(const ServerSettings&) = default;
    ServerSettings(ServerSettings&&) = default;
    ~ServerSettings() = default;
};

//This manages the input/output system of the world
//This also manages the ticking system
class Server {
private:
    bool stop_ = true; // TODO: Rename
    std::thread main_server_loop_;
    std::unique_ptr<Timer> time_; // TODO: Rename
    double mspt_ = 0.0;
public:
    std::unique_ptr<Level> level_ = nullptr;
    std::unique_ptr<ServerSettings> settings_ = nullptr;
    ClientInterface* client_interface_ = nullptr;

    Server();
    ~Server();

    size_t GetChunkCount();

    double GetMSPT();

    Timer* GetTimer();

    std::vector<EntityProperty> GetUpdatedEntities();

    std::vector<EntityUUID> GetRemovedEntities();

    bool CheckEntityOnGround(EntityUUID id);

    void Join(Entity& entity);

    std::vector<ChunkPos> GetUpdatedChunkPos();

    Chunk* GetChunk(const ChunkPos& id);

    BlockID GetBlock(const BlockPos& pos);

    bool GetRayIntersection(Ray& ray);

    glm::vec3 GetEntityCollusionTime(EntityUUID entity);

    void StartServer(ServerSettings serverSettings);

    void Stop();

    void Loop();

    void Tick();

    void SendEvent(const Event::Event& event);

    void SetInternalConnection(InternalInterface* conn);

    void ProcessPacket();
};
"./Level\\TerrainGeneration\\Biome\\Biome.h"
#pragma once
#include "../../../Core/Registry/Registry.h"
#include "../../../Core/Registry/ResourceLocation.h"
#include "BiomeProperties.h"
#include "../../Chunk/TallChunk.h"

#include "../Noisemaps/MinecraftNoiseGeneratorPerlin.h"
#include "../Noisemaps/TerrainParameters.h"

class Biome {
private:
    std::string biomeName = "";
    std::string baseBiome = "";
    float baseHeight = 0.1F;
    float heightVariation = 0.2F;
    float temperature = 0.5F;
    float rainfall = 0.5F;
    int waterColor = 16777215;
    bool enableSnow;
    bool enableRain = true;
public:
    BiomeProperties biomeProperties;

    static Registry<std::string, Biome*> REGISTRY;
    static FastHashMap<Biome*, int> BiomeIDs;
    static FastHashMap<int, Biome*> MUTATION_TO_BASE_ID_MAP;
    static NoiseGeneratorPerlin TEMPERATURE_NOISE;
    static NoiseGeneratorPerlin GRASS_COLOR_NOISE;

    BlockID topBlock = g_blocks.GRASS;
    BlockID fillerBlock = g_blocks.DIRT;

    enum TempCategory {
        OCEAN,
        COLD,
        MEDIUM,
        WARM
    };

    static void Register(int ID, std::string BiomeName, Biome* biome) {
        REGISTRY.Register(ID, ResourceLocation(BiomeName).path_, biome);
        BiomeIDs[biome] = ID;
        g_logger.LogDebug("Biome::Register", "Registered biome: " + BiomeName);
        if (biome->isMutation()) {
            MUTATION_TO_BASE_ID_MAP[ID] = biome;
        }
    }

    bool isMutation() {
        return baseBiome.length() != 0;
    }

    static int getIdForBiome(Biome* biome) {
        if (!BiomeIDs.count(biome)) {
            throw std::exception("Invalid biome");
        }
        return BiomeIDs[biome];
    }

    static Biome* getBiomeForId(int ID) {
        return REGISTRY.GetValue(REGISTRY.GetKey(ID));
    }

    static Biome* getBiome(int id) {
        return getBiome(id, (Biome*)nullptr);
    }

    static Biome* getBiome(int biomeId, Biome* fallback) {
        Biome* biome = nullptr;
        try {
            biome = REGISTRY.GetValue(REGISTRY.GetKey(biomeId));
        }
        catch (const std::exception& e) {
            g_logger.LogError("Biome::getBiome", e.what());
        }
        
        return biome == nullptr ? fallback : biome;
    }

    static Biome* getMutationForBiome(Biome* biome) {
        if (!Biome::MUTATION_TO_BASE_ID_MAP.count(getIdForBiome(biome))) {
            return nullptr;
        }

        return Biome::MUTATION_TO_BASE_ID_MAP[getIdForBiome(biome)];
    }

    virtual Biome::TempCategory getTempCategory() {
        if ((double)getDefaultTemperature() < 0.2)
        {
            return Biome::TempCategory::COLD;
        }
        else
        {
            return (double)getDefaultTemperature() < 1.0 ? Biome::TempCategory::MEDIUM : Biome::TempCategory::WARM;
        }
    }

    float getDefaultTemperature() {
        return temperature;
    }

    bool isSnowyBiome() {
        return enableSnow;
    }

    float getHeightVariation() {
        return heightVariation;
    }

    float getBaseHeight() {
        return baseHeight;
    }

    float getTemperature(glm::ivec3 pos)
    {
        if (pos.y > 64)
        {
            float f = (float)(TEMPERATURE_NOISE.getValue((double)((float)pos.x / 8.0F), (double)((float)pos.z / 8.0F)) * 4.0);
            return getDefaultTemperature() - (f + (float)pos.y - 64.0F) * 0.05F / 30.0F;
        }
        else
        {
            return getDefaultTemperature();
        }
    }

    Biome() {

    }

    Biome(BiomeProperties p) {
        biomeProperties = p;
        biomeName = p.biomeName;
        baseBiome = p.baseBiome;
        baseHeight = p.baseHeight;
        heightVariation = p.heightVariation;
        temperature = p.temperature;
        rainfall = p.rainfall;
        waterColor = p.waterColor;
        enableSnow = p.enableSnow;
        enableRain = p.enableRain;
    }

    virtual ~Biome() {

    }

    virtual const std::type_info& getBiomeClass() const {
        return typeid(*this);
    }

    virtual void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) {
        generateBiomeTerrain(rand, chunk, x, z, noiseVal, settings_);
    }

    void SetBlockChunkSafe(TallChunk* chunk, BlockID block, int x, int y, int z) {
        if ((x | (y >> 4) | z) >> 4) return;
        chunk->SetBlockUnsafe(x, y, z, block);
    }

    BlockID GetBlockChunkSafe(TallChunk* chunk, int x, int y, int z) {
        if ((x | (y >> 4) | z) >> 4) return g_blocks.AIR;
        return chunk->GetBlockUnsafe( x, y, z);
    }

    void generateBiomeTerrain(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) {

        int i = settings_->seaLevel;
        BlockID iblockstate = topBlock;
        BlockID iblockstate1 = fillerBlock;
        int j = -1;
        int k = (int)(noiseVal / 3.0 + 3.0 + rand.NextDouble() * 0.25);
        int l = x & 15;
        int i1 = z & 15;

        for (int j1 = 255; j1 >= 0; --j1)
        {
            if (j1 <= rand.NextInt(5))
            {
                chunk->SetBlockUnsafe(i1, j1, l, g_blocks.BEDROCK);
            }
            else
            {
                BlockID iblockstate2 = chunk->GetBlockUnsafe(i1, j1, l);

                if (iblockstate2 == g_blocks.AIR)
                {
                    j = -1;
                }
                else if (iblockstate2 == g_blocks.STONE)
                {
                    if (j == -1)
                    {
                        if (k <= 0)
                        {
                            iblockstate = g_blocks.AIR;
                            iblockstate1 = g_blocks.STONE;
                        }
                        else if (j1 >= i - 4 && j1 <= i + 1)
                        {
                            iblockstate = topBlock;
                            iblockstate1 = fillerBlock;
                        }

                        if (j1 < i && (iblockstate == g_blocks.AIR))
                        {
                            if (getTemperature(glm::ivec3(x, j1, z)) < 0.15F)
                            {
                                iblockstate = g_blocks.ICE;
                            }
                            else
                            {
                                iblockstate = g_blocks.WATER;
                            }
                        }

                        j = k;

                        if (j1 >= i - 1)
                        {
                            chunk->SetBlockUnsafe(i1, j1, l, iblockstate);
                        }
                        else if (j1 < i - 7 - k)
                        {
                            iblockstate = g_blocks.AIR;
                            iblockstate1 = g_blocks.STONE;
                            chunk->SetBlockUnsafe(i1, j1, l, g_blocks.GRAVEL);
                        }
                        else
                        {
                            chunk->SetBlockUnsafe(i1, j1, l, iblockstate1);
                        }
                    }
                    else if (j > 0)
                    {
                        --j;
                        chunk->SetBlockUnsafe(i1, j1, l, iblockstate1);

                        if (j == 0 && iblockstate1 == g_blocks.SAND && k > 1)
                        {
                            j = rand.NextInt(4) + std::max(0, j1 - 63);
                            iblockstate1 = g_blocks.RED_SAND;
                        }
                    }
                }
            }
        }
    }

};

inline Registry<std::string, Biome*> Biome::REGISTRY = Registry<std::string, Biome*>();
inline FastHashMap<Biome*, int> Biome::BiomeIDs = FastHashMap<Biome*, int>();
inline FastHashMap<int, Biome*> Biome::MUTATION_TO_BASE_ID_MAP = FastHashMap<int, Biome*>();

inline NoiseGeneratorPerlin Biome::TEMPERATURE_NOISE = NoiseGeneratorPerlin(JavaRandom(1234L), 1);
inline NoiseGeneratorPerlin Biome::GRASS_COLOR_NOISE = NoiseGeneratorPerlin(JavaRandom(2345L), 1);
"./Level\\TerrainGeneration\\Biome\\BiomeProperties.cpp"
#include "BiomeProperties.h"

BiomeProperties& BiomeProperties::setTemperature(float temperatureIn) {
    if (temperatureIn > 0.1F && temperatureIn < 0.2F) {
        throw std::exception("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
    }
    else {
        temperature = temperatureIn;
        return *this;
    }
}

BiomeProperties& BiomeProperties::setRainfall(float rainfallIn) {
    rainfall = rainfallIn;
    return *this;
}

BiomeProperties& BiomeProperties::setBaseHeight(float baseHeightIn) {
    baseHeight = baseHeightIn;
    return *this;
}

BiomeProperties& BiomeProperties::setHeightVariation(float heightVariationIn) {
    heightVariation = heightVariationIn;
    return *this;
}

BiomeProperties& BiomeProperties::setRainDisabled() {
    enableRain = false;
    return *this;
}

BiomeProperties& BiomeProperties::setSnowEnabled() {
    enableSnow = true;
    return *this;
}

BiomeProperties& BiomeProperties::setWaterColor(int waterColorIn) {
    waterColor = waterColorIn;
    return *this;
}

BiomeProperties& BiomeProperties::setBaseBiome(std::string baseBiomeIn) {
    baseBiome = baseBiomeIn;
    return *this;
}
"./Level\\TerrainGeneration\\Biome\\BiomeProperties.h"
#pragma once
#include <string>
#include <exception>
class BiomeProperties {
private:
    
public:
    std::string biomeName = "";
    std::string baseBiome = "";
    float baseHeight = 0.1F;
    float heightVariation = 0.2F;
    float temperature = 0.5F;
    float rainfall = 0.5F;
    int waterColor = 16777215;
    bool enableSnow = false;
    bool enableRain = true;

    BiomeProperties(std::string biomeNameIn) : biomeName(biomeNameIn) {}

    BiomeProperties() {}

    BiomeProperties& setTemperature(float temperatureIn);

    BiomeProperties& setRainfall(float rainfallIn);

    BiomeProperties& setBaseHeight(float baseHeightIn);

    BiomeProperties& setHeightVariation(float heightVariationIn);

    BiomeProperties& setRainDisabled();

    BiomeProperties& setSnowEnabled();

    BiomeProperties& setWaterColor(int waterColorIn);

    BiomeProperties& setBaseBiome(std::string baseBiomeIn);
};
"./Level\\TerrainGeneration\\Biome\\BiomeProvider.h"
#pragma once
#include "../GenLayer/CombineLayers.h"
#include <concurrent_unordered_map.h>
//mc src
inline std::mutex g_biome_lock;

class BiomeProvider {
private:
    static std::vector<GenLayer*> genBiomes;
    static std::vector<GenLayer*> biomeIndexLayer;
    static ChunkGeneratorSettings* settings_;
    static concurrency::concurrent_unordered_map<size_t, size_t> ThreadGenIndex;
    static long long biomeProviderSeed;
public:
    BiomeProvider() {

    }

    BiomeProvider(long long seed, ChunkGeneratorSettings* settingsIn) {
        (void)seed;
        (void)settingsIn;
        throw std::exception("Not used");
    }

    static void init(long long seed, ChunkGeneratorSettings* settingsIn) {
        std::lock_guard<std::mutex> lock{ g_biome_lock };
        std::vector<GenLayer*> agenlayer = CombinedGenLayers::initializeAllBiomeGenerators(seed, settingsIn);
        BiomeProvider::genBiomes.push_back(agenlayer[0]);
        BiomeProvider::biomeIndexLayer.push_back(agenlayer[1]);
        BiomeProvider::settings_ = settingsIn;
        BiomeProvider::biomeProviderSeed = seed;
    }

    static std::vector<Biome*> getBiomesForGeneration(int x, int z, int width, int length) {
        size_t threadHash = std::hash<std::thread::id>{}(std::this_thread::get_id()); //Used to detect if a new thread is running
        size_t mapSize = BiomeProvider::ThreadGenIndex.size();
        if (!ThreadGenIndex.count(threadHash)) {
            BiomeProvider::ThreadGenIndex[threadHash] = mapSize;
            init(biomeProviderSeed, settings_);
        }

        size_t threadIndex = BiomeProvider::ThreadGenIndex[threadHash];

        std::vector<int> aint = BiomeProvider::genBiomes[threadIndex]->getInts(x, z, width, length);

        std::vector<Biome*> list(width * length);

        for (int i = 0; i < width * length; ++i) {
            list[i] = Biome::getBiome(aint[i], Biomes::DEFAULT);
        }
        return list;
    }

    static std::vector<Biome*> getBiomes(int x, int z, int width, int length) {
        size_t threadHash = std::hash<std::thread::id>{}(std::this_thread::get_id()); //Used to detect if a new thread is running
        size_t mapSize = BiomeProvider::ThreadGenIndex.size();
        if (!ThreadGenIndex.count(threadHash)) {
            BiomeProvider::ThreadGenIndex[threadHash] = mapSize;
            init(biomeProviderSeed, settings_);
        }

        size_t threadIndex = BiomeProvider::ThreadGenIndex[threadHash];

        std::vector<int> aint = biomeIndexLayer[threadIndex]->getInts(x, z, width, length);
        std::vector<Biome*> out(width * length);
        for (int i = 0; i < width * length; ++i)
        {
            out[i] = Biome::getBiome(aint[i], Biomes::DEFAULT);
        }

        return out;
    }
};

inline std::vector<GenLayer*> BiomeProvider::genBiomes = std::vector<GenLayer*>();
inline std::vector<GenLayer*> BiomeProvider::biomeIndexLayer = std::vector<GenLayer*>();
inline ChunkGeneratorSettings* BiomeProvider::settings_ = nullptr;
inline long long BiomeProvider::biomeProviderSeed = 0;
inline concurrency::concurrent_unordered_map<size_t, size_t> BiomeProvider::ThreadGenIndex = concurrency::concurrent_unordered_map<size_t, size_t>();
"./Level\\TerrainGeneration\\Biome\\Biomes.h"
#pragma once
#include "Biome.h"
#include "BiomeType/BiomeOcean.h"
#include "BiomeType/BiomeDesert.h"
#include "BiomeType/BiomeForest.h"
#include "BiomeType/BiomeHills.h"
#include "BiomeType/BiomePlains.h"
#include "BiomeType/BiomeRiver.h"
#include "BiomeType/BiomeSwamp.h"
#include "BiomeType/BiomeTaiga.h"
#include "BiomeType/BiomeHell.h"
#include "BiomeType/BiomeEnd.h"
#include "BiomeType/BiomeSnow.h"
#include "BiomeType/BiomeMushroomIsland.h"
#include "BiomeType/BiomeBeach.h"
#include "BiomeType/BiomeJungle.h"
#include "BiomeType/BiomeStoneBeach.h"
#include "BiomeType/BiomeSavanna.h"
#include "BiomeType/BiomeMesa.h"
#include "BiomeType/BiomeVoid.h"
#include "BiomeType/BiomeForestMutated.h"
#include "BiomeType/BiomeSavannaMutated.h"

// TODO: Rework this to not use static variables

class Biomes {
public:
    static Biome* OCEAN;
    static Biome* DEFAULT;
    static Biome* PLAINS;
    static Biome* DESERT;
    static Biome* EXTREME_HILLS;
    static Biome* FOREST;
    static Biome* TAIGA;
    static Biome* SWAMPLAND;
    static Biome* RIVER;
    static Biome* HELL;
    static Biome* SKY;
    static Biome* FROZEN_OCEAN;
    static Biome* FROZEN_RIVER;
    static Biome* ICE_PLAINS;
    static Biome* ICE_MOUNTAINS;
    static Biome* MUSHROOM_ISLAND;
    static Biome* MUSHROOM_ISLAND_SHORE;
    static Biome* BEACH;
    static Biome* DESERT_HILLS;
    static Biome* FOREST_HILLS;
    static Biome* TAIGA_HILLS;
    static Biome* EXTREME_HILLS_EDGE;
    static Biome* JUNGLE;
    static Biome* JUNGLE_HILLS;
    static Biome* JUNGLE_EDGE;
    static Biome* DEEP_OCEAN;
    static Biome* STONE_BEACH;
    static Biome* COLD_BEACH;
    static Biome* BIRCH_FOREST;
    static Biome* BIRCH_FOREST_HILLS;
    static Biome* ROOFED_FOREST;
    static Biome* COLD_TAIGA;
    static Biome* COLD_TAIGA_HILLS;
    static Biome* REDWOOD_TAIGA;
    static Biome* REDWOOD_TAIGA_HILLS;
    static Biome* EXTREME_HILLS_WITH_TREES;
    static Biome* SAVANNA;
    static Biome* SAVANNA_PLATEAU;
    static Biome* MESA;
    static Biome* MESA_ROCK;
    static Biome* MESA_CLEAR_ROCK;
    static Biome* VOID;
    static Biome* MUTATED_PLAINS;
    static Biome* MUTATED_DESERT;
    static Biome* MUTATED_EXTREME_HILLS;
    static Biome* MUTATED_FOREST;
    static Biome* MUTATED_TAIGA;
    static Biome* MUTATED_SWAMPLAND;
    static Biome* MUTATED_ICE_FLATS;
    static Biome* MUTATED_JUNGLE;
    static Biome* MUTATED_JUNGLE_EDGE;
    static Biome* MUTATED_BIRCH_FOREST;
    static Biome* MUTATED_BIRCH_FOREST_HILLS;
    static Biome* MUTATED_ROOFED_FOREST;
    static Biome* MUTATED_TAIGA_COLD;
    static Biome* MUTATED_REDWOOD_TAIGA;
    static Biome* MUTATED_REDWOOD_TAIGA_HILLS;
    static Biome* MUTATED_EXTREME_HILLS_WITH_TREES;
    static Biome* MUTATED_SAVANNA;
    static Biome* MUTATED_SAVANNA_ROCK;
    static Biome* MUTATED_MESA;
    static Biome* MUTATED_MESA_ROCK;
    static Biome* MUTATED_MESA_CLEAR_ROCK;

    static Biome* getRegisteredBiome(std::string name) {
        Biome* biome;

        biome = Biome::REGISTRY.GetValue(ResourceLocation(name).path_);

        return biome;
    }

    static void RegisterBiome() {
        Biome::Register(0, "ocean", new BiomeOcean(BiomeProperties("Ocean").setBaseHeight(-1.0F).setHeightVariation(0.1F)));
        Biome::Register(1, "plains", new BiomePlains(false, BiomeProperties("Plains").setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(0.8F).setRainfall(0.4F)));
        Biome::Register(2, "desert", new BiomeDesert(BiomeProperties("Desert").setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(3, "extreme_hills", new BiomeHills(BiomeHills::Type::NORMAL, BiomeProperties("Extreme Hills").setBaseHeight(1.0F).setHeightVariation(0.5F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(4, "forest", new BiomeForest(BiomeForest::Type::NORMAL, BiomeProperties("Forest").setTemperature(0.7F).setRainfall(0.8F)));
        Biome::Register(5, "taiga", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("Taiga").setBaseHeight(0.2F).setHeightVariation(0.2F).setTemperature(0.25F).setRainfall(0.8F)));
        Biome::Register(6, "swampland", new BiomeSwamp(BiomeProperties("Swampland").setBaseHeight(-0.2F).setHeightVariation(0.1F).setTemperature(0.8F).setRainfall(0.9F).setWaterColor(14745518)));
        Biome::Register(7, "river", new BiomeRiver(BiomeProperties("River").setBaseHeight(-0.5F).setHeightVariation(0.0F)));
        Biome::Register(8, "hell", new BiomeHell(BiomeProperties("Hell").setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(9, "sky", new BiomeEnd(BiomeProperties("The End").setRainDisabled()));
        Biome::Register(10, "frozen_ocean", new BiomeOcean(BiomeProperties("FrozenOcean").setBaseHeight(-1.0F).setHeightVariation(0.1F).setTemperature(0.0F).setRainfall(0.5F).setSnowEnabled()));
        Biome::Register(11, "frozen_river", new BiomeRiver(BiomeProperties("FrozenRiver").setBaseHeight(-0.5F).setHeightVariation(0.0F).setTemperature(0.0F).setRainfall(0.5F).setSnowEnabled()));
        Biome::Register(12, "ice_flats", new BiomeSnow(false, BiomeProperties("Ice Plains").setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(0.0F).setRainfall(0.5F).setSnowEnabled()));
        Biome::Register(13, "ice_mountains", new BiomeSnow(false, BiomeProperties("Ice Mountains").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.0F).setRainfall(0.5F).setSnowEnabled()));
        Biome::Register(14, "mushroom_island", new BiomeMushroomIsland(BiomeProperties("MushroomIsland").setBaseHeight(0.2F).setHeightVariation(0.3F).setTemperature(0.9F).setRainfall(1.0F)));
        Biome::Register(15, "mushroom_island_shore", new BiomeMushroomIsland(BiomeProperties("MushroomIslandShore").setBaseHeight(0.0F).setHeightVariation(0.025F).setTemperature(0.9F).setRainfall(1.0F)));
        Biome::Register(16, "beaches", new BiomeBeach(BiomeProperties("Beach").setBaseHeight(0.0F).setHeightVariation(0.025F).setTemperature(0.8F).setRainfall(0.4F)));
        Biome::Register(17, "desert_hills", new BiomeDesert(BiomeProperties("DesertHills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(18, "forest_hills", new BiomeForest(BiomeForest::Type::NORMAL, BiomeProperties("ForestHills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.7F).setRainfall(0.8F)));
        Biome::Register(19, "taiga_hills", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("TaigaHills").setTemperature(0.25F).setRainfall(0.8F).setBaseHeight(0.45F).setHeightVariation(0.3F)));
        Biome::Register(20, "smaller_extreme_hills", new BiomeHills(BiomeHills::Type::EXTRA_TREES, BiomeProperties("Extreme Hills Edge").setBaseHeight(0.8F).setHeightVariation(0.3F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(21, "jungle", new BiomeJungle(false, BiomeProperties("Jungle").setTemperature(0.95F).setRainfall(0.9F)));
        Biome::Register(22, "jungle_hills", new BiomeJungle(false, BiomeProperties("JungleHills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.95F).setRainfall(0.9F)));
        Biome::Register(23, "jungle_edge", new BiomeJungle(true, BiomeProperties("JungleEdge").setTemperature(0.95F).setRainfall(0.8F)));
        Biome::Register(24, "deep_ocean", new BiomeOcean(BiomeProperties("Deep Ocean").setBaseHeight(-1.8F).setHeightVariation(0.1F)));
        Biome::Register(25, "stone_beach", new BiomeStoneBeach(BiomeProperties("Stone Beach").setBaseHeight(0.1F).setHeightVariation(0.8F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(26, "cold_beach", new BiomeBeach(BiomeProperties("Cold Beach").setBaseHeight(0.0F).setHeightVariation(0.025F).setTemperature(0.05F).setRainfall(0.3F).setSnowEnabled()));
        Biome::Register(27, "birch_forest", new BiomeForest(BiomeForest::Type::BIRCH, BiomeProperties("Birch Forest").setTemperature(0.6F).setRainfall(0.6F)));
        Biome::Register(28, "birch_forest_hills", new BiomeForest(BiomeForest::Type::BIRCH, BiomeProperties("Birch Forest Hills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.6F).setRainfall(0.6F)));
        Biome::Register(29, "roofed_forest", new BiomeForest(BiomeForest::Type::ROOFED, BiomeProperties("Roofed Forest").setTemperature(0.7F).setRainfall(0.8F)));
        Biome::Register(30, "taiga_cold", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("Cold Taiga").setBaseHeight(0.2F).setHeightVariation(0.2F).setTemperature(-0.5F).setRainfall(0.4F).setSnowEnabled()));
        Biome::Register(31, "taiga_cold_hills", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("Cold Taiga Hills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(-0.5F).setRainfall(0.4F).setSnowEnabled()));
        Biome::Register(32, "redwood_taiga", new BiomeTaiga(BiomeTaiga::Type::MEGA, BiomeProperties("Mega Taiga").setTemperature(0.3F).setRainfall(0.8F).setBaseHeight(0.2F).setHeightVariation(0.2F)));
        Biome::Register(33, "redwood_taiga_hills", new BiomeTaiga(BiomeTaiga::Type::MEGA, BiomeProperties("Mega Taiga Hills").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(0.3F).setRainfall(0.8F)));
        Biome::Register(34, "extreme_hills_with_trees", new BiomeHills(BiomeHills::Type::EXTRA_TREES, BiomeProperties("Extreme Hills+").setBaseHeight(1.0F).setHeightVariation(0.5F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(35, "savanna", new BiomeSavanna(BiomeProperties("Savanna").setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(1.2F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(36, "savanna_rock", new BiomeSavanna(BiomeProperties("Savanna Plateau").setBaseHeight(1.5F).setHeightVariation(0.025F).setTemperature(1.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(37, "mesa", new BiomeMesa(false, false, BiomeProperties("Mesa").setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(38, "mesa_rock", new BiomeMesa(false, true, BiomeProperties("Mesa Plateau F").setBaseHeight(1.5F).setHeightVariation(0.025F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(39, "mesa_clear_rock", new BiomeMesa(false, false, BiomeProperties("Mesa Plateau").setBaseHeight(1.5F).setHeightVariation(0.025F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(127, "void", new BiomeVoid(BiomeProperties("The Void").setRainDisabled()));
        Biome::Register(129, "mutated_plains", new BiomePlains(true, BiomeProperties("Sunflower Plains").setBaseBiome("plains").setBaseHeight(0.125F).setHeightVariation(0.05F).setTemperature(0.8F).setRainfall(0.4F)));
        Biome::Register(130, "mutated_desert", new BiomeDesert(BiomeProperties("Desert M").setBaseBiome("desert").setBaseHeight(0.225F).setHeightVariation(0.25F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(131, "mutated_extreme_hills", new BiomeHills(BiomeHills::Type::MUTATED, BiomeProperties("Extreme Hills M").setBaseBiome("extreme_hills").setBaseHeight(1.0F).setHeightVariation(0.5F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(132, "mutated_forest", new BiomeForest(BiomeForest::Type::FLOWER, BiomeProperties("Flower Forest").setBaseBiome("forest").setHeightVariation(0.4F).setTemperature(0.7F).setRainfall(0.8F)));
        Biome::Register(133, "mutated_taiga", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("Taiga M").setBaseBiome("taiga").setBaseHeight(0.3F).setHeightVariation(0.4F).setTemperature(0.25F).setRainfall(0.8F)));
        Biome::Register(134, "mutated_swampland", new BiomeSwamp(BiomeProperties("Swampland M").setBaseBiome("swampland").setBaseHeight(-0.1F).setHeightVariation(0.3F).setTemperature(0.8F).setRainfall(0.9F).setWaterColor(14745518)));
        Biome::Register(140, "mutated_ice_flats", new BiomeSnow(true, BiomeProperties("Ice Plains Spikes").setBaseBiome("ice_flats").setBaseHeight(0.425F).setHeightVariation(0.45000002F).setTemperature(0.0F).setRainfall(0.5F).setSnowEnabled()));
        Biome::Register(149, "mutated_jungle", new BiomeJungle(false, BiomeProperties("Jungle M").setBaseBiome("jungle").setBaseHeight(0.2F).setHeightVariation(0.4F).setTemperature(0.95F).setRainfall(0.9F)));
        Biome::Register(151, "mutated_jungle_edge", new BiomeJungle(true, BiomeProperties("JungleEdge M").setBaseBiome("jungle_edge").setBaseHeight(0.2F).setHeightVariation(0.4F).setTemperature(0.95F).setRainfall(0.8F)));
        Biome::Register(155, "mutated_birch_forest", new BiomeForestMutated(BiomeProperties("Birch Forest M").setBaseBiome("birch_forest").setBaseHeight(0.2F).setHeightVariation(0.4F).setTemperature(0.6F).setRainfall(0.6F)));
        Biome::Register(156, "mutated_birch_forest_hills", new BiomeForestMutated(BiomeProperties("Birch Forest Hills M").setBaseBiome("birch_forest_hills").setBaseHeight(0.55F).setHeightVariation(0.5F).setTemperature(0.6F).setRainfall(0.6F)));
        Biome::Register(157, "mutated_roofed_forest", new BiomeForest(BiomeForest::Type::ROOFED, BiomeProperties("Roofed Forest M").setBaseBiome("roofed_forest").setBaseHeight(0.2F).setHeightVariation(0.4F).setTemperature(0.7F).setRainfall(0.8F)));
        Biome::Register(158, "mutated_taiga_cold", new BiomeTaiga(BiomeTaiga::Type::NORMAL, BiomeProperties("Cold Taiga M").setBaseBiome("taiga_cold").setBaseHeight(0.3F).setHeightVariation(0.4F).setTemperature(-0.5F).setRainfall(0.4F).setSnowEnabled()));
        Biome::Register(160, "mutated_redwood_taiga", new BiomeTaiga(BiomeTaiga::Type::MEGA_SPRUCE, BiomeProperties("Mega Spruce Taiga").setBaseBiome("redwood_taiga").setBaseHeight(0.2F).setHeightVariation(0.2F).setTemperature(0.25F).setRainfall(0.8F)));
        Biome::Register(161, "mutated_redwood_taiga_hills", new BiomeTaiga(BiomeTaiga::Type::MEGA_SPRUCE, BiomeProperties("Redwood Taiga Hills M").setBaseBiome("redwood_taiga_hills").setBaseHeight(0.2F).setHeightVariation(0.2F).setTemperature(0.25F).setRainfall(0.8F)));
        Biome::Register(162, "mutated_extreme_hills_with_trees", new BiomeHills(BiomeHills::Type::MUTATED, BiomeProperties("Extreme Hills+ M").setBaseBiome("extreme_hills_with_trees").setBaseHeight(1.0F).setHeightVariation(0.5F).setTemperature(0.2F).setRainfall(0.3F)));
        Biome::Register(163, "mutated_savanna", new BiomeSavannaMutated(BiomeProperties("Savanna M").setBaseBiome("savanna").setBaseHeight(0.3625F).setHeightVariation(1.225F).setTemperature(1.1F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(164, "mutated_savanna_rock", new BiomeSavannaMutated(BiomeProperties("Savanna Plateau M").setBaseBiome("savanna_rock").setBaseHeight(1.05F).setHeightVariation(1.2125001F).setTemperature(1.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(165, "mutated_mesa", new BiomeMesa(true, false, BiomeProperties("Mesa (Bryce)").setBaseBiome("mesa").setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(166, "mutated_mesa_rock", new BiomeMesa(false, true, BiomeProperties("Mesa Plateau F M").setBaseBiome("mesa_rock").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
        Biome::Register(167, "mutated_mesa_clear_rock", new BiomeMesa(false, false, BiomeProperties("Mesa Plateau M").setBaseBiome("mesa_clear_rock").setBaseHeight(0.45F).setHeightVariation(0.3F).setTemperature(2.0F).setRainfall(0.0F).setRainDisabled()));
    
        Biomes::OCEAN = getRegisteredBiome("ocean");
        Biomes::DEFAULT = OCEAN;
        Biomes::PLAINS = getRegisteredBiome("plains");
        Biomes::DESERT = getRegisteredBiome("desert");
        Biomes::EXTREME_HILLS = getRegisteredBiome("extreme_hills");
        Biomes::FOREST = getRegisteredBiome("forest");
        Biomes::TAIGA = getRegisteredBiome("taiga");
        Biomes::SWAMPLAND = getRegisteredBiome("swampland");
        Biomes::RIVER = getRegisteredBiome("river");
        Biomes::HELL = getRegisteredBiome("hell");
        Biomes::SKY = getRegisteredBiome("sky");
        Biomes::FROZEN_OCEAN = getRegisteredBiome("frozen_ocean");
        Biomes::FROZEN_RIVER = getRegisteredBiome("frozen_river");
        Biomes::ICE_PLAINS = getRegisteredBiome("ice_flats");
        Biomes::ICE_MOUNTAINS = getRegisteredBiome("ice_mountains");
        Biomes::MUSHROOM_ISLAND = getRegisteredBiome("mushroom_island");
        Biomes::MUSHROOM_ISLAND_SHORE = getRegisteredBiome("mushroom_island_shore");
        Biomes::BEACH = getRegisteredBiome("beaches");
        Biomes::DESERT_HILLS = getRegisteredBiome("desert_hills");
        Biomes::FOREST_HILLS = getRegisteredBiome("forest_hills");
        Biomes::TAIGA_HILLS = getRegisteredBiome("taiga_hills");
        Biomes::EXTREME_HILLS_EDGE = getRegisteredBiome("smaller_extreme_hills");
        Biomes::JUNGLE = getRegisteredBiome("jungle");
        Biomes::JUNGLE_HILLS = getRegisteredBiome("jungle_hills");
        Biomes::JUNGLE_EDGE = getRegisteredBiome("jungle_edge");
        Biomes::DEEP_OCEAN = getRegisteredBiome("deep_ocean");
        Biomes::STONE_BEACH = getRegisteredBiome("stone_beach");
        Biomes::COLD_BEACH = getRegisteredBiome("cold_beach");
        Biomes::BIRCH_FOREST = getRegisteredBiome("birch_forest");
        Biomes::BIRCH_FOREST_HILLS = getRegisteredBiome("birch_forest_hills");
        Biomes::ROOFED_FOREST = getRegisteredBiome("roofed_forest");
        Biomes::COLD_TAIGA = getRegisteredBiome("taiga_cold");
        Biomes::COLD_TAIGA_HILLS = getRegisteredBiome("taiga_cold_hills");
        Biomes::REDWOOD_TAIGA = getRegisteredBiome("redwood_taiga");
        Biomes::REDWOOD_TAIGA_HILLS = getRegisteredBiome("redwood_taiga_hills");
        Biomes::EXTREME_HILLS_WITH_TREES = getRegisteredBiome("extreme_hills_with_trees");
        Biomes::SAVANNA = getRegisteredBiome("savanna");
        Biomes::SAVANNA_PLATEAU = getRegisteredBiome("savanna_rock");
        Biomes::MESA = getRegisteredBiome("mesa");
        Biomes::MESA_ROCK = getRegisteredBiome("mesa_rock");
        Biomes::MESA_CLEAR_ROCK = getRegisteredBiome("mesa_clear_rock");
        Biomes::VOID = getRegisteredBiome("void");
        Biomes::MUTATED_PLAINS = getRegisteredBiome("mutated_plains");
        Biomes::MUTATED_DESERT = getRegisteredBiome("mutated_desert");
        Biomes::MUTATED_EXTREME_HILLS = getRegisteredBiome("mutated_extreme_hills");
        Biomes::MUTATED_FOREST = getRegisteredBiome("mutated_forest");
        Biomes::MUTATED_TAIGA = getRegisteredBiome("mutated_taiga");
        Biomes::MUTATED_SWAMPLAND = getRegisteredBiome("mutated_swampland");
        Biomes::MUTATED_ICE_FLATS = getRegisteredBiome("mutated_ice_flats");
        Biomes::MUTATED_JUNGLE = getRegisteredBiome("mutated_jungle");
        Biomes::MUTATED_JUNGLE_EDGE = getRegisteredBiome("mutated_jungle_edge");
        Biomes::MUTATED_BIRCH_FOREST = getRegisteredBiome("mutated_birch_forest");
        Biomes::MUTATED_BIRCH_FOREST_HILLS = getRegisteredBiome("mutated_birch_forest_hills");
        Biomes::MUTATED_ROOFED_FOREST = getRegisteredBiome("mutated_roofed_forest");
        Biomes::MUTATED_TAIGA_COLD = getRegisteredBiome("mutated_taiga_cold");
        Biomes::MUTATED_REDWOOD_TAIGA = getRegisteredBiome("mutated_redwood_taiga");
        Biomes::MUTATED_REDWOOD_TAIGA_HILLS = getRegisteredBiome("mutated_redwood_taiga_hills");
        Biomes::MUTATED_EXTREME_HILLS_WITH_TREES = getRegisteredBiome("mutated_extreme_hills_with_trees");
        Biomes::MUTATED_SAVANNA = getRegisteredBiome("mutated_savanna");
        Biomes::MUTATED_SAVANNA_ROCK = getRegisteredBiome("mutated_savanna_rock");
        Biomes::MUTATED_MESA = getRegisteredBiome("mutated_mesa");
        Biomes::MUTATED_MESA_ROCK = getRegisteredBiome("mutated_mesa_rock");
        Biomes::MUTATED_MESA_CLEAR_ROCK = getRegisteredBiome("mutated_mesa_clear_rock");
    }
};

inline Biome* Biomes::OCEAN = nullptr;
inline Biome* Biomes::DEFAULT = nullptr;
inline Biome* Biomes::PLAINS = nullptr;
inline Biome* Biomes::DESERT = nullptr;
inline Biome* Biomes::EXTREME_HILLS = nullptr;
inline Biome* Biomes::FOREST = nullptr;
inline Biome* Biomes::TAIGA = nullptr;
inline Biome* Biomes::SWAMPLAND = nullptr;
inline Biome* Biomes::RIVER = nullptr;
inline Biome* Biomes::HELL = nullptr;
inline Biome* Biomes::SKY = nullptr;
inline Biome* Biomes::FROZEN_OCEAN = nullptr;
inline Biome* Biomes::FROZEN_RIVER = nullptr;
inline Biome* Biomes::ICE_PLAINS = nullptr;
inline Biome* Biomes::ICE_MOUNTAINS = nullptr;
inline Biome* Biomes::MUSHROOM_ISLAND = nullptr;
inline Biome* Biomes::MUSHROOM_ISLAND_SHORE = nullptr;
inline Biome* Biomes::BEACH = nullptr;
inline Biome* Biomes::DESERT_HILLS = nullptr;
inline Biome* Biomes::FOREST_HILLS = nullptr;
inline Biome* Biomes::TAIGA_HILLS = nullptr;
inline Biome* Biomes::EXTREME_HILLS_EDGE = nullptr;
inline Biome* Biomes::JUNGLE = nullptr;
inline Biome* Biomes::JUNGLE_HILLS = nullptr;
inline Biome* Biomes::JUNGLE_EDGE = nullptr;
inline Biome* Biomes::DEEP_OCEAN = nullptr;
inline Biome* Biomes::STONE_BEACH = nullptr;
inline Biome* Biomes::COLD_BEACH = nullptr;
inline Biome* Biomes::BIRCH_FOREST = nullptr;
inline Biome* Biomes::BIRCH_FOREST_HILLS = nullptr;
inline Biome* Biomes::ROOFED_FOREST = nullptr;
inline Biome* Biomes::COLD_TAIGA = nullptr;
inline Biome* Biomes::COLD_TAIGA_HILLS = nullptr;
inline Biome* Biomes::REDWOOD_TAIGA = nullptr;
inline Biome* Biomes::REDWOOD_TAIGA_HILLS = nullptr;
inline Biome* Biomes::EXTREME_HILLS_WITH_TREES = nullptr;
inline Biome* Biomes::SAVANNA = nullptr;
inline Biome* Biomes::SAVANNA_PLATEAU = nullptr;
inline Biome* Biomes::MESA = nullptr;
inline Biome* Biomes::MESA_ROCK = nullptr;
inline Biome* Biomes::MESA_CLEAR_ROCK = nullptr;
inline Biome* Biomes::VOID = nullptr;
inline Biome* Biomes::MUTATED_PLAINS = nullptr;
inline Biome* Biomes::MUTATED_DESERT = nullptr;
inline Biome* Biomes::MUTATED_EXTREME_HILLS = nullptr;
inline Biome* Biomes::MUTATED_FOREST = nullptr;
inline Biome* Biomes::MUTATED_TAIGA = nullptr;
inline Biome* Biomes::MUTATED_SWAMPLAND = nullptr;
inline Biome* Biomes::MUTATED_ICE_FLATS = nullptr;
inline Biome* Biomes::MUTATED_JUNGLE = nullptr;
inline Biome* Biomes::MUTATED_JUNGLE_EDGE = nullptr;
inline Biome* Biomes::MUTATED_BIRCH_FOREST = nullptr;
inline Biome* Biomes::MUTATED_BIRCH_FOREST_HILLS = nullptr;
inline Biome* Biomes::MUTATED_ROOFED_FOREST = nullptr;
inline Biome* Biomes::MUTATED_TAIGA_COLD = nullptr;
inline Biome* Biomes::MUTATED_REDWOOD_TAIGA = nullptr;
inline Biome* Biomes::MUTATED_REDWOOD_TAIGA_HILLS = nullptr;
inline Biome* Biomes::MUTATED_EXTREME_HILLS_WITH_TREES = nullptr;
inline Biome* Biomes::MUTATED_SAVANNA = nullptr;
inline Biome* Biomes::MUTATED_SAVANNA_ROCK = nullptr;
inline Biome* Biomes::MUTATED_MESA = nullptr;
inline Biome* Biomes::MUTATED_MESA_ROCK = nullptr;
inline Biome* Biomes::MUTATED_MESA_CLEAR_ROCK = nullptr;
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeBeach.h"
#pragma once
#include "../Biome.h"

class BiomeBeach : public Biome {
public:
    BiomeBeach(BiomeProperties properties) : Biome(properties) {
        topBlock = g_blocks.SAND;
        fillerBlock = g_blocks.SAND;
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeDesert.h"
#pragma once
#include "../Biome.h"

class BiomeDesert : public Biome {
public:
    BiomeDesert(BiomeProperties properties) : Biome(properties) {
        topBlock = g_blocks.SAND;
        topBlock = g_blocks.SAND;
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeEnd.h"
#pragma once
#include "../Biome.h"

class BiomeEnd : public Biome {
public:
    BiomeEnd(BiomeProperties properties) : Biome(properties) {
        topBlock = g_blocks.DIRT;
        fillerBlock = g_blocks.DIRT;
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeForest.h"
#pragma once
#include "../Biome.h"

class BiomeForest : public Biome {
public:
    enum Type {
        NORMAL,
        FLOWER,
        BIRCH,
        ROOFED
    };

    BiomeForest::Type type_;

    BiomeForest(BiomeForest::Type biomeType, BiomeProperties properties) : Biome(properties), type_(biomeType) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeForestMutated.h"
#pragma once
#include "../Biome.h"
#include "BiomeForest.h"

class BiomeForestMutated : public BiomeForest {
public:
    BiomeForestMutated(BiomeProperties properties) : BiomeForest(BiomeForest::Type::BIRCH, properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeHell.h"
#pragma once
#include "../Biome.h"

class BiomeHell : public Biome {
public:
    BiomeHell(BiomeProperties properties) : Biome(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeHills.h"
#pragma once
#include "../Biome.h"

class BiomeHills : public Biome {
public:
    
    enum Type {
        NORMAL,
        EXTRA_TREES,
        MUTATED
    };

    BiomeHills::Type type_;

    BiomeHills(BiomeHills::Type biomeType, BiomeProperties properties) : Biome(properties), type_(biomeType) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) override {
        topBlock = g_blocks.GRASS;
        fillerBlock = g_blocks.DIRT;

        if ((noiseVal < -1.0 || noiseVal > 2.0) && type_ == BiomeHills::Type::MUTATED)
        {
            topBlock = g_blocks.GRAVEL;
            fillerBlock = g_blocks.GRAVEL;
        }
        else if (noiseVal > 1.0 && type_ != BiomeHills::Type::EXTRA_TREES)
        {
            topBlock = g_blocks.STONE;
            fillerBlock = g_blocks.STONE;
        }

        generateBiomeTerrain(rand, chunk, x, z, noiseVal, settings_);
    }

    
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeJungle.h"
#pragma once
#include "../Biome.h"

class BiomeJungle : public Biome {
public:
    bool is_edge_ = false;

    BiomeJungle(bool isEdgeIn, BiomeProperties properties) : Biome(properties), is_edge_(isEdgeIn) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeMesa.h"
#pragma once
#include "../Biome.h"
#include <cmath>

class BiomeMesa : public Biome {
private:
    std::vector<BlockID> clay_bands_;
    long world_seed_ = 0;
    std::unique_ptr<NoiseGeneratorPerlin> pillar_noise_;
    std::unique_ptr<NoiseGeneratorPerlin> pillar_roof_noise_;
    std::unique_ptr<NoiseGeneratorPerlin> clay_bands_offset_noise_;
    bool bryce_pillars_;

public:
    bool has_forest_ = false;

    BiomeMesa(bool brycePillarsIn, bool hasForestIn, BiomeProperties properties) : 
        Biome{ properties },
        bryce_pillars_{ brycePillarsIn },
        has_forest_{ hasForestIn } {

        topBlock = g_blocks.RED_SAND;
        fillerBlock = g_blocks.TERRACOTTA; //STAINED_HARDEN_CLAY
    
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    void GenerateBands(long p_150619_1_)
    {
        clay_bands_.resize(64);
        for (int i = 0; i < 64; i++) clay_bands_[i] = g_blocks.TERRACOTTA;
        JavaRandom random = JavaRandom(p_150619_1_);
        clay_bands_offset_noise_ = std::make_unique<NoiseGeneratorPerlin>(random, 1);

        for (int l1 = 0; l1 < 64; ++l1)
        {
            l1 += random.NextInt(5) + 1;

            if (l1 < 64)
            {
                clay_bands_[l1] = g_blocks.ORANGE_TERRACOTTA;
            }
        }

        int i2 = random.NextInt(4) + 2;

        for (int i = 0; i < i2; ++i)
        {
            int j = random.NextInt(3) + 1;
            int k = random.NextInt(64);

            for (int l = 0; k + l < 64 && l < j; ++l)
            {
                clay_bands_[k + l] = g_blocks.YELLOW_TERRACOTTA;
            }
        }

        int j2 = random.NextInt(4) + 2;

        for (int k2 = 0; k2 < j2; ++k2)
        {
            int i3 = random.NextInt(3) + 2;
            int l3 = random.NextInt(64);

            for (int i1 = 0; l3 + i1 < 64 && i1 < i3; ++i1)
            {
                clay_bands_[l3 + i1] = g_blocks.BROWN_TERRACOTTA;
            }
        }

        int l2 = random.NextInt(4) + 2;

        for (int j3 = 0; j3 < l2; ++j3)
        {
            int i4 = random.NextInt(3) + 1;
            int k4 = random.NextInt(64);

            for (int j1 = 0; k4 + j1 < 64 && j1 < i4; ++j1)
            {
                clay_bands_[k4 + j1] = g_blocks.RED_TERRACOTTA;
            }
        }

        int k3 = random.NextInt(3) + 3;
        int j4 = 0;

        for (int l4 = 0; l4 < k3; ++l4)
        {
            //int i5 = 1;
            j4 += random.NextInt(16) + 4;

            for (int k1 = 0; j4 + k1 < 64 && k1 < 1; ++k1)
            {
                clay_bands_[j4 + k1] = g_blocks.WHITE_TERRACOTTA;

                if (j4 + k1 > 1 && random.NextBoolean())
                {
                    clay_bands_[j4 + k1 - 1] = g_blocks.GRAY_TERRACOTTA; //silver terracotta
                }

                if (j4 + k1 < 63 && random.NextBoolean())
                {
                    clay_bands_[j4 + k1 + 1] = g_blocks.GRAY_TERRACOTTA;
                }
            }
        }
    }

    BlockID GetBand(int p_180629_1_, int p_180629_2_, int p_180629_3_)
    {
        (void)p_180629_3_;
        int i = (int)std::round(clay_bands_offset_noise_->getValue((double)p_180629_1_ / 512.0, (double)p_180629_1_ / 512.0) * 2.0);
        return clay_bands_[(p_180629_2_ + i + 64) % 64];
    }

    void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) override { //doiuble check this again later
        if (clay_bands_.size() == 0 || world_seed_ != -1587754402)
        {
            GenerateBands(-1587754402); //world seed here
        }

        if (pillar_noise_ == nullptr || pillar_roof_noise_ == nullptr || world_seed_ != -1587754402)
        {
            JavaRandom random = JavaRandom(world_seed_);
            pillar_noise_ = std::make_unique<NoiseGeneratorPerlin>(random, 4);
            pillar_roof_noise_ = std::make_unique<NoiseGeneratorPerlin>(random, 1);
        }

        world_seed_ = -1587754402;
        double d4 = 0.0;

        if (bryce_pillars_)
        {
            int i = (x & -16) + (z & 15);
            int j = (z & -16) + (x & 15);
            double d0 = std::min(abs(noiseVal), pillar_noise_->getValue((double)i * 0.25, (double)j * 0.25));

            if (d0 > 0.0)
            {
                // double d1 = 0.001953125;
                double d2 = std::abs(pillar_roof_noise_->getValue((double)i * 0.001953125, (double)j * 0.001953125));
                d4 = d0 * d0 * 2.5;
                double d3 = ceil(d2 * 50.0) + 14.0;

                if (d4 > d3)
                {
                    d4 = d3;
                }

                d4 = d4 + 64.0;
            }
        }

        int k1 = x & 15;
        int l1 = z & 15;
        int i2 = settings_->seaLevel;
        BlockID iblockstate = g_blocks.WHITE_TERRACOTTA;
        BlockID iblockstate3 = fillerBlock;
        int k = (int)(noiseVal / 3.0 + 3.0 + rand.NextDouble() * 0.25);
        bool flag = cos(noiseVal / 3.0 * 3.14159) > 0.0;
        int l = -1;
        bool flag1 = false;
        int i1 = 0;

        for (int j1 = 255; j1 >= 0; --j1)
        {
            if (chunk->GetBlockUnsafe(l1, j1, k1) == g_blocks.AIR && j1 < (int)d4)
            {
                chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.STONE);
            }

            if (j1 <= rand.NextInt(5))
            {
                chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.BEDROCK);
            }
            else if (i1 < 15 || bryce_pillars_)
            {
                BlockID iblockstate1 = chunk->GetBlockUnsafe(l1, j1, k1);

                if (iblockstate1 == g_blocks.AIR)
                {
                    l = -1;
                }
                else if (iblockstate1 == g_blocks.STONE)
                {
                    if (l == -1)
                    {
                        flag1 = false;

                        if (k <= 0)
                        {
                            iblockstate = g_blocks.AIR;
                            iblockstate3 = g_blocks.STONE;
                        }
                        else if (j1 >= i2 - 4 && j1 <= i2 + 1)
                        {
                            iblockstate = g_blocks.WHITE_TERRACOTTA;
                            iblockstate3 = fillerBlock;
                        }

                        if (j1 < i2 && (iblockstate == g_blocks.AIR))
                        {
                            iblockstate = g_blocks.WATER;
                        }

                        l = k + std::max(0, j1 - i2);

                        if (j1 >= i2 - 1)
                        {
                            if (has_forest_ && j1 > 86 + k * 2)
                            {
                                if (flag)
                                {
                                    chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.COARSE_DIRT);
                                }
                                else
                                {
                                    chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.GRASS);
                                }
                            }
                            else if (j1 > i2 + 3 + k)
                            {
                                BlockID iblockstate2;

                                if (j1 >= 64 && j1 <= 127)
                                {
                                    if (flag)
                                    {
                                        iblockstate2 = g_blocks.TERRACOTTA;
                                    }
                                    else
                                    {
                                        iblockstate2 = GetBand(x, j1, z);
                                    }
                                }
                                else
                                {
                                    iblockstate2 = g_blocks.ORANGE_TERRACOTTA;
                                }

                                chunk->SetBlockUnsafe(l1, j1, k1, iblockstate2);
                            }
                            else
                            {
                                chunk->SetBlockUnsafe(l1, j1, k1, topBlock);
                                flag1 = true;
                            }
                        }
                        else
                        {
                            chunk->SetBlockUnsafe(l1, j1, k1, iblockstate3);

                            if (iblockstate3 == g_blocks.WHITE_TERRACOTTA)
                            {
                                chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.ORANGE_TERRACOTTA);
                            }
                        }
                    }
                    else if (l > 0)
                    {
                        --l;

                        if (flag1)
                        {
                            chunk->SetBlockUnsafe(l1, j1, k1, g_blocks.ORANGE_TERRACOTTA);
                        }
                        else
                        {
                            chunk->SetBlockUnsafe(l1, j1, k1, GetBand(x, j1, z));
                        }
                    }

                    ++i1;
                }
            }
        }
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeMushroomIsland.h"
#pragma once
#include "../Biome.h"

class BiomeMushroomIsland : public Biome {
public:
    BiomeMushroomIsland(BiomeProperties properties) : Biome(properties) {
        topBlock = g_blocks.MYCELIUM;
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeOcean.h"
#pragma once

#include "../Biome.h"

class BiomeOcean : public Biome {
public:
    BiomeOcean(BiomeProperties p) : Biome(p) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    Biome::TempCategory getTempCategory() override {
        return Biome::TempCategory::OCEAN;
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomePlains.h"
#pragma once
#include "../Biome.h"

class BiomePlains : public Biome {
public:
    bool sunglowers = false;

    BiomePlains(bool sunflowersIn, BiomeProperties p) : Biome(p), sunglowers(sunflowersIn) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeRiver.h"
#pragma once
#include "../Biome.h"

class BiomeRiver : public Biome {
public:
    BiomeRiver(BiomeProperties properties) : Biome(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeSavanna.h"
#pragma once
#include "../Biome.h"

class BiomeSavanna : public Biome {
public:
    BiomeSavanna(BiomeProperties properties) : Biome(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeSavannaMutated.h"
#pragma once
#include "../Biome.h"

class BiomeSavannaMutated : public BiomeSavanna {
public:
    BiomeSavannaMutated(BiomeProperties properties) : BiomeSavanna(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) override
    {
        topBlock = g_blocks.GRASS;
        fillerBlock = g_blocks.DIRT;

        if (noiseVal > 1.75)
        {
            topBlock = g_blocks.STONE;
            fillerBlock = g_blocks.STONE;
        }
        else if (noiseVal > -0.5)
        {
            topBlock = g_blocks.COARSE_DIRT;
        }

        generateBiomeTerrain(rand, chunk, x, z, noiseVal, settings_);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeSnow.h"
#pragma once
#include "../Biome.h"

class BiomeSnow : public Biome {
public:
    bool superIcy = false;

    BiomeSnow(bool superIcyIn, BiomeProperties properties) : Biome(properties), superIcy(superIcyIn) {
        if (superIcyIn) {
            topBlock = g_blocks.SNOW_BLOCK;
        }
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeStoneBeach.h"
#pragma once
#include "../Biome.h"

class BiomeStoneBeach : public Biome {
public:
    BiomeStoneBeach(BiomeProperties properties) : Biome(properties) {
        topBlock = g_blocks.STONE;
        fillerBlock = g_blocks.STONE;
    }

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeSwamp.h"
#pragma once
#include "../Biome.h"

class BiomeSwamp : public Biome {
public:
    BiomeSwamp(BiomeProperties properties) : Biome(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) override
    {
        double d0 = GRASS_COLOR_NOISE.getValue((double)x * 0.25, (double)z * 0.25);

        if (d0 > 0.0)
        {
            int i = x & 15;
            int j = z & 15;

            for (int k = 255; k >= 0; --k)
            {
                if (GetBlockChunkSafe(chunk, j, k, i) != g_blocks.AIR)
                {
                    if (k == 62 && GetBlockChunkSafe(chunk, j, k, i) != g_blocks.WATER)
                    {
                        SetBlockChunkSafe(chunk, g_blocks.WATER, j, k, i);

                        //if (d0 < 0.12)
                        //{
                        //    chunk.setBlockState(j, k + 1, i, WATER_LILY);
                        //}
                    }

                    break;
                }
            }
        }

        generateBiomeTerrain(rand, chunk, x, z, noiseVal, settings_);
    }
};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeTaiga.h"
#pragma once
#include "../Biome.h"

class BiomeTaiga : public Biome {
public:
    enum Type {
        NORMAL,
        MEGA,
        MEGA_SPRUCE
    };

    BiomeTaiga::Type type_;

    BiomeTaiga(BiomeTaiga::Type biomeType, BiomeProperties properties) : Biome(properties), type_(biomeType) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }

    void GenTerrainBlocks(JavaRandom& rand, TallChunk* chunk, int x, int z, double noiseVal, ChunkGeneratorSettings* settings_) override {
        if (type_ == BiomeTaiga::Type::MEGA || type_ == BiomeTaiga::Type::MEGA_SPRUCE)
        {
            topBlock = g_blocks.GRASS;
            fillerBlock = g_blocks.DIRT;

            if (noiseVal > 1.75)
            {
                topBlock = g_blocks.COARSE_DIRT;
            }
            else if (noiseVal > -0.95)
            {
                topBlock = g_blocks.PODZOL;
            }
        }

        generateBiomeTerrain(rand, chunk, x, z, noiseVal, settings_);
    }

};
"./Level\\TerrainGeneration\\Biome\\BiomeType\\BiomeVoid.h"
#pragma once
#include "../Biome.h"

class BiomeVoid : public Biome {
public:
    BiomeVoid(BiomeProperties properties) : Biome(properties) {}

    const std::type_info& getBiomeClass() const override {
        return typeid(*this);
    }
};
"./Level\\TerrainGeneration\\Generator.cpp"
#include "Generator.h"
#include "../Chunk/ChunkPos/ChunkPos.h"
#include "../../Utils/Clock.h"
#include "Generators/GeneratorType.h"
#include <concurrent_unordered_set.h>

std::vector<std::unique_ptr<Chunk>> ChunkGeneration::GetOutput() {
    std::vector<std::unique_ptr<Chunk>> output;
    for (auto& chunks : gen_pool_->GetOutput()) {
        output.insert(output.end(), std::make_move_iterator(chunks.begin()), std::make_move_iterator(chunks.end()));
    }

    return output;
}

void ChunkGeneration::Start(int threadCount, long long int worldSeedIn) {
    gen_pool_ = std::make_unique<ThreadPool<std::pair<ChunkPos, WorldGeneratorID>,
        std::vector<std::unique_ptr<Chunk>>,
        ChunkGeneration::Worker>>(threadCount, "World Generator", 100);

    WorldGenerator::SetSeed(worldSeedIn);
}

void ChunkGeneration::Stop() {
    gen_pool_->Stop();
}

/*
* Static function for the thread pool to use
*/
std::vector<std::unique_ptr<Chunk>> ChunkGeneration::Worker(const std::pair<ChunkPos, WorldGeneratorID>& task ) {
    //Generate
    const ChunkPos& pos = task.first;
    const WorldGeneratorID& generatorUse = task.second;
    std::vector<std::unique_ptr<Chunk>> output;

    if (!g_generators.GetGenerator(generatorUse)->use_tall_chunks_) {
        std::unique_ptr<Chunk> chunk = std::make_unique<Chunk>();
        chunk->SetPosition(pos.x, pos.y, pos.z);
        g_generators.GetGenerator(generatorUse)->Generate(pos, chunk);

        output.push_back(std::move(chunk));
    }
    else {
        std::unique_ptr<TallChunk> chunk = std::make_unique<TallChunk>();
        if (pos.y == 0) {
            g_generators.GetGenerator(generatorUse)->GenerateTall(pos, chunk);
        }
        output.insert(output.end(), std::make_move_iterator(chunk->chunk_sub_column_.begin()), std::make_move_iterator(chunk->chunk_sub_column_.end()));
    }

    return output;
}


void ChunkGeneration::Generate(ChunkPos pos, WorldGeneratorID genType) {
    gen_pool_->SubmitTask(std::pair<ChunkPos, WorldGeneratorID>(pos, genType));
}

void ChunkGeneration::Generate(std::vector<ChunkPos> ids, WorldGeneratorID genTypeIn) {
    std::vector<std::pair<ChunkPos, WorldGeneratorID>> tasks;
    for (const auto& chunkId : ids) {
        tasks.emplace_back(chunkId, genTypeIn);
    }
    gen_pool_->SubmitTask(tasks);
}
"./Level\\TerrainGeneration\\Generator.h"
#pragma once
#include "../Chunk/Chunk.h"
#include "../../Utils/FastNoiseLite.h"
#include "../TerrainGeneration/Generators/GeneratorType.h"
#include <deque>
#include <memory>
#include "../../Utils/ThreadPool.h"

class ChunkGeneration {
public:
    void Start(int ThreadCount, long long int WorldSeedIn);

    void Stop(); //Stop the threads and does some clean up

    void Generate(ChunkPos id, WorldGeneratorID genTypeIn);

    void Generate(std::vector<ChunkPos> ids, WorldGeneratorID genTypeIn);

    std::vector<std::unique_ptr<Chunk>> GetOutput();

private:
    /*
    * Worker submitting output as std::vector<Chunk*> to handle tall chunks with multiple sub chunks for now
    */
    static std::vector<std::unique_ptr<Chunk>> Worker(const std::pair<ChunkPos, WorldGeneratorID>& task);

    std::unique_ptr<ThreadPool<std::pair<ChunkPos, WorldGeneratorID>, std::vector<std::unique_ptr<Chunk>>, ChunkGeneration::Worker>> gen_pool_;

    bool stop_ = false;
    bool collect_ready_ = false;
};
"./Level\\TerrainGeneration\\Generators\\Debug\\Debug.cpp"
#include "Debug.h"
DebugWorld::DebugWorld() = default;

void DebugWorld::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    int gx = pos.x * 16;
    int gz = pos.z * 16;
    int gy = pos.y * 16;

    if (pos.y < 0) {
        return;
    }

    int numBlocks = static_cast<int>(g_blocks.block_type_data_.size());

    int RowLen = 50;
    int ColLen = 50;

    if (gy == 0) {
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {

                chunk->SetBlockUnsafe(g_blocks.WHITE_CONCRETE, x, 0, z);
            }
        }
    }
    

    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {
            for (int y = 0; y < 16; y++) {
                int px = x + gx;
                int pz = z + gz;
                int py = y + gy - 1;

                if (((px & 0b1) == 1) || ((pz & 0b1) == 1) || ((py & 0b1) == 1)) {
                    continue;
                }

                px = px / 2;
                pz = pz / 2;
                py = py / 2;

                if ((px < 0) || (px >= RowLen) || (pz < 0) || (pz >= ColLen)) {
                    continue;
                }

                int b = px + pz * RowLen + py * RowLen * ColLen;

                if ((b < numBlocks) && (b >= 0)) {
                    chunk->SetBlockUnsafe(b, x, y, z);
                }
            }
        }
    }
}
"./Level\\TerrainGeneration\\Generators\\Debug\\Debug.h"
#pragma once
#include "../Generator.h"

class DebugWorld : public WorldGenerator {
public:
    DebugWorld();

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;
};
"./Level\\TerrainGeneration\\Generators\\DebugPositioning\\DebugPositioning.cpp"
#include "DebugPositioning.h"
DebugPositioning::DebugPositioning() = default;

void DebugPositioning::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    // Red -> x
    ChunkPos newPos = chunk->position_;
    for (int i = 0; i < 16; ++i) {
        if (newPos.x & 1)
            chunk->SetBlockUnsafe(g_blocks.RED_WOOL, i, 0, 0);
        if (newPos.y & 1)
            chunk->SetBlockUnsafe(g_blocks.GREEN_WOOL, i, 1, 0);
        if (newPos.z & 1)
            chunk->SetBlockUnsafe(g_blocks.BLUE_WOOL, i, 2, 0);

        newPos.x >>= 1;
        newPos.y >>= 1;
        newPos.z >>= 1;
    }

    chunk->SetBlockUnsafe(g_blocks.RED_WOOL, 1, 4, 0);
    chunk->SetBlockUnsafe(g_blocks.GREEN_WOOL, 0, 5, 0);
    chunk->SetBlockUnsafe(g_blocks.BLUE_WOOL, 0, 4, 1);

    chunk->SetBlockUnsafe(g_blocks.GOLD_BLOCK, 0, 3, 0);
    chunk->SetBlockUnsafe(g_blocks.EMERALD_BLOCK, 15, 3, 0);

    for (int i = 1; i < 15; ++i) {
        if (i & 1) {
            chunk->SetBlockUnsafe(g_blocks.BLACK_CONCRETE, i, 3, 0);
        }
        else {
            chunk->SetBlockUnsafe(g_blocks.WHITE_CONCRETE, i, 3, 0);
        }
    }
}
"./Level\\TerrainGeneration\\Generators\\DebugPositioning\\DebugPositioning.h"
#pragma once
#include "../Generator.h"

class DebugPositioning : public WorldGenerator {
public:
    DebugPositioning();

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;
};
"./Level\\TerrainGeneration\\Generators\\DebugSecond\\DebugSecond.cpp"
#include "DebugSecond.h"
DebugWorldSecond::DebugWorldSecond() = default;

void DebugWorldSecond::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    chunk->SetBlock(g_blocks.COBBLESTONE, 8, 8, 8);

    ChunkPos scaledPos = pos;

    scaledPos.set(pos.x * 16, pos.y * 16, pos.z * 16);

    for (int gx = 0; gx < 16; gx++) {
        for (int gy = 0; gy < 16; gy++) {
            for (int gz = 0; gz < 16; gz++) {

                int index = gz * 256 + gy * 16 + gx;


                if (index % 5) {
                    continue;
                }

                int x = gx + scaledPos.x;
                int y = gy + scaledPos.y;
                int z = gz + scaledPos.z;

                if ((abs(x) >= abs(z)) && (abs(x) >= abs(y))) {
                    chunk->SetBlock(g_blocks.BLUE_STAINED_GLASS, gx, gy, gz);
                }
                if ((abs(z) >= abs(x)) && (abs(z) >= abs(y))) {
                    chunk->SetBlock(g_blocks.DARK_OAK_PLANKS, gx, gy, gz);
                }
                if ((abs(y) >= abs(x)) && (abs(y) >= abs(z))) {
                    chunk->SetBlock(g_blocks.ORANGE_CONCRETE, gx, gy, gz);
                }
            }
        }
    }
}
"./Level\\TerrainGeneration\\Generators\\DebugSecond\\DebugSecond.h"
#pragma once
#include "../Generator.h"

class DebugWorldSecond : public WorldGenerator {
public:
    DebugWorldSecond();

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;
};
"./Level\\TerrainGeneration\\Generators\\FastTerrain\\FastTerrain.cpp"
#include "FastTerrain.h"
#include "../../../../Utils/FastNoiseLite.h"

FastTerrain::FastTerrain() :noise_{std::make_unique<FastNoiseLite>()} {
    noise_->SetNoiseType(noise_->NoiseType_OpenSimplex2);
    noise_->SetFrequency(0.009f);
}

void FastTerrain::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    int cx = pos.x * 16;
    int cy = pos.y * 16;
    int cz = pos.z * 16;

    long long SEED = WorldGenerator::world_seed_;

    for (int x = 0 + cx; x < 16 + cx; x++) {
        for (int z = 0 + cz; z < 16 + cz; z++) {

            float BIOME_MAP = (float)(noise_->GetNoise((float)x / 600, (float)z / 600, (float)SEED) + 1) / 2;
            float TREE_MAP = (float)((double)(noise_->GetNoise((float)x * 10, (float)z * 10, (float)SEED) + 1) / 2) * (BIOME_MAP * 2);
            float MIN_BIOME_MAP = (float)((noise_->GetNoise((float)x / 60, (float)z / 60, (float)SEED) + 1)) * 2;
            float TEMP_MAP = (float)(noise_->GetNoise((float)x / 1000, (float)z / 1000, (float)SEED) + 1) * 2;
            float HEIGHT_MAP = (float)(((noise_->GetNoise((float)x, (float)z, (float)SEED) + 1) * 3) * (((noise_->GetNoise((float)x * 5, (float)z * 5, (float)SEED) + 1) * .25) * BIOME_MAP)) * 30;
            int a = (int)pow(((BIOME_MAP * HEIGHT_MAP + 5) * TEMP_MAP - 10) / (2 * MIN_BIOME_MAP), 1.6) + 5;
            for (int y = 0 + cy; y < 16 + cy; y++) {
                if ((a == y || a + 1 == y || a + 2 == y || a + 3 == y || a + 4 == y) && a > 10) {
                    if (TREE_MAP >= (TREE_RAND_VAL - TREE_RAND_VAL_RANGE) && TREE_MAP <= (TREE_RAND_VAL + TREE_RAND_VAL_RANGE)) {
                        chunk->SetBlock(g_blocks.OAK_LOG, x - cx, y - cy, z - cz);

                    }
                }
                if (a + 5 == y && a > 10) {
                    if (TREE_MAP >= (TREE_RAND_VAL - TREE_RAND_VAL_RANGE) && TREE_MAP <= (TREE_RAND_VAL + TREE_RAND_VAL_RANGE)) {
                        for (int tx = -2; tx <= 2; tx++) {
                            for (int ty = -2; ty <= 2; ty++) {
                                for (int tz = -2; tz <= 2; tz++) {
                                    chunk->SetBlock(g_blocks.OAK_LEAF, x + tx - cx, y + ty - cy, z + tz - cz);
                                }
                            }
                        }

                    }
                }

                if (y < 10) {
                    chunk->SetBlockUnsafe(g_blocks.WATER, x - cx, y - cy, z - cz);
                }

                if (a > y) {
                    if (y < 12) {
                        chunk->SetBlockUnsafe(g_blocks.SAND, x - cx, y - cy, z - cz);
                    }
                    else {

                        if (a >= y) {
                            chunk->SetBlockUnsafe(g_blocks.GRASS, x - cx, y - cy, z - cz);
                            chunk->is_empty_ = false;
                        }
                        if (a - 1 > y) {
                            chunk->SetBlockUnsafe(g_blocks.DIRT, x - cx, y - cy, z - cz);
                        }



                    }

                }


            }

        }
    }
}
"./Level\\TerrainGeneration\\Generators\\FastTerrain\\FastTerrain.h"
#pragma once
#include "../Generator.h"
#include <memory>

class FastNoiseLite;

class FastTerrain : public WorldGenerator {
public:
    FastTerrain();
    
    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;

    std::unique_ptr<FastNoiseLite> noise_;

    static constexpr double TREE_RAND_VAL = 0.5;
    static constexpr double TREE_RAND_VAL_RANGE = .01f;
};
"./Level\\TerrainGeneration\\Generators\\Generator.cpp"
#include "Generator.h"
"./Level\\TerrainGeneration\\Generators\\Generator.h"
#pragma once
#include "../../Chunk/Chunk.h"
#include "../../Chunk/TallChunk.h"
#include <glm/vec3.hpp>

// TODO: Fix me later

class WorldGenerator {
public:
    WorldGenerator() {

    }

    static void SetSeed(long long worldSeedIn) {
        WorldGenerator::world_seed_ = worldSeedIn;
    }

    virtual void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
        (void)pos;
        (void)chunk;
        throw std::exception("Don't use");
    }
    // TODO: Use custom tall chunk positioning
    virtual void GenerateTall(const ChunkPos& pos, std::unique_ptr<TallChunk>& chunk) {
        (void)pos;
        (void)chunk;
        throw std::exception("Don't use");
    }

    bool use_tall_chunks_ = false;

    static long long world_seed_;
};

inline long long WorldGenerator::world_seed_ = -1587754402;
"./Level\\TerrainGeneration\\Generators\\Generators.h"
#pragma once
#include "Debug/Debug.h"
#include "DebugSecond/DebugSecond.h"
#include "FastTerrain/FastTerrain.h"
#include "Math/MathWorld.h"
#include "Mountains/Mountains.h"
#include "Superflat/Superflat.h"
#include "Minecraft/MinecraftTerrain.h"
#include "DebugPositioning/DebugPositioning.h"
"./Level\\TerrainGeneration\\Generators\\GeneratorType.cpp"
#include "GeneratorType.h"

WorldGeneratorID GeneratorType::RegisterWorldGenerator(WorldGenerator* Gen) {
    generator_list_.push_back(Gen);
    g_logger.LogInfo("GeneratorType::RegisterWorldGenerator", "Registered Generator: " + std::to_string(generator_list_.size() - 1));
    return generator_list_.size() - 1;
}

WorldGenerator* GeneratorType::GetGenerator(WorldGeneratorID ID) {
    return generator_list_[ID];
}
"./Level\\TerrainGeneration\\Generators\\GeneratorType.h"
#pragma once
#include "Generators.h"
#include <vector>
#include "../../../Utils/LogUtils.h"


class GeneratorType {
private:

    std::vector<WorldGenerator*> generator_list_ = {};

    WorldGeneratorID RegisterWorldGenerator(WorldGenerator* Gen);

public:
    WorldGeneratorID DEBUG = RegisterWorldGenerator(new DebugWorld());
    WorldGeneratorID DEBUG_2 = RegisterWorldGenerator(new DebugWorldSecond());
    WorldGeneratorID DEBUG_POSITIONING = RegisterWorldGenerator(new DebugPositioning());
    WorldGeneratorID FAST_TERRAIN = RegisterWorldGenerator(new FastTerrain());
    WorldGeneratorID MATH_WORLD = RegisterWorldGenerator(new MathWorld());
    WorldGeneratorID MOUNTAINS = RegisterWorldGenerator(new MountainGenerator());
    WorldGeneratorID SUPERFLAT = RegisterWorldGenerator(new SuperflatWorld());
    WorldGeneratorID MINECRAFT = RegisterWorldGenerator(new MinecraftTerrain());

    WorldGenerator* GetGenerator(WorldGeneratorID ID);
};

extern GeneratorType g_generators;
"./Level\\TerrainGeneration\\Generators\\Math\\MainWorld.cpp"
#include "MathWorld.h"
MathWorld::MathWorld() = default;

void MathWorld::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    int cx = pos.x * 16;
    int cy = pos.y * 16;
    int cz = pos.z * 16;
    float zoom = 20.f;

    for (int x = 0; x < 16; x++) {
        for (int y = 0; y < 16; y++) {
            for (int z = 0; z < 16; z++) {

                if ((chunk->GetBlock(x, y, z) == g_blocks.RED_STAINED_GLASS) || (chunk->GetBlock(x, y, z) == g_blocks.BLACK_STAINED_GLASS))
                    continue;

                glm::vec3 globalPos(cx + x, cy + y, cz + z);


                float gx = globalPos.x / zoom;
                float gy = globalPos.y / zoom;
                float gz = globalPos.z / zoom;

                //if (0 < gx * gx - gy * gy - gz) {

                //    SetBlock(Blocks.WHITE_CONCRETE, x, y, z);
                //}

                //if (gy > 3 * gz * gz - gx * gx + 2) {
                //    SetBlock(Blocks.WHITE_CONCRETE, x, y, z);
                //}

                if (gz * gz + gy * gy > 4) {
                    chunk->SetBlock(g_blocks.BRICKS, x, y, z);
                }

                int Unit = 1;
                int UnitSize = 5;

                if (gx == 0 && gy == 0) {
                    if (((int)globalPos.z % (Unit * (int)zoom)) == 0) {
                        for (int i = -UnitSize; i <= UnitSize; i++) {
                            for (int j = -UnitSize; j <= UnitSize; j++) {
                                chunk->SetBlock(g_blocks.RED_STAINED_GLASS, x + j, y + i, z);
                            }
                        }
                    }
                    else {
                        chunk->SetBlock(g_blocks.BLACK_STAINED_GLASS, x, y, z);
                    }

                }
                if (gz == 0 && gy == 0) {
                    if (((int)globalPos.x % (Unit * (int)zoom)) == 0) {
                        for (int i = -UnitSize; i <= UnitSize; i++) {
                            for (int j = -UnitSize; j <= UnitSize; j++) {
                                chunk->SetBlock(g_blocks.RED_STAINED_GLASS, x, y + i, z + j);
                            }
                        }
                    }
                    else {
                        chunk->SetBlock(g_blocks.BLACK_STAINED_GLASS, x, y, z);
                    }
                }
                if (gz == 0 && gx == 0) {
                    if (((int)globalPos.y % (Unit * (int)zoom)) == 0) {
                        for (int i = -UnitSize; i <= UnitSize; i++) {
                            for (int j = -UnitSize; j <= UnitSize; j++) {
                                chunk->SetBlock(g_blocks.RED_STAINED_GLASS, x + i, y, z + j);
                            }
                        }
                    }
                    else {
                        chunk->SetBlock(g_blocks.BLACK_STAINED_GLASS, x, y, z);
                    }
                }

            }
        }
    }
}
"./Level\\TerrainGeneration\\Generators\\Math\\MathWorld.h"
#pragma once
#include "../Generator.h"

class MathWorld : public WorldGenerator {
public:
    MathWorld();

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;
};
"./Level\\TerrainGeneration\\Generators\\Minecraft\\MinecraftTerrain.cpp"
#include "MinecraftTerrain.h"
#include "../../Noisemaps/Noisemap.h"
#include "../../Noisemaps/TerrainParameters.h"
#include "Overworld.h"
#include "../../Biome/BiomeProvider.h"

MinecraftTerrain::MinecraftTerrain() :
    noisemaps_{ std::make_unique<NoiseMaps1122>() },
    parameters_{ std::make_unique<TerrainParamters>() },
    settings_{std::make_unique<ChunkGeneratorSettings>()}
{
    use_tall_chunks_ = true;
}

glm::vec3 MinecraftTerrain::VecFloor(glm::vec3 v) {
    return glm::vec3(floor(v.x), floor(v.y), floor(v.z));
}

void MinecraftTerrain::GenerateTall(const ChunkPos& pos, std::unique_ptr<TallChunk>& chunk) {
    OverworldGenerator overworldGenerator = OverworldGenerator(WorldGenerator::world_seed_, *settings_);
    chunk->SetPosition(pos.x, pos.y, pos.z);
    
    overworldGenerator.GenerateChunk(pos.x, pos.z, chunk.get());
}

void MinecraftTerrain::Init() {
    
    return;
}
"./Level\\TerrainGeneration\\Generators\\Minecraft\\MinecraftTerrain.h"
#pragma once
#include <memory>
#include <glm/vec3.hpp>

#include "../Generator.h"


class NoiseMaps1122;

struct TerrainParamters;
struct ChunkGeneratorSettings;

class MinecraftTerrain : public WorldGenerator {
public:
    MinecraftTerrain();

    void GenerateTall(const ChunkPos& pos, std::unique_ptr <TallChunk>& chunk) override;

private:
    void Init();

    std::unique_ptr<NoiseMaps1122> noisemaps_;
    std::unique_ptr<TerrainParamters> parameters_;
    std::unique_ptr<ChunkGeneratorSettings> settings_;

    //double* heightMap;

    //bool isInitialized = false;

    glm::vec3 VecFloor(glm::vec3 v);
};
"./Level\\TerrainGeneration\\Generators\\Minecraft\\Overworld.cpp"
#include "Overworld.h"
#include "../../Biome/BiomeProvider.h"

void OverworldGenerator::GenerateChunk(int x, int z, TallChunk* chunk) {
    rand.SetSeed((long long)x * 341873128712LL + (long long)z * 132897987541LL);
    setBlocksInChunk(x, z, chunk);
    biomesForGeneration = BiomeProvider::getBiomes(x * 16, z * 16, 16, 16);
    replaceBiomeBlocks(x, z, chunk, biomesForGeneration);
}

void OverworldGenerator::replaceBiomeBlocks(int x, int z, TallChunk* chunk, std::vector<Biome*> biomesIn) {
    depthBuffer = surfaceNoise.getRegion(depthBuffer, (double)(x * 16), (double)(z * 16), 16, 16, 0.0625, 0.0625, 1.0);

    for (int i = 0; i < 16; ++i)
    {
        for (int j = 0; j < 16; ++j)
        {
            Biome* biome = biomesIn[j + i * 16];
            biome->GenTerrainBlocks(rand, chunk, x * 16 + i, z * 16 + j, depthBuffer[j + i * 16], &settings_);
        }
    }
}

void OverworldGenerator::generateHeightmap(int x, int y, int z) {
    depthRegion = depthNoise.generateNoiseOctaves(depthRegion, x, z, 5, 5, settings_.depthNoiseScaleX, settings_.depthNoiseScaleZ, settings_.depthNoiseScaleExponent);
    float f = settings_.coordinateScale;
    float f1 = settings_.stretchY;
    mainNoiseRegion = mainPerlinNoise.generateNoiseOctaves(mainNoiseRegion, x, y, z, 5, 33, 5, (double)(f / settings_.mainNoiseScaleX), (double)(f1 / settings_.mainNoiseScaleY), (double)(f / settings_.mainNoiseScaleZ));
    minLimitRegion = minLimitPerlinNoise.generateNoiseOctaves(minLimitRegion, x, y, z, 5, 33, 5, (double)f, (double)f1, (double)f);
    maxLimitRegion = maxLimitPerlinNoise.generateNoiseOctaves(maxLimitRegion, x, y, z, 5, 33, 5, (double)f, (double)f1, (double)f);
    int i = 0;
    int j = 0;

    for (int k = 0; k < 5; ++k)
    {
        for (int l = 0; l < 5; ++l)
        {
            float f2 = 0.0F;
            float f3 = 0.0F;
            float f4 = 0.0F;
            //int i1 = 2;
            Biome* biome = biomesForGeneration[k + 2 + (l + 2) * 10];

            for (int j1 = -2; j1 <= 2; ++j1)
            {
                for (int k1 = -2; k1 <= 2; ++k1)
                {
                    Biome* biome1 = biomesForGeneration[k + j1 + 2 + (l + k1 + 2) * 10];
                    float f5 = settings_.biomeDepthOffset + biome1->getBaseHeight() * settings_.biomeDepthWeight;
                    float f6 = settings_.biomeScaleOffset + biome1->getHeightVariation() * settings_.biomeScaleWeight;

                    float f7 = biomeWeights[j1 + 2 + (k1 + 2) * 5] / (f5 + 2.0F);

                    if (biome1->getBaseHeight() > biome->getBaseHeight())
                    {
                        f7 /= 2.0F;
                    }

                    f2 += f6 * f7;
                    f3 += f5 * f7;
                    f4 += f7;
                }
            }

            f2 = f2 / f4;
            f3 = f3 / f4;
            f2 = f2 * 0.9F + 0.1F;
            f3 = (f3 * 4.0F - 1.0F) / 8.0F;
            double d7 = depthRegion[j] / 8000.0;
            if (d7 < 0.0)
            {
                d7 = -d7 * 0.3;
            }

            d7 = d7 * 3.0 - 2.0;

            if (d7 < 0.0)
            {
                d7 = d7 / 2.0;

                if (d7 < -1.0)
                {
                    d7 = -1.0;
                }

                d7 = d7 / 1.4;
                d7 = d7 / 2.0;
            }
            else
            {
                if (d7 > 1.0)
                {
                    d7 = 1.0;
                }

                d7 = d7 / 8.0;
            }

            ++j;
            double d8 = (double)f3;
            double d9 = (double)f2;
            d8 = d8 + d7 * 0.2;
            d8 = d8 * (double)settings_.baseSize / 8.0;
            double d0 = (double)settings_.baseSize + d8 * 4.0;

            for (int l1 = 0; l1 < 33; ++l1)
            {
                double d1 = ((double)l1 - d0) * (double)settings_.stretchY * 128.0 / 256.0 / d9;

                if (d1 < 0.0)
                {
                    d1 *= 4.0;
                }

                double d2 = minLimitRegion[i] / (double)settings_.lowerLimitScale;
                double d3 = maxLimitRegion[i] / (double)settings_.upperLimitScale;
                double d4 = (mainNoiseRegion[i] / 10.0 + 1.0) / 2.0;
                double d5 = clampedLerp(d2, d3, d4) - d1;

                if (l1 > 29)
                {
                    double d6 = (double)((float)(l1 - 29) / 3.0F);
                    d5 = d5 * (1.0 - d6) + -10.0 * d6;
                }

                heightMap[i] = d5;
                ++i;
            }
        }
    }
}


void OverworldGenerator::setBlocksInChunk(int x, int z, TallChunk* chunk) {
    biomesForGeneration = BiomeProvider::getBiomesForGeneration(x * 4 - 2, z * 4 - 2, 10, 10);
    generateHeightmap(x * 4, 0, z * 4);

    for (int i = 0; i < 4; ++i)
    {
        int j = i * 5;
        int k = (i + 1) * 5;

        for (int l = 0; l < 4; ++l)
        {
            int i1 = (j + l) * 33;
            int j1 = (j + l + 1) * 33;
            int k1 = (k + l) * 33;
            int l1 = (k + l + 1) * 33;

            for (int i2 = 0; i2 < 32; ++i2)
            {
                //double d0 = 0.125;
                double d1 = heightMap[i1 + i2];
                double d2 = heightMap[j1 + i2];
                double d3 = heightMap[k1 + i2];
                double d4 = heightMap[l1 + i2];
                double d5 = (heightMap[i1 + i2 + 1] - d1) * 0.125;
                double d6 = (heightMap[j1 + i2 + 1] - d2) * 0.125;
                double d7 = (heightMap[k1 + i2 + 1] - d3) * 0.125;
                double d8 = (heightMap[l1 + i2 + 1] - d4) * 0.125;

                for (int j2 = 0; j2 < 8; ++j2)
                {
                    //double d9 = 0.25;
                    double d10 = d1;
                    double d11 = d2;
                    double d12 = (d3 - d1) * 0.25;
                    double d13 = (d4 - d2) * 0.25;

                    for (int k2 = 0; k2 < 4; ++k2)
                    {
                        //double d14 = 0.25;
                        double d16 = (d11 - d10) * 0.25;
                        double lvt_45_1_ = d10 - d16;

                        for (int l2 = 0; l2 < 4; ++l2)
                        {
                            if ((lvt_45_1_ += d16) > 0.0)
                            {
                                int genHeight = i2 * 8 + j2;
                                chunk->SetBlockUnsafe(i * 4 + k2, genHeight, l * 4 + l2, g_blocks.STONE);
                            }
                            else if (i2 * 8 + j2 < settings_.seaLevel) {
                                int genHeight = i2 * 8 + j2;
                                chunk->SetBlockUnsafe(i * 4 + k2, genHeight, l * 4 + l2, g_blocks.WATER);
                            }
                        }

                        d10 += d12;
                        d11 += d13;
                    }

                    d1 += d5;
                    d2 += d6;
                    d3 += d7;
                    d4 += d8;
                }
            }
        }
    }
}



double OverworldGenerator::clampedLerp(double lowerBnd, double upperBnd, double slide) {
    if (slide < 0.0) {
        return lowerBnd;
    } else {
        return slide > 1.0 ? upperBnd : lowerBnd + (upperBnd - lowerBnd) * slide;
    }
}
"./Level\\TerrainGeneration\\Generators\\Minecraft\\Overworld.h"
#pragma once
#include "../../Random/JavaRandom.h"
#include "../../Noisemaps/NoiseOctave.h"
#include "../../Noisemaps/MinecraftNoiseGeneratorPerlin.h"
#include "../../Noisemaps/TerrainParameters.h"
#include "../../../Chunk/Chunk.h"
#include "../../../Chunk/TallChunk.h"
#include "../../../Chunk/Heightmap/Heightmap.h"
#include "../../../Chunk/ChunkColumn.h"
#include "../../Biome/Biome.h"

// TODO: Fix me

class OverworldGenerator {
private:

    static double clampedLerp(double lowerBnd, double upperBnd, double slide);

public:
    JavaRandom rand;
    NoiseOctave minLimitPerlinNoise;
    NoiseOctave maxLimitPerlinNoise;
    NoiseOctave mainPerlinNoise;
    NoiseGeneratorPerlin surfaceNoise;
    NoiseOctave scaleNoise;
    NoiseOctave depthNoise;
    std::vector<double> depthBuffer;
    std::vector<double> heightMap;
    std::vector<double> mainNoiseRegion;
    std::vector<double> minLimitRegion;
    std::vector<double> maxLimitRegion;
    std::vector<double> depthRegion;
    ChunkGeneratorSettings settings_;

    std::vector<float> biomeWeights;
    std::vector<Biome*> biomesForGeneration;

    OverworldGenerator(int64_t seed, ChunkGeneratorSettings setting) : 
        rand{ JavaRandom(seed) }, 
        minLimitPerlinNoise{ NoiseOctave(rand, 16) },
        maxLimitPerlinNoise{ NoiseOctave(rand, 16) }, 
        mainPerlinNoise{ NoiseOctave(rand, 8) },
        surfaceNoise{ NoiseGeneratorPerlin(rand, 4) }, 
        scaleNoise{ NoiseOctave(rand, 10) },
        depthNoise{ NoiseOctave(rand, 16) }, 
        depthBuffer{ std::vector<double>(256) },
        heightMap{ std::vector<double>(825) },
        settings_{ setting },
        biomeWeights{ std::vector<float>(25) } {

        for (int i = -2; i <= 2; ++i) {
            for (int j = -2; j <= 2; ++j) {
                float f = 10.0f / sqrtf((float)(i * i + j * j) + 0.2f);
                biomeWeights[i + 2 + (j + 2) * 5] = f;
            }
        }
    }

    void replaceBiomeBlocks(int x, int z, TallChunk* chunk, std::vector<Biome*> biomesIn);

    void GenerateChunk(int x, int z, TallChunk* chunk);

    void generateHeightmap(int x, int y, int z);

    void setBlocksInChunk(int x, int z, TallChunk* chunk);
};
"./Level\\TerrainGeneration\\Generators\\Mountains\\Mountains.cpp"
#include "Mountains.h"
#include "../../../../Utils/FastNoiseLite.h"

MountainGenerator::MountainGenerator() : noise_{std::make_unique<FastNoiseLite>()} {
    noise_->SetNoiseType(noise_->NoiseType_OpenSimplex2);
    noise_->SetFrequency(0.005f);
}

void MountainGenerator::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    ChunkPos scaledPos = pos;
    scaledPos *= 16;

    float heightBias = 50;
    float noiseOffset = 0.3;

    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {

            float continental = ContinentialNoise(GetNoise2D(glm::ivec2(pos.x, pos.z), glm::ivec2(x, z), 3, 0.3f));
            float erosion = ErosionNoise(GetNoise2D(glm::ivec2(pos.x, pos.z), glm::ivec2(x + 4345, z + 6443), 3, 1.f)) / 2.f;
            float pv = PeaksAndValley(GetNoise2D(glm::ivec2(pos.x, pos.z), glm::ivec2(x + 65345, z + 12323), 3, 4.f)) / 8;

            for (int y = 0; y < 16; y++) {

                float gy = (float)(y + scaledPos.y);

                float n = GetNoise3D(glm::ivec3{ pos.x,pos.y ,pos.z }, glm::ivec3(x, y, z), 4, 1.f);

                n = n + noiseOffset;

                n += continental;
                n += erosion;
                n += (pv / (heightBias * (n + 0.5f))) * gy;

                n = n * exp(-gy / heightBias);

                if (n > 0.5f) {
                    if (n < 0.54f) {
                        chunk->SetBlockUnsafe(g_blocks.GRASS, x, y, z);
                        chunk->SetBlock(g_blocks.DIRT, x, y - 1, z);
                    }
                    else {
                        chunk->SetBlockUnsafe(g_blocks.STONE, x, y, z);
                    }
                }
            }
        }
    }

    GenerateEnvironment(scaledPos, chunk.get());
    GenerateDecor(scaledPos, chunk.get());

    int gx = scaledPos.x;
    int gz = scaledPos.z;
    int gy = scaledPos.y;


    if (pos.y == 3) {
        int numBlocks = static_cast<int>(g_blocks.block_type_data_.size());

        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {

                int px = x + gx;
                int pz = z + gz;

                if (((px & 0b1) == 1) || ((pz & 0b1) == 1)) {
                    continue;
                }

                px = px / 2;
                pz = pz / 2;

                if ((px < 0) || (px >= 20)) {
                    continue;
                }

                int b = px + pz * 20;

                if ((b < numBlocks) && (b >= 0)) {
                    chunk->SetBlockUnsafe(b, x, 3, z);
                }
            }
        }
    }
}

void MountainGenerator::GenerateEnvironment(const ChunkPos& pos, Chunk* chunk) {
    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {
            for (int y = 0; y < 16; y++) {

                if (y + pos.y < 34) {
                    if ((chunk->GetBlockUnsafe(x, y, z) == g_blocks.AIR)) {
                        chunk->SetBlockUnsafe(g_blocks.BLUE_CONCRETE, x, y, z);
                    }

                    if ((chunk->GetBlockUnsafe(x, y, z) == g_blocks.GRASS)) {
                        chunk->SetBlockUnsafe(g_blocks.SAND, x, y, z);
                    }
                }
            }
        }
    }
}

void MountainGenerator::GenerateDecor(const ChunkPos& pos, Chunk* chunk) {
    const int tree_height = 3;

    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {

            //Global Pos
            int gx = pos.x + x;
            int gz = pos.z + z;

            float TREE_MAP = (float)((double)(noise_->GetNoise((float)gx * 100.f, (float)gz * 100.f, 3453454.f) + 1.f) / 2.f);
            for (int y = 0; y < 16; y++) {
                if (chunk->GetBlock(x, y - 1, z) == g_blocks.GRASS) {

                    if (TREE_MAP <= 0.04) {
                        
                        for (int tx = -2; tx <= 2; tx++) {
                            for (int tz = -2; tz <= 2; tz++) {
                                if ((abs(tx) == 2) && (abs(tz) == 2))
                                    continue;
                                
                                for (int ty = tree_height; ty <= tree_height + 1; ty++)
                                    chunk->SetBlock(g_blocks.OAK_LEAF, x + tx, y + ty, z + tz);

                            }
                        }

                        for (int tx = -1; tx <= 1; tx++) {
                            for (int tz = -1; tz <= 1; tz++) {
                                for (int ty = tree_height + 2; ty <= tree_height + 3; ty++) {

                                    if ((abs(tx) == 1) && (abs(tz) == 1) && (ty == tree_height + 3)) {
                                        continue;
                                    }
                                    chunk->SetBlock(g_blocks.OAK_LEAF, x + tx, y + ty, z + tz);
                                }
                            }
                        }
                        for (int ty = 0; ty < tree_height + 2; ty++) {
                            chunk->SetBlock(g_blocks.OAK_LOG, x, y + ty, z);
                        }
                    }
                }
            }
        }
    }

    //Cube 

    int xSize = 316;
    int ySize = 100;
    int zSize = 316;

    int xOffset = 0;
    int yOffset = 160;
    int zOffset = 0;

    /*for (int x = 0 + Position.x; x < 16 + Position.x; x++) {
        for (int z = 0 + Position.z; z < 16 + Position.z; z++) {
            for (int y = 0 + Position.y; y < 16 + Position.y; y++) {
                if (((x - xOffset) >= 0) && ((x - xOffset) < xSize) &&
                    ((y - yOffset) >= 0) && ((y - yOffset) < ySize) &&
                    ((z - zOffset) >= 0) && ((z - zOffset) < zSize)) {
                    chunk->SetBlock(Blocks.SAND, x - Position.x, y - Position.y, z - Position.z);
                }
            }
        }
    }*/


    int radius = 40;

    for (int x = 0 + pos.x; x < 16 + pos.x; x++) {
        for (int z = 0 + pos.z; z < 16 + pos.z; z++) {
            for (int y = 0 + pos.y; y < 16 + pos.y; y++) {
                if ((x * x) + (y - 140) * (y - 140) + z * z <= radius * radius) {
                    chunk->SetBlock(g_blocks.SAND, x - pos.x, y - pos.y, z - pos.z);
                }

                //if (y == 90) {
                //    SetBlock(Blocks.SAND, x - cx, y - cy, z - cz);
                //}
            }
        }
    }
}


float MountainGenerator::GetNoise3D(glm::ivec3 ChunkCoordinate, glm::ivec3 RelativeBlockCoords, int samples, float frequency) {
    glm::vec3 GlobalBlockPosition = glm::vec3(ChunkCoordinate * 16 + RelativeBlockCoords);

    GlobalBlockPosition *= frequency;

    float out = 0.0f;

    for (int i = 0; i < samples; i++) {
        float n = noise_->GetNoise(
            GlobalBlockPosition.x * powf(2.0, static_cast<float>(i)),
            GlobalBlockPosition.y * powf(2.0, static_cast<float>(i)),
            GlobalBlockPosition.z * powf(2.0, static_cast<float>(i))) + 1;

        n *= 0.5f;
        out += n * powf(0.5f, static_cast<float>(i));
    }

    out = out * ((-0.5f) / (powf(0.5, static_cast<float>(samples)) - 1));

    return out;

}
float MountainGenerator::GetNoise2D(glm::ivec2 ChunkCoordinate, glm::ivec2 RelativeBlockCoords, int samples, float frequency) {
    glm::vec2 GlobalBlockPosition = glm::vec2(ChunkCoordinate * 16 + RelativeBlockCoords);

    GlobalBlockPosition *= frequency;

    float out = 0.0f;

    for (int i = 0; i < samples; i++) {
        float n = noise_->GetNoise(GlobalBlockPosition.x * powf(2.0, static_cast<float>(i)),
            GlobalBlockPosition.y * powf(2.0, static_cast<float>(i))) + 1;
        n *= 0.5f;
        out += n * powf(0.5f, static_cast<float>(i));
    }

    out = out * ((-0.5f) / (powf(0.5f, static_cast<float>(samples)) - 1.0f));

    return out;
}


float MountainGenerator::ContinentialNoise(float n) {
    size_t index = GetIndex(continentalness_interpolation_, n);

    float x1 = continentalness_interpolation_[index].x;
    float y1 = continentalness_interpolation_[index].y;

    index++;

    float x2 = continentalness_interpolation_[index].x;
    float y2 = continentalness_interpolation_[index].y;

    float m = (y1 - y2) / (x1 - x2);

    float out = m * (n - x1) + y1;

    return out;
}

float MountainGenerator::ErosionNoise(float n) {
    size_t index = GetIndex(erosionness_interpolation_, n);

    float x1 = erosionness_interpolation_[index].x;
    float y1 = erosionness_interpolation_[index].y;

    index++;

    float x2 = erosionness_interpolation_[index].x;
    float y2 = erosionness_interpolation_[index].y;

    float m = (y1 - y2) / (x1 - x2);

    float out = m * (n - x1) + y1;

    return out;
}

float MountainGenerator::PeaksAndValley(float n) {
    size_t index = GetIndex(peaks_valley_interpolation_, n);

    float x1 = peaks_valley_interpolation_[index].x;
    float y1 = peaks_valley_interpolation_[index].y;

    index++;

    float x2 = peaks_valley_interpolation_[index].x;
    float y2 = peaks_valley_interpolation_[index].y;

    float m = (y1 - y2) / (x1 - x2);

    float out = m * (n - x1) + y1;

    return out;
}

size_t MountainGenerator::GetIndex(std::vector<glm::vec2>& vec, float bottomBound) {
    for (int i = 0; i < vec.size(); i++) {
        if (vec[i].x >= bottomBound) {
            return i - 1;
        }
    }

    return vec.size() - 1;
}
"./Level\\TerrainGeneration\\Generators\\Mountains\\Mountains.h"
#pragma once
#include <memory>
#include <vector>
#include <glm/vec2.hpp>

#include "../Generator.h"

class FastNoiseLite;

class MountainGenerator : public WorldGenerator {
public:
    std::unique_ptr<FastNoiseLite> noise_;

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;

    MountainGenerator();

    void GenerateEnvironment(const ChunkPos& pos, Chunk* chunk);

    void GenerateDecor(const ChunkPos& pos, Chunk* chunk);

    float GetNoise3D(glm::ivec3 ChunkCoordinate, glm::ivec3 RelativeBlockCoords, int samples, float frequency);

    float GetNoise2D(glm::ivec2 ChunkCoordinate, glm::ivec2 RelativeBlockCoords, int samples, float frequency);

    float ContinentialNoise(float n);

    float ErosionNoise(float n);

    float PeaksAndValley(float n);

    size_t GetIndex(std::vector<glm::vec2>& vec, float bottomBound);

    std::vector<glm::vec2> continentalness_interpolation_ {
        glm::vec2(0.f, 0.75f),
        glm::vec2(0.2f, 0.82f),
        glm::vec2(0.23f, 0.8f),
        glm::vec2(0.28f, 0.5f),
        glm::vec2(0.38f, 0.2f),
        glm::vec2(0.75f, 0.1f),
        glm::vec2(1.f, 0.3f),
    };

    std::vector<glm::vec2> erosionness_interpolation_ {
        glm::vec2(0.f, 0.75f),
        glm::vec2(0.2f, 0.82f),
        glm::vec2(0.23f, 0.8f),
        glm::vec2(0.28f, 0.5f),
        glm::vec2(0.38f, 0.2f),
        glm::vec2(0.75f, 0.1f),
        glm::vec2(1.f, 0.3f),
    };

    std::vector<glm::vec2> peaks_valley_interpolation_ {
        glm::vec2(0.f, 0.0f),
        glm::vec2(0.075f, 0.0f),
        glm::vec2(0.15f, 0.25f),
        glm::vec2(0.5f, 0.35f),
        glm::vec2(0.6f, 0.75f),
        glm::vec2(0.75f, 0.85f),
        glm::vec2(0.9f, 0.83f),
        glm::vec2(1.f, 0.84f),
    };
};
"./Level\\TerrainGeneration\\Generators\\Superflat\\Superflat.cpp"
#include "Superflat.h"
SuperflatWorld::SuperflatWorld() = default;

void SuperflatWorld::Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) {
    int cy = pos.y * 16;

    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {
            for (int y = 0; y < 16; y++) {
                if (y + cy < 10) {
                    chunk->SetBlockUnsafe(g_blocks.WHITE_CONCRETE, x, y, z);
                }
            }
        }
    }
}
"./Level\\TerrainGeneration\\Generators\\Superflat\\Superflat.h"
#pragma once
#include "../Generator.h"

class SuperflatWorld : public  WorldGenerator {
public:
    SuperflatWorld();

    void Generate(const ChunkPos& pos, std::unique_ptr<Chunk>& chunk) override;
};
"./Level\\TerrainGeneration\\GenLayer\\CombineLayers.h"
#pragma once
#include "GenLayer.h"
#include "GenLayerAddIsland.h"
#include "GenLayerAddMushroomIsland.h"
#include "GenLayerAddSnow.h"
#include "GenLayerBiome.h"
#include "GenLayerBiomeEdge.h"
#include "GenLayerDeepOcean.h"
#include "GenLayerEdge.h"
#include "GenLayerFuzzyZoom.h"
#include "GenLayerHills.h"
#include "GenLayerIsland.h"
#include "GenLayerRareBiome.h"
#include "GenLayerRemoveTooMuchOcean.h"
#include "GenLayerRiverInit.h"
#include "GenLayerRiverMix.h"
#include "GenLayerShore.h"
#include "GenLayerSmooth.h"
#include "GenLayerVoronoiZoom.h"
#include "GenLayerZoom.h"
#include "GenLayerRiver.h"

class CombinedGenLayers {
public:
    static std::vector<GenLayer*> initializeAllBiomeGenerators(long long seed, ChunkGeneratorSettings* p_180781_3_)
    { // TODO: Use unique ptr
        GenLayer* genlayer = new GenLayerIsland(1L);
        genlayer = new GenLayerFuzzyZoom(2000L, genlayer);
        GenLayer* genlayeraddisland = new GenLayerAddIsland(1L, genlayer);
        GenLayer* genlayerzoom = new GenLayerZoom(2001L, genlayeraddisland);
        GenLayer* genlayeraddisland1 = new GenLayerAddIsland(2L, genlayerzoom);
        genlayeraddisland1 = new GenLayerAddIsland(50L, genlayeraddisland1);
        genlayeraddisland1 = new GenLayerAddIsland(70L, genlayeraddisland1);
        GenLayer* genlayerremovetoomuchocean = new GenLayerRemoveTooMuchOcean(2LL, genlayeraddisland1);
        GenLayer* genlayeraddsnow = new GenLayerAddSnow(2L, genlayerremovetoomuchocean);
        GenLayer* genlayeraddisland2 = new GenLayerAddIsland(3L, genlayeraddsnow);
        GenLayer* genlayeredge = new GenLayerEdge(2L, genlayeraddisland2, GenLayerEdge::Mode::COOL_WARM);
        genlayeredge = new GenLayerEdge(2L, genlayeredge, GenLayerEdge::Mode::HEAT_ICE);
        genlayeredge = new GenLayerEdge(3L, genlayeredge, GenLayerEdge::Mode::SPECIAL);
        GenLayer* genlayerzoom1 = new GenLayerZoom(2002L, genlayeredge);
        genlayerzoom1 = new GenLayerZoom(2003L, genlayerzoom1);
        GenLayer* genlayeraddisland3 = new GenLayerAddIsland(4L, genlayerzoom1);
        GenLayer* genlayeraddmushroomisland = new GenLayerAddMushroomIsland(5L, genlayeraddisland3);
        GenLayer* genlayerdeepocean = new GenLayerDeepOcean(4L, genlayeraddmushroomisland);
        GenLayer* genlayer4 = GenLayerZoom::magnify(1000L, genlayerdeepocean, 0);
        int i = 4;
        int j = i;

        if (p_180781_3_ != nullptr)
        {
            i = p_180781_3_->biomeSize;
            j = p_180781_3_->riverSize;
        }

        //if (p_180781_2_ == WorldType.LARGE_BIOMES)
        //{
        //    i = 6;
        //}

        GenLayer* lvt_7_1_ = GenLayerZoom::magnify(1000LL, genlayer4, 0);
        GenLayer* genlayerriverinit = new GenLayerRiverInit(100LL, lvt_7_1_);
        GenLayer* lvt_8_1_ = new GenLayerBiome(200LL, genlayer4, p_180781_3_);
        GenLayer* genlayer6 = GenLayerZoom::magnify(1000LL, lvt_8_1_, 2);
        GenLayer* genlayerbiomeedge = new GenLayerBiomeEdge(1000LL, genlayer6);
        GenLayer* lvt_9_1_ = GenLayerZoom::magnify(1000LL, genlayerriverinit, 2);
        GenLayer* genlayerhills = new GenLayerHills(1000LL, genlayerbiomeedge, lvt_9_1_);
        GenLayer* genlayer5 = GenLayerZoom::magnify(1000LL, genlayerriverinit, 2);
        genlayer5 = GenLayerZoom::magnify(1000LL, genlayer5, j);
        GenLayer* genlayerriver = new GenLayerRiver(1LL, genlayer5);
        GenLayer* genlayersmooth = new GenLayerSmooth(1000LL, genlayerriver);
        genlayerhills = new GenLayerRareBiome(1001LL, genlayerhills);

        for (int k = 0; k < i; ++k)
        {
            genlayerhills = new GenLayerZoom((long long)(1000 + k), genlayerhills);

            if (k == 0)
            {
                genlayerhills = new GenLayerAddIsland(3LL, genlayerhills);
            }

            if (k == 1 || i == 1)
            {
                genlayerhills = new GenLayerShore(1000LL, genlayerhills);
            }
        }

        GenLayer* genlayersmooth1 = new GenLayerSmooth(1000LL, genlayerhills);
        GenLayer* genlayerrivermix = new GenLayerRiverMix(100LL, genlayersmooth1, genlayersmooth);
        GenLayer* genlayer3 = new GenLayerVoronoiZoom(10LL, genlayerrivermix);
        genlayerrivermix->initWorldGenSeed(seed);
        genlayer3->initWorldGenSeed(seed); 
        return { genlayerrivermix, genlayer3, genlayerrivermix };
    }

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayer.h"
#pragma once
#include <vector>
#include "../Biome/Biomes.h"

class GenLayer {
public:

    long long int baseSeed = 0, chunkSeed = 0, worldGenSeed = 0;

    GenLayer* parent = nullptr;

    GenLayer(long long int baseSeedIn) {
        baseSeed = baseSeedIn;
        baseSeed *= baseSeed * 6364136223846793005LL + 1442695040888963407L;
        baseSeed += baseSeedIn;
        baseSeed *= baseSeed * 6364136223846793005LL + 1442695040888963407L;
        baseSeed += baseSeedIn;
        baseSeed *= baseSeed * 6364136223846793005LL + 1442695040888963407L;
        baseSeed += baseSeedIn;
    }

    GenLayer() {

    }
    

    virtual std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) {
        (void)areaHeight;
        (void)areaWidth;
        (void)areaY;
        (void)areaX;
        throw std::exception("no");
    }

    void initChunkSeed(long long val1, long long val2) {
        chunkSeed = worldGenSeed;
        chunkSeed *= chunkSeed * 6364136223846793005LL + 1442695040888963407LL;
        chunkSeed += val1;
        chunkSeed *= chunkSeed * 6364136223846793005LL + 1442695040888963407LL;
        chunkSeed += val2;
        chunkSeed *= chunkSeed * 6364136223846793005LL + 1442695040888963407LL;
        chunkSeed += val1;
        chunkSeed *= chunkSeed * 6364136223846793005LL + 1442695040888963407LL;
        chunkSeed += val2;
    }

    virtual void initWorldGenSeed(long long seed) {
        worldGenSeed = seed;

        if (parent != nullptr) {
            parent->initWorldGenSeed(seed);
        }

        worldGenSeed *= worldGenSeed * 6364136223846793005LL + 1442695040888963407LL;
        worldGenSeed += baseSeed;
        worldGenSeed *= worldGenSeed * 6364136223846793005LL + 1442695040888963407LL;
        worldGenSeed += baseSeed;
        worldGenSeed *= worldGenSeed * 6364136223846793005LL + 1442695040888963407LL;
        worldGenSeed += baseSeed;
    }

    int NextInt(int rngSeed) {
        int i = (int)((chunkSeed >> 24) % (long long)rngSeed);

        if (i < 0) {
            i += rngSeed;
        }

        chunkSeed *= chunkSeed * 6364136223846793005LL + 1442695040888963407LL;
        chunkSeed += worldGenSeed;
        return i;
    }

    static bool biomesEqualOrMesaPlateau(int biomeIDA, int biomeIDB)
    {
        if (biomeIDA == biomeIDB) {
            return true;
        } else {
            Biome* biome = Biome::getBiome(biomeIDA);
            Biome* biome1 = Biome::getBiome(biomeIDB);

            if (biome != nullptr && biome1 != nullptr)
            {
                if (biome != Biomes::MESA_ROCK && biome != Biomes::MESA_CLEAR_ROCK)
                {
                    return biome == biome1 || biome->getBiomeClass() == biome1->getBiomeClass(); //return biome == biome1 || biome->getBiomeClass() == biome1->getBiomeClass();
                } //????
                else
                {
                    return biome1 == Biomes::MESA_ROCK || biome1 == Biomes::MESA_CLEAR_ROCK;
                }
            }
            else
            {
                return false;
            }
        }
    }

    int selectRandom(std::vector<int> rngNum) {
        return rngNum[NextInt(static_cast<int>(rngNum.size()))];
    }

    int selectModeOrRandom(int p_151617_1_, int p_151617_2_, int p_151617_3_, int p_151617_4_) {
        if (p_151617_2_ == p_151617_3_ && p_151617_3_ == p_151617_4_)
        {
            return p_151617_2_;
        }
        else if (p_151617_1_ == p_151617_2_ && p_151617_1_ == p_151617_3_)
        {
            return p_151617_1_;
        }
        else if (p_151617_1_ == p_151617_2_ && p_151617_1_ == p_151617_4_)
        {
            return p_151617_1_;
        }
        else if (p_151617_1_ == p_151617_3_ && p_151617_1_ == p_151617_4_)
        {
            return p_151617_1_;
        }
        else if (p_151617_1_ == p_151617_2_ && p_151617_3_ != p_151617_4_)
        {
            return p_151617_1_;
        }
        else if (p_151617_1_ == p_151617_3_ && p_151617_2_ != p_151617_4_)
        {
            return p_151617_1_;
        }
        else if (p_151617_1_ == p_151617_4_ && p_151617_2_ != p_151617_3_)
        {
            return p_151617_1_;
        }
        else if (p_151617_2_ == p_151617_3_ && p_151617_1_ != p_151617_4_)
        {
            return p_151617_2_;
        }
        else if (p_151617_2_ == p_151617_4_ && p_151617_1_ != p_151617_3_)
        {
            return p_151617_2_;
        }
        else
        {
            return p_151617_3_ == p_151617_4_ && p_151617_1_ != p_151617_2_ ? p_151617_3_ : selectRandom({ p_151617_1_, p_151617_2_, p_151617_3_, p_151617_4_ });
        }
    }

    static bool isBiomeOceanic(int p_151618_0_) {
        Biome* biome = Biome::getBiome(p_151618_0_);
        return biome == Biomes::OCEAN || biome == Biomes::DEEP_OCEAN || biome == Biomes::FROZEN_OCEAN;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerAddIsland.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerAddIsland : public GenLayer {
private:

public:
    GenLayerAddIsland(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn){
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight);

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 0 + (i1 + 0) * k];
                int l1 = aint[j1 + 2 + (i1 + 0) * k];
                int i2 = aint[j1 + 0 + (i1 + 2) * k];
                int j2 = aint[j1 + 2 + (i1 + 2) * k];
                int k2 = aint[j1 + 1 + (i1 + 1) * k];
                initChunkSeed((long long)(j1 + areaX), (long long)(i1 + areaY));

                if (k2 != 0 || k1 == 0 && l1 == 0 && i2 == 0 && j2 == 0)
                {
                    if (k2 > 0 && (k1 == 0 || l1 == 0 || i2 == 0 || j2 == 0))
                    {
                        if (NextInt(5) == 0)
                        {
                            if (k2 == 4)
                            {
                                aint1[j1 + i1 * areaWidth] = 4;
                            }
                            else
                            {
                                aint1[j1 + i1 * areaWidth] = 0;
                            }
                        }
                        else
                        {
                            aint1[j1 + i1 * areaWidth] = k2;
                        }
                    }
                    else
                    {
                        aint1[j1 + i1 * areaWidth] = k2;
                    }
                }
                else
                {
                    int l2 = 1;
                    int i3 = 1;

                    if (k1 != 0 && NextInt(l2++) == 0)
                    {
                        i3 = k1;
                    }

                    if (l1 != 0 && NextInt(l2++) == 0)
                    {
                        i3 = l1;
                    }

                    if (i2 != 0 && NextInt(l2++) == 0)
                    {
                        i3 = i2;
                    }

                    if (j2 != 0 && NextInt(l2++) == 0)
                    {
                        i3 = j2;
                    }

                    if (NextInt(3) == 0)
                    {
                        aint1[j1 + i1 * areaWidth] = i3;
                    }
                    else if (i3 == 4)
                    {
                        aint1[j1 + i1 * areaWidth] = 4;
                    }
                    else
                    {
                        aint1[j1 + i1 * areaWidth] = 0;
                    }
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerAddMushroomIsland.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerAddMushroomIsland : public GenLayer {
public:
    GenLayerAddMushroomIsland(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }


    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 0 + (i1 + 0) * k];
                int l1 = aint[j1 + 2 + (i1 + 0) * k];
                int i2 = aint[j1 + 0 + (i1 + 2) * k];
                int j2 = aint[j1 + 2 + (i1 + 2) * k];
                int k2 = aint[j1 + 1 + (i1 + 1) * k];
                initChunkSeed((long long)(j1 + areaX), (long long)(i1 + areaY));

                if (k2 == 0 && k1 == 0 && l1 == 0 && i2 == 0 && j2 == 0 && NextInt(100) == 0)
                {
                    aint1[j1 + i1 * areaWidth] = Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND);
                }
                else
                {
                    aint1[j1 + i1 * areaWidth] = k2;
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerAddSnow.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerAddSnow : public GenLayer {
public:
    GenLayerAddSnow(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override  {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int i1 = 0; i1 < areaHeight; ++i1)  {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 1 + (i1 + 1) * k];
                initChunkSeed((long long)(j1 + areaX), (long long)(i1 + areaY));

                if (k1 == 0)
                {
                    aint1[j1 + i1 * areaWidth] = 0;
                }
                else
                {
                    int l1 = NextInt(6);

                    if (l1 == 0)
                    {
                        l1 = 4;
                    }
                    else if (l1 <= 1)
                    {
                        l1 = 3;
                    }
                    else
                    {
                        l1 = 1;
                    }

                    aint1[j1 + i1 * areaWidth] = l1;
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerBiome.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
#include "../Noisemaps/TerrainParameters.h"
#include "../Biome/Biomes.h"

class GenLayerBiome : public GenLayer {
private:
    std::vector<Biome*> warmBiomes = { Biomes::DESERT, Biomes::DESERT, Biomes::DESERT, Biomes::SAVANNA, Biomes::SAVANNA, Biomes::PLAINS };
    std::vector<Biome*> mediumBiomes = { Biomes::FOREST, Biomes::ROOFED_FOREST, Biomes::EXTREME_HILLS, Biomes::PLAINS, Biomes::BIRCH_FOREST, Biomes::SWAMPLAND };
    std::vector<Biome*> iceBiomes = { Biomes::ICE_PLAINS, Biomes::ICE_PLAINS, Biomes::ICE_PLAINS, Biomes::COLD_TAIGA };
    std::vector<Biome*> coldBiomes = { Biomes::FOREST, Biomes::EXTREME_HILLS, Biomes::TAIGA, Biomes::PLAINS };
    ChunkGeneratorSettings* settings_;
public:

    GenLayerBiome(long long baseSeedIn, GenLayer* parentIn, ChunkGeneratorSettings* settingsIn) : GenLayer(baseSeedIn) { // add worldtype ;ater
        parent = parentIn;
        settings_ = settingsIn;

    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override
    {
        std::vector<int>  aint = parent->getInts(areaX, areaY, areaWidth, areaHeight);
        std::vector<int>  aint1 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                int k = aint[j + i * areaWidth];
                int l = (k & 3840) >> 8;
                k = k & -3841;

                if (settings_ != nullptr && settings_->fixedBiome >= 0)
                {
                    aint1[j + i * areaWidth] = settings_->fixedBiome;
                }
                else if (isBiomeOceanic(k))
                {
                    aint1[j + i * areaWidth] = k;
                }
                else if (k == Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND))
                {
                    aint1[j + i * areaWidth] = k;
                }
                else if (k == 1)
                {
                    if (l > 0)
                    {
                        if (NextInt(3) == 0)
                        {
                            aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::MESA_CLEAR_ROCK);
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::MESA_ROCK);
                        }
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(warmBiomes[NextInt(static_cast<int>(warmBiomes.size()))]);
                    }
                }
                else if (k == 2)
                {
                    if (l > 0)
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::JUNGLE);
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(mediumBiomes[NextInt(static_cast<int>(mediumBiomes.size()))]);
                    }
                }
                else if (k == 3)
                {
                    if (l > 0)
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::REDWOOD_TAIGA);
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(coldBiomes[NextInt(static_cast<int>(coldBiomes.size()))]);
                    }
                }
                else if (k == 4)
                {
                    aint1[j + i * areaWidth] = Biome::getIdForBiome(iceBiomes[NextInt(static_cast<int>(iceBiomes.size()))]);
                }
                else
                {
                    aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND);
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerBiomeEdge.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
#include "../Biome/Biomes.h"

class GenLayerBiomeEdge : public GenLayer {
public:
    GenLayerBiomeEdge(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

   std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
       std::vector<int> aint = parent->getInts(areaX - 1, areaY - 1, areaWidth + 2, areaHeight + 2);
       std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                int k = aint[j + 1 + (i + 1) * (areaWidth + 2)];

                if (!replaceBiomeEdgeIfNecessary(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::EXTREME_HILLS), Biome::getIdForBiome(Biomes::EXTREME_HILLS_EDGE)) && !replaceBiomeEdge(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::MESA_ROCK), Biome::getIdForBiome(Biomes::MESA)) && !replaceBiomeEdge(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::MESA_CLEAR_ROCK), Biome::getIdForBiome(Biomes::MESA)) && !replaceBiomeEdge(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::REDWOOD_TAIGA), Biome::getIdForBiome(Biomes::TAIGA)))
                {
                    if (k == Biome::getIdForBiome(Biomes::DESERT))
                    {
                        int l1 = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                        int i2 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                        int j2 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                        int k2 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                        if (l1 != Biome::getIdForBiome(Biomes::ICE_PLAINS) && i2 != Biome::getIdForBiome(Biomes::ICE_PLAINS) && j2 != Biome::getIdForBiome(Biomes::ICE_PLAINS) && k2 != Biome::getIdForBiome(Biomes::ICE_PLAINS))
                        {
                            aint1[j + i * areaWidth] = k;
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::EXTREME_HILLS_WITH_TREES);
                        }
                    }
                    else if (k == Biome::getIdForBiome(Biomes::SWAMPLAND))
                    {
                        int l = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                        int i1 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                        int j1 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                        int k1 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                        if (l != Biome::getIdForBiome(Biomes::DESERT) && i1 != Biome::getIdForBiome(Biomes::DESERT) && j1 != Biome::getIdForBiome(Biomes::DESERT) && k1 != Biome::getIdForBiome(Biomes::DESERT) && l != Biome::getIdForBiome(Biomes::COLD_TAIGA) && i1 != Biome::getIdForBiome(Biomes::COLD_TAIGA) && j1 != Biome::getIdForBiome(Biomes::COLD_TAIGA) && k1 != Biome::getIdForBiome(Biomes::COLD_TAIGA) && l != Biome::getIdForBiome(Biomes::ICE_PLAINS) && i1 != Biome::getIdForBiome(Biomes::ICE_PLAINS) && j1 != Biome::getIdForBiome(Biomes::ICE_PLAINS) && k1 != Biome::getIdForBiome(Biomes::ICE_PLAINS))
                        {
                            if (l != Biome::getIdForBiome(Biomes::JUNGLE) && k1 != Biome::getIdForBiome(Biomes::JUNGLE) && i1 != Biome::getIdForBiome(Biomes::JUNGLE) && j1 != Biome::getIdForBiome(Biomes::JUNGLE))
                            {
                                aint1[j + i * areaWidth] = k;
                            }
                            else
                            {
                                aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::JUNGLE_EDGE);
                            }
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::PLAINS);
                        }
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = k;
                    }
                }
            }
        }

        return aint1;
    }

    bool replaceBiomeEdgeIfNecessary(std::vector<int>& p_151636_1_, std::vector<int>& p_151636_2_, int p_151636_3_, int p_151636_4_, int p_151636_5_, int p_151636_6_, int p_151636_7_, int p_151636_8_)
    {
        if (!biomesEqualOrMesaPlateau(p_151636_6_, p_151636_7_))
        {
            return false;
        }
        else
        {
            int i = p_151636_1_[p_151636_3_ + 1 + (p_151636_4_ + 1 - 1) * (p_151636_5_ + 2)];
            int j = p_151636_1_[p_151636_3_ + 1 + 1 + (p_151636_4_ + 1) * (p_151636_5_ + 2)];
            int k = p_151636_1_[p_151636_3_ + 1 - 1 + (p_151636_4_ + 1) * (p_151636_5_ + 2)];
            int l = p_151636_1_[p_151636_3_ + 1 + (p_151636_4_ + 1 + 1) * (p_151636_5_ + 2)];

            if (canBiomesBeNeighbors(i, p_151636_7_) && canBiomesBeNeighbors(j, p_151636_7_) && canBiomesBeNeighbors(k, p_151636_7_) && canBiomesBeNeighbors(l, p_151636_7_))
            {
                p_151636_2_[p_151636_3_ + p_151636_4_ * p_151636_5_] = p_151636_6_;
            }
            else
            {
                p_151636_2_[p_151636_3_ + p_151636_4_ * p_151636_5_] = p_151636_8_;
            }

            return true;
        }
    }

    bool replaceBiomeEdge(std::vector<int>& p_151635_1_, std::vector<int>& p_151635_2_, int p_151635_3_, int p_151635_4_, int p_151635_5_, int p_151635_6_, int p_151635_7_, int p_151635_8_)
    {
        if (p_151635_6_ != p_151635_7_)
        {
            return false;
        }
        else
        {
            int i = p_151635_1_[p_151635_3_ + 1 + (p_151635_4_ + 1 - 1) * (p_151635_5_ + 2)];
            int j = p_151635_1_[p_151635_3_ + 1 + 1 + (p_151635_4_ + 1) * (p_151635_5_ + 2)];
            int k = p_151635_1_[p_151635_3_ + 1 - 1 + (p_151635_4_ + 1) * (p_151635_5_ + 2)];
            int l = p_151635_1_[p_151635_3_ + 1 + (p_151635_4_ + 1 + 1) * (p_151635_5_ + 2)];

            if (biomesEqualOrMesaPlateau(i, p_151635_7_) && biomesEqualOrMesaPlateau(j, p_151635_7_) && biomesEqualOrMesaPlateau(k, p_151635_7_) && biomesEqualOrMesaPlateau(l, p_151635_7_))
            {
                p_151635_2_[p_151635_3_ + p_151635_4_ * p_151635_5_] = p_151635_6_;
            }
            else
            {
                p_151635_2_[p_151635_3_ + p_151635_4_ * p_151635_5_] = p_151635_8_;
            }

            return true;
        }
    }

    bool canBiomesBeNeighbors(int p_151634_1_, int p_151634_2_)
    {
        if (biomesEqualOrMesaPlateau(p_151634_1_, p_151634_2_))
        {
            return true;
        }
        else
        {
            Biome* biome = Biome::getBiome(p_151634_1_);
            Biome* biome1 = Biome::getBiome(p_151634_2_);

            if (biome != nullptr && biome1 != nullptr)
            {
                Biome::TempCategory biomeTempcategory = biome->getTempCategory();
                Biome::TempCategory biomeTempcategory1 = biome1->getTempCategory();
                return biomeTempcategory == biomeTempcategory1 || biomeTempcategory == Biome::TempCategory::MEDIUM || biomeTempcategory1 == Biome::TempCategory::MEDIUM;
            }
            else
            {
                return false;
            }
        }
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerDeepOcean.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerDeepOcean : public GenLayer {
public:
    GenLayerDeepOcean(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight)
    {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int>aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 1 + (i1 + 1 - 1) * (areaWidth + 2)];
                int l1 = aint[j1 + 1 + 1 + (i1 + 1) * (areaWidth + 2)];
                int i2 = aint[j1 + 1 - 1 + (i1 + 1) * (areaWidth + 2)];
                int j2 = aint[j1 + 1 + (i1 + 1 + 1) * (areaWidth + 2)];
                int k2 = aint[j1 + 1 + (i1 + 1) * k];
                int l2 = 0;

                if (k1 == 0)
                {
                    ++l2;
                }

                if (l1 == 0)
                {
                    ++l2;
                }

                if (i2 == 0)
                {
                    ++l2;
                }

                if (j2 == 0)
                {
                    ++l2;
                }

                if (k2 == 0 && l2 > 3)
                {
                    aint1[j1 + i1 * areaWidth] = Biome::getIdForBiome(Biomes::DEEP_OCEAN);
                }
                else
                {
                    aint1[j1 + i1 * areaWidth] = k2;
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerEdge.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerEdge : public GenLayer {
private:

    std::vector<int> getIntsCoolWarm(int p_151626_1_, int p_151626_2_, int p_151626_3_, int p_151626_4_)
    {
        int i = p_151626_1_ - 1;
        int j = p_151626_2_ - 1;
        int k = 1 + p_151626_3_ + 1;
        int l = 1 + p_151626_4_ + 1;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(p_151626_3_ * p_151626_4_); //int cache

        for (int i1 = 0; i1 < p_151626_4_; ++i1)
        {
            for (int j1 = 0; j1 < p_151626_3_; ++j1)
            {
                initChunkSeed((long long)(j1 + p_151626_1_), (long long)(i1 + p_151626_2_));
                int k1 = aint[j1 + 1 + (i1 + 1) * k];

                if (k1 == 1)
                {
                    int l1 = aint[j1 + 1 + (i1 + 1 - 1) * k];
                    int i2 = aint[j1 + 1 + 1 + (i1 + 1) * k];
                    int j2 = aint[j1 + 1 - 1 + (i1 + 1) * k];
                    int k2 = aint[j1 + 1 + (i1 + 1 + 1) * k];
                    bool flag = l1 == 3 || i2 == 3 || j2 == 3 || k2 == 3;
                    bool flag1 = l1 == 4 || i2 == 4 || j2 == 4 || k2 == 4;

                    if (flag || flag1)
                    {
                        k1 = 2;
                    }
                }

                aint1[j1 + i1 * p_151626_3_] = k1;
            }
        }

        return aint1;
    }

    std::vector<int> getIntsHeatIce(int p_151624_1_, int p_151624_2_, int p_151624_3_, int p_151624_4_)
    {
        int i = p_151624_1_ - 1;
        int j = p_151624_2_ - 1;
        int k = 1 + p_151624_3_ + 1;
        int l = 1 + p_151624_4_ + 1;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(p_151624_3_ * p_151624_4_); //int cache

        for (int i1 = 0; i1 < p_151624_4_; ++i1)
        {
            for (int j1 = 0; j1 < p_151624_3_; ++j1)
            {
                int k1 = aint[j1 + 1 + (i1 + 1) * k];

                if (k1 == 4)
                {
                    int l1 = aint[j1 + 1 + (i1 + 1 - 1) * k];
                    int i2 = aint[j1 + 1 + 1 + (i1 + 1) * k];
                    int j2 = aint[j1 + 1 - 1 + (i1 + 1) * k];
                    int k2 = aint[j1 + 1 + (i1 + 1 + 1) * k];
                    bool flag = l1 == 2 || i2 == 2 || j2 == 2 || k2 == 2;
                    bool flag1 = l1 == 1 || i2 == 1 || j2 == 1 || k2 == 1;

                    if (flag1 || flag)
                    {
                        k1 = 3;
                    }
                }

                aint1[j1 + i1 * p_151624_3_] = k1;
            }
        }

        return aint1;
    }

    std::vector<int> getIntsSpecial(int p_151625_1_, int p_151625_2_, int p_151625_3_, int p_151625_4_)
    {
        std::vector<int> aint = parent->getInts(p_151625_1_, p_151625_2_, p_151625_3_, p_151625_4_);
        std::vector<int> aint1 = std::vector<int>(p_151625_3_ * p_151625_4_); //int cache

        for (int i = 0; i < p_151625_4_; ++i)
        {
            for (int j = 0; j < p_151625_3_; ++j)
            {
                initChunkSeed((long long)(j + p_151625_1_), (long long)(i + p_151625_2_));
                int k = aint[j + i * p_151625_3_];

                if (k != 0 && NextInt(13) == 0)
                {
                    k |= (1 + NextInt(15)) << 8 & 3840; // TODO: Original: 1 + NextInt(15) << 8 & 3840
                }

                aint1[j + i * p_151625_3_] = k;
            }
        }

        return aint1;
    }
public:
    enum Mode {
        COOL_WARM,
        HEAT_ICE,
        SPECIAL
    };

    GenLayerEdge::Mode mode;

    GenLayerEdge(long long baseSeedIn, GenLayer* parentIn, GenLayerEdge::Mode modeIn) : GenLayer(baseSeedIn), mode(modeIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight)
    {
        switch (mode)
        {
        case COOL_WARM:
        default:
            return getIntsCoolWarm(areaX, areaY, areaWidth, areaHeight);

        case HEAT_ICE:
            return getIntsHeatIce(areaX, areaY, areaWidth, areaHeight);

        case SPECIAL:
            return getIntsSpecial(areaX, areaY, areaWidth, areaHeight);
        }
    }

   

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerFuzzyZoom.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
#include "GenLayerZoom.h"

class GenLayerFuzzyZoom : public GenLayerZoom {
public:
    GenLayerFuzzyZoom(long long baseSeedIn, GenLayer* parentIn) : GenLayerZoom(baseSeedIn, parentIn) {
    }

    int selectModeOrRandom(int p_151617_1_, int p_151617_2_, int p_151617_3_, int p_151617_4_)
    {
        return selectRandom({p_151617_1_, p_151617_2_, p_151617_3_, p_151617_4_});
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerHills.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
#include "../Biome/Biomes.h"

class GenLayerHills : public GenLayer {
private:
    GenLayer* riverLayer = nullptr;
public:
    GenLayerHills(long long baseSeedIn, GenLayer* parentIn, GenLayer* riverLayerIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
        riverLayer = riverLayerIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) {
        std::vector<int> aint = parent->getInts(areaX - 1, areaY - 1, areaWidth + 2, areaHeight + 2);
        std::vector<int> aint1 = riverLayer->getInts(areaX - 1, areaY - 1, areaWidth + 2, areaHeight + 2);
        std::vector<int> aint2 = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                int k = aint[j + 1 + (i + 1) * (areaWidth + 2)];
                int l = aint1[j + 1 + (i + 1) * (areaWidth + 2)];
                bool flag = (l - 2) % 29 == 0;

                if (k > 255)
                {
                    //LOGGER.debug("old! {}", Integer.valueOf(k));
                }

                Biome* biome = Biome::getBiomeForId(k);
                bool flag1 = biome != nullptr && biome->isMutation();

                if (k != 0 && l >= 2 && (l - 2) % 29 == 1 && !flag1)
                {
                    Biome* biome3 = Biome::getMutationForBiome(biome);
                    aint2[j + i * areaWidth] = biome3 == nullptr ? k : Biome::getIdForBiome(biome3);
                }
                else if (NextInt(3) != 0 && !flag)
                {
                    aint2[j + i * areaWidth] = k;
                }
                else
                {
                    Biome* biome1 = biome;

                    if (biome == Biomes::DESERT)
                    {
                        biome1 = Biomes::DESERT_HILLS;
                    }
                    else if (biome == Biomes::FOREST)
                    {
                        biome1 = Biomes::FOREST_HILLS;
                    }
                    else if (biome == Biomes::BIRCH_FOREST)
                    {
                        biome1 = Biomes::BIRCH_FOREST_HILLS;
                    }
                    else if (biome == Biomes::ROOFED_FOREST)
                    {
                        biome1 = Biomes::PLAINS;
                    }
                    else if (biome == Biomes::TAIGA)
                    {
                        biome1 = Biomes::TAIGA_HILLS;
                    }
                    else if (biome == Biomes::REDWOOD_TAIGA)
                    {
                        biome1 = Biomes::REDWOOD_TAIGA_HILLS;
                    }
                    else if (biome == Biomes::COLD_TAIGA)
                    {
                        biome1 = Biomes::COLD_TAIGA_HILLS;
                    }
                    else if (biome == Biomes::PLAINS)
                    {
                        if (NextInt(3) == 0)
                        {
                            biome1 = Biomes::FOREST_HILLS;
                        }
                        else
                        {
                            biome1 = Biomes::FOREST;
                        }
                    }
                    else if (biome == Biomes::ICE_PLAINS)
                    {
                        biome1 = Biomes::ICE_MOUNTAINS;
                    }
                    else if (biome == Biomes::JUNGLE)
                    {
                        biome1 = Biomes::JUNGLE_HILLS;
                    }
                    else if (biome == Biomes::OCEAN)
                    {
                        biome1 = Biomes::DEEP_OCEAN;
                    }
                    else if (biome == Biomes::EXTREME_HILLS)
                    {
                        biome1 = Biomes::EXTREME_HILLS_WITH_TREES;
                    }
                    else if (biome == Biomes::SAVANNA)
                    {
                        biome1 = Biomes::SAVANNA_PLATEAU;
                    }
                    else if (biomesEqualOrMesaPlateau(k, Biome::getIdForBiome(Biomes::MESA_ROCK)))
                    {
                        biome1 = Biomes::MESA;
                    }
                    else if (biome == Biomes::DEEP_OCEAN && NextInt(3) == 0)
                    {
                        int i1 = NextInt(2);

                        if (i1 == 0)
                        {
                            biome1 = Biomes::PLAINS;
                        }
                        else
                        {
                            biome1 = Biomes::FOREST;
                        }
                    }

                    int j2 = Biome::getIdForBiome(biome1);

                    if (flag && j2 != k)
                    {
                        Biome* biome2 = Biome::getMutationForBiome(biome1);
                        j2 = biome2 == nullptr ? k : Biome::getIdForBiome(biome2);
                    }

                    if (j2 == k)
                    {
                        aint2[j + i * areaWidth] = k;
                    }
                    else
                    {
                        int k2 = aint[j + 1 + (i + 0) * (areaWidth + 2)];
                        int j1 = aint[j + 2 + (i + 1) * (areaWidth + 2)];
                        int k1 = aint[j + 0 + (i + 1) * (areaWidth + 2)];
                        int l1 = aint[j + 1 + (i + 2) * (areaWidth + 2)];
                        int i2 = 0;

                        if (biomesEqualOrMesaPlateau(k2, k))
                        {
                            ++i2;
                        }

                        if (biomesEqualOrMesaPlateau(j1, k))
                        {
                            ++i2;
                        }

                        if (biomesEqualOrMesaPlateau(k1, k))
                        {
                            ++i2;
                        }

                        if (biomesEqualOrMesaPlateau(l1, k))
                        {
                            ++i2;
                        }

                        if (i2 >= 3)
                        {
                            aint2[j + i * areaWidth] = j2;
                        }
                        else
                        {
                            aint2[j + i * areaWidth] = k;
                        }
                    }
                }
            }
        }

        return aint2;
    }

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerIsland.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerIsland : public GenLayer {
private:

public:
    GenLayerIsland(long long baseSeedIn) : GenLayer(baseSeedIn) {

    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        std::vector<int> aint = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(areaX + j), (long long)(areaY + i));
                aint[j + i * areaWidth] = NextInt(10) == 0 ? 1 : 0;
            }
        }

        if (areaX > -areaWidth && areaX <= 0 && areaY > -areaHeight && areaY <= 0)
        {
            aint[-areaX + -areaY * areaWidth] = 1;
        }

        return aint;
    }

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerRareBiome.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerRareBiome : public GenLayer {
public:
    GenLayerRareBiome(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        std::vector<int> aint = parent->getInts(areaX - 1, areaY - 1, areaWidth + 2, areaHeight + 2);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                int k = aint[j + 1 + (i + 1) * (areaWidth + 2)];

                if (NextInt(57) == 0)
                {
                    if (k == Biome::getIdForBiome(Biomes::PLAINS))
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::MUTATED_PLAINS);
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = k;
                    }
                }
                else
                {
                    aint1[j + i * areaWidth] = k;
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerRemoveTooMuchOcean.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerRemoveTooMuchOcean : public GenLayer {
public:
    GenLayerRemoveTooMuchOcean(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int>  aint = parent->getInts(i, j, k, l);
        std::vector<int>  aint1 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 1 + (i1 + 1 - 1) * (areaWidth + 2)];
                int l1 = aint[j1 + 1 + 1 + (i1 + 1) * (areaWidth + 2)];
                int i2 = aint[j1 + 1 - 1 + (i1 + 1) * (areaWidth + 2)];
                int j2 = aint[j1 + 1 + (i1 + 1 + 1) * (areaWidth + 2)];
                int k2 = aint[j1 + 1 + (i1 + 1) * k];
                aint1[j1 + i1 * areaWidth] = k2;
                initChunkSeed((long long)(j1 + areaX), (long long)(i1 + areaY));

                if (k2 == 0 && k1 == 0 && l1 == 0 && i2 == 0 && j2 == 0 && NextInt(2) == 0)
                {
                    aint1[j1 + i1 * areaWidth] = 1;
                }
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerRiver.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerRiver : public GenLayer {
private:
    int riverFilter(int p_151630_1_)
    {
        return p_151630_1_ >= 2 ? 2 + (p_151630_1_ & 1) : p_151630_1_;
    }
public:
    GenLayerRiver(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override
    {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); // int cache

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = riverFilter(aint[j1 + 0 + (i1 + 1) * k]);
                int l1 = riverFilter(aint[j1 + 2 + (i1 + 1) * k]);
                int i2 = riverFilter(aint[j1 + 1 + (i1 + 0) * k]);
                int j2 = riverFilter(aint[j1 + 1 + (i1 + 2) * k]);
                int k2 = riverFilter(aint[j1 + 1 + (i1 + 1) * k]);

                if (k2 == k1 && k2 == i2 && k2 == l1 && k2 == j2)
                {
                    aint1[j1 + i1 * areaWidth] = -1;
                }
                else
                {
                    aint1[j1 + i1 * areaWidth] = Biome::getIdForBiome(Biomes::RIVER);
                }
            }
        }

        return aint1;
    }

    
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerRiverInit.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerRiverInit : public GenLayer {
public:
    GenLayerRiverInit(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        std::vector<int> aint = parent->getInts(areaX, areaY, areaWidth, areaHeight);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); // int cache

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                aint1[j + i * areaWidth] = aint[j + i * areaWidth] > 0 ? NextInt(299999) + 2 : 0;
            }
        }

        return aint1;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerRiverMix.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
#include "../Biome/Biomes.h"

class GenLayerRiverMix : public GenLayer {
private:
    GenLayer* biomePatternGeneratorChain = nullptr;
    GenLayer* riverPatternGeneratorChain = nullptr;
public:
    GenLayerRiverMix(long long baseSeedIn, GenLayer* biomePatternGeneratorChainIn, GenLayer* riverPatternGeneratorChainIn) : GenLayer(baseSeedIn) {
        biomePatternGeneratorChain = biomePatternGeneratorChainIn;
        riverPatternGeneratorChain = riverPatternGeneratorChainIn;
    }

    void initWorldGenSeed(long long seed) override {
        biomePatternGeneratorChain->initWorldGenSeed(seed);
        riverPatternGeneratorChain->initWorldGenSeed(seed);
        GenLayer::initWorldGenSeed(seed); //
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        std::vector<int> aint = biomePatternGeneratorChain->getInts(areaX, areaY, areaWidth, areaHeight);
        std::vector<int> aint1 = riverPatternGeneratorChain->getInts(areaX, areaY, areaWidth, areaHeight);
        std::vector<int> aint2 = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaWidth * areaHeight; ++i) {
            if (aint[i] != Biome::getIdForBiome(Biomes::OCEAN) && aint[i] != Biome::getIdForBiome(Biomes::DEEP_OCEAN)) {
                if (aint1[i] == Biome::getIdForBiome(Biomes::RIVER)) {
                    if (aint[i] == Biome::getIdForBiome(Biomes::ICE_PLAINS)) {
                        aint2[i] = Biome::getIdForBiome(Biomes::FROZEN_RIVER);
                    } else if (aint[i] != Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND) && aint[i] != Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND_SHORE)) {
                        aint2[i] = aint1[i] & 255;
                    } else {
                        aint2[i] = Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND_SHORE);
                    }
                } else {
                    aint2[i] = aint[i];
                }
            } else {
                aint2[i] = aint[i];
            }
        }
        return aint2;
    }

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerShore.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerShore : public GenLayer {
private:
   void replaceIfNeighborOcean(std::vector<int>& p_151632_1_, std::vector<int>& p_151632_2_, int p_151632_3_, int p_151632_4_, int p_151632_5_, int p_151632_6_, int p_151632_7_)
    {
        if (isBiomeOceanic(p_151632_6_))
        {
            p_151632_2_[p_151632_3_ + p_151632_4_ * p_151632_5_] = p_151632_6_;
        }
        else
        {
            int i = p_151632_1_[p_151632_3_ + 1 + (p_151632_4_ + 1 - 1) * (p_151632_5_ + 2)];
            int j = p_151632_1_[p_151632_3_ + 1 + 1 + (p_151632_4_ + 1) * (p_151632_5_ + 2)];
            int k = p_151632_1_[p_151632_3_ + 1 - 1 + (p_151632_4_ + 1) * (p_151632_5_ + 2)];
            int l = p_151632_1_[p_151632_3_ + 1 + (p_151632_4_ + 1 + 1) * (p_151632_5_ + 2)];

            if (!isBiomeOceanic(i) && !isBiomeOceanic(j) && !isBiomeOceanic(k) && !isBiomeOceanic(l))
            {
                p_151632_2_[p_151632_3_ + p_151632_4_ * p_151632_5_] = p_151632_6_;
            }
            else
            {
                p_151632_2_[p_151632_3_ + p_151632_4_ * p_151632_5_] = p_151632_7_;
            }
        }
    }

    bool isJungleCompatible(int p_151631_1_)
    {
        if (Biome::getBiome(p_151631_1_) != nullptr && Biome::getBiome(p_151631_1_)->getBiomeClass() == typeid(BiomeJungle)) // class thingy
        {
            return true;
        }
        else
        {
            return p_151631_1_ == Biome::getIdForBiome(Biomes::JUNGLE_EDGE) || p_151631_1_ == Biome::getIdForBiome(Biomes::JUNGLE) || p_151631_1_ == Biome::getIdForBiome(Biomes::JUNGLE_HILLS) || p_151631_1_ == Biome::getIdForBiome(Biomes::FOREST) || p_151631_1_ == Biome::getIdForBiome(Biomes::TAIGA) || isBiomeOceanic(p_151631_1_);
        }
    }

    bool isMesa(int p_151633_1_)
    {
        return dynamic_cast<BiomeMesa*>(Biome::getBiome(p_151633_1_)) != nullptr;
    }

public:
    GenLayerShore(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        std::vector<int> aint = parent->getInts(areaX - 1, areaY - 1, areaWidth + 2, areaHeight + 2);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight);

        for (int i = 0; i < areaHeight; ++i)
        {
            for (int j = 0; j < areaWidth; ++j)
            {
                initChunkSeed((long long)(j + areaX), (long long)(i + areaY));
                int k = aint[j + 1 + (i + 1) * (areaWidth + 2)];
                Biome* biome = Biome::getBiome(k);

                if (k == Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND))
                {
                    int j2 = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                    int i3 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                    int l3 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                    int k4 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                    if (j2 != Biome::getIdForBiome(Biomes::OCEAN) && i3 != Biome::getIdForBiome(Biomes::OCEAN) && l3 != Biome::getIdForBiome(Biomes::OCEAN) && k4 != Biome::getIdForBiome(Biomes::OCEAN))
                    {
                        aint1[j + i * areaWidth] = k;
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::MUSHROOM_ISLAND_SHORE);
                    }
                }


                else if (biome != nullptr && biome->getBiomeClass() == typeid(BiomeJungle))
                {
                    int i2 = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                    int l2 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                    int k3 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                    int j4 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                    if (isJungleCompatible(i2) && isJungleCompatible(l2) && isJungleCompatible(k3) && isJungleCompatible(j4))
                    {
                        if (!isBiomeOceanic(i2) && !isBiomeOceanic(l2) && !isBiomeOceanic(k3) && !isBiomeOceanic(j4))
                        {
                            aint1[j + i * areaWidth] = k;
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::BEACH);
                        }
                    }
                    else
                    {
                        aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::JUNGLE_EDGE);
                    }
                }
                else if (k != Biome::getIdForBiome(Biomes::EXTREME_HILLS) && k != Biome::getIdForBiome(Biomes::EXTREME_HILLS_WITH_TREES) && k != Biome::getIdForBiome(Biomes::EXTREME_HILLS_EDGE))
                {
                    if (biome != nullptr && biome->isSnowyBiome())
                    {
                        replaceIfNeighborOcean(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::COLD_BEACH));
                    }
                    else if (k != Biome::getIdForBiome(Biomes::MESA) && k != Biome::getIdForBiome(Biomes::MESA_ROCK))
                    {
                        if (k != Biome::getIdForBiome(Biomes::OCEAN) && k != Biome::getIdForBiome(Biomes::DEEP_OCEAN) && k != Biome::getIdForBiome(Biomes::RIVER) && k != Biome::getIdForBiome(Biomes::SWAMPLAND))
                        {
                            int l1 = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                            int k2 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                            int j3 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                            int i4 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                            if (!isBiomeOceanic(l1) && !isBiomeOceanic(k2) && !isBiomeOceanic(j3) && !isBiomeOceanic(i4))
                            {
                                aint1[j + i * areaWidth] = k;
                            }
                            else
                            {
                                aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::BEACH);
                            }
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = k;
                        }
                    }
                    else
                    {
                        int l = aint[j + 1 + (i + 1 - 1) * (areaWidth + 2)];
                        int i1 = aint[j + 1 + 1 + (i + 1) * (areaWidth + 2)];
                        int j1 = aint[j + 1 - 1 + (i + 1) * (areaWidth + 2)];
                        int k1 = aint[j + 1 + (i + 1 + 1) * (areaWidth + 2)];

                        if (!isBiomeOceanic(l) && !isBiomeOceanic(i1) && !isBiomeOceanic(j1) && !isBiomeOceanic(k1))
                        {
                            if (isMesa(l) && isMesa(i1) && isMesa(j1) && isMesa(k1))
                            {
                                aint1[j + i * areaWidth] = k;
                            }
                            else
                            {
                                aint1[j + i * areaWidth] = Biome::getIdForBiome(Biomes::DESERT);
                            }
                        }
                        else
                        {
                            aint1[j + i * areaWidth] = k;
                        }
                    }
                }
                else
                {
                    replaceIfNeighborOcean(aint, aint1, j, i, areaWidth, k, Biome::getIdForBiome(Biomes::STONE_BEACH));
                }
            }
        }

        return aint1;
    }

    

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerSmooth.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerSmooth : public GenLayer {
public:
    GenLayerSmooth(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        int i = areaX - 1;
        int j = areaY - 1;
        int k = areaWidth + 2;
        int l = areaHeight + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        std::vector<int> aint1 = std::vector<int>(areaWidth * areaHeight); //int cache thingy

        for (int i1 = 0; i1 < areaHeight; ++i1)
        {
            for (int j1 = 0; j1 < areaWidth; ++j1)
            {
                int k1 = aint[j1 + 0 + (i1 + 1) * k];
                int l1 = aint[j1 + 2 + (i1 + 1) * k];
                int i2 = aint[j1 + 1 + (i1 + 0) * k];
                int j2 = aint[j1 + 1 + (i1 + 2) * k];
                int k2 = aint[j1 + 1 + (i1 + 1) * k];

                if (k1 == l1 && i2 == j2)
                {
                    initChunkSeed((long long)(j1 + areaX), (long long)(i1 + areaY));

                    if (NextInt(2) == 0)
                    {
                        k2 = k1;
                    }
                    else
                    {
                        k2 = i2;
                    }
                }
                else
                {
                    if (k1 == l1)
                    {
                        k2 = k1;
                    }

                    if (i2 == j2)
                    {
                        k2 = i2;
                    }
                }

                aint1[j1 + i1 * areaWidth] = k2;
            }
        }

        return aint1;
    }

};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerVoronoiZoom.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"

class GenLayerVoronoiZoom : public GenLayer {
public:
    GenLayerVoronoiZoom(long long int baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }


    std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        areaX = areaX - 2;
        areaY = areaY - 2;
        int i = areaX >> 2;
        int j = areaY >> 2;
        int k = (areaWidth >> 2) + 2;
        int l = (areaHeight >> 2) + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        int i1 = (k - 1) << 2;
        int j1 = (l - 1) << 2;
        std::vector<int> aint1 = std::vector<int>(i1 * j1); //IntCache.getIntCache(i1 * j1);

        for (int k1 = 0; k1 < l - 1; ++k1)
        {
            int l1 = 0;
            int i2 = aint[l1 + 0 + (k1 + 0) * k];

            for (int j2 = aint[l1 + 0 + (k1 + 1) * k]; l1 < k - 1; ++l1)
            {
                // double d0 = 3.6;
                initChunkSeed(static_cast<long long>(l1 + i) << 2, static_cast<long long>(k1 + j) << 2);
                double d1 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6;
                double d2 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6;
                initChunkSeed(static_cast<long long>(l1 + i + 1) << 2, static_cast<long long>(k1 + j) << 2);
                double d3 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6 + 4.0;
                double d4 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6;
                initChunkSeed(static_cast<long long>(l1 + i) << 2, static_cast<long long>(k1 + j + 1) << 2);
                double d5 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6;
                double d6 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6 + 4.0;
                initChunkSeed(static_cast<long long>(l1 + i + 1) << 2, static_cast<long long>(k1 + j + 1) << 2);
                double d7 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6 + 4.0;
                double d8 = ((double)NextInt(1024) / 1024.0 - 0.5) * 3.6 + 4.0;
                int k2 = aint[l1 + 1 + (k1 + 0) * k] & 255;
                int l2 = aint[l1 + 1 + (k1 + 1) * k] & 255;

                for (int i3 = 0; i3 < 4; ++i3)
                {
                    int j3 = ((k1 << 2) + i3) * i1 + (l1 << 2);

                    for (int k3 = 0; k3 < 4; ++k3)
                    {
                        double d9 = ((double)i3 - d2) * ((double)i3 - d2) + ((double)k3 - d1) * ((double)k3 - d1);
                        double d10 = ((double)i3 - d4) * ((double)i3 - d4) + ((double)k3 - d3) * ((double)k3 - d3);
                        double d11 = ((double)i3 - d6) * ((double)i3 - d6) + ((double)k3 - d5) * ((double)k3 - d5);
                        double d12 = ((double)i3 - d8) * ((double)i3 - d8) + ((double)k3 - d7) * ((double)k3 - d7);

                        if (d9 < d10 && d9 < d11 && d9 < d12)
                        {
                            aint1[j3++] = i2;
                        }
                        else if (d10 < d9 && d10 < d11 && d10 < d12)
                        {
                            aint1[j3++] = k2;
                        }
                        else if (d11 < d9 && d11 < d10 && d11 < d12)
                        {
                            aint1[j3++] = j2;
                        }
                        else
                        {
                            aint1[j3++] = l2;
                        }
                    }
                }

                i2 = k2;
                j2 = l2;
            }
        }

        std::vector<int> aint2 = std::vector<int>(areaWidth * areaHeight); // IntCache.getIntCache(areaWidth * areaHeight);

        for (int l3 = 0; l3 < areaHeight; ++l3) {
            std::copy(aint1.begin() + (l3 + (areaY & 3)) * i1 + (areaX & 3),
                aint1.begin() + (l3 + (areaY & 3)) * i1 + (areaX & 3) + areaWidth,
                aint2.begin() + l3 * areaWidth);
        }

        return aint2;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\GenLayerZoom.h"
#pragma once
#include "GenLayer.h"
#include "IntCache.h"
class GenLayerZoom : public GenLayer {
public:
    GenLayerZoom(long long baseSeedIn, GenLayer* parentIn) : GenLayer(baseSeedIn) {
        parent = parentIn;
    }

   std::vector<int> getInts(int areaX, int areaY, int areaWidth, int areaHeight) override {
        int i = areaX >> 1;
        int j = areaY >> 1;
        int k = (areaWidth >> 1) + 2;
        int l = (areaHeight >> 1) + 2;
        std::vector<int> aint = parent->getInts(i, j, k, l);
        int i1 = (k - 1) << 1;
        int j1 = (l - 1) << 1;
        std::vector<int> aint1 = std::vector<int>(i1 * j1); //int cache

        for (int k1 = 0; k1 < l - 1; ++k1)
        {
            int l1 = (k1 << 1) * i1;
            int i2 = 0;
            int j2 = aint[i2 + 0 + (k1 + 0) * k];

            for (int k2 = aint[i2 + 0 + (k1 + 1) * k]; i2 < k - 1; ++i2)
            {
                initChunkSeed(static_cast<long long>(i2 + i) << 1, static_cast<long long>(k1 + j) << 1);
                int l2 = aint[i2 + 1 + (k1 + 0) * k];
                int i3 = aint[i2 + 1 + (k1 + 1) * k];
                aint1[l1] = j2;
                aint1[l1++ + i1] = selectRandom({j2, k2});
                aint1[l1] = selectRandom({j2, l2});
                aint1[l1++ + i1] = selectModeOrRandom(j2, l2, k2, i3);
                j2 = l2;
                k2 = i3;
            }
        }

        std::vector<int> aint2 = std::vector<int>(areaWidth * areaHeight); //int cache

        for (int j3 = 0; j3 < areaHeight; ++j3)
        {
            std::copy(
                aint1.begin() + (j3 + (areaY & 1)) * i1 + (areaX & 1),
                aint1.begin() + (j3 + (areaY & 1)) * i1 + (areaX & 1) + areaWidth,
                aint2.begin() + j3 * areaWidth
            );
        }

        return aint2;
    }

    static GenLayer* magnify(long long p_75915_0_, GenLayer* p_75915_2_, int p_75915_3_) {
        GenLayer* genlayer = p_75915_2_;

        for (int i = 0; i < p_75915_3_; ++i)
        {
            genlayer = new GenLayerZoom(p_75915_0_ + (long long)i, genlayer);
        }

        return genlayer;
    }
};
"./Level\\TerrainGeneration\\GenLayer\\IntCache.h"
#pragma once
#include <vector>
#include <string>
#include <mutex>

class IntCache {
private:
    static int intCacheSize;
    static std::vector<int*> freeSmallArrays;
    static std::vector<int*> inUseSmallArrays;
    static std::vector<int*> freeLargeArrays;
    static std::vector<int*> inUseLargeArrays;

public:
    static int* getIntCache(int size) {
        std::lock_guard<std::mutex> lock(mutex);  // Add mutex lock for thread safety

        if (size <= 256) {
            if (freeSmallArrays.empty()) {
                int* array = new int[256];
                inUseSmallArrays.push_back(array);
                return array;
            }
            else {
                int* array = freeSmallArrays.back();
                freeSmallArrays.pop_back();
                inUseSmallArrays.push_back(array);
                return array;
            }
        }
        else if (size > intCacheSize) {
            intCacheSize = size; //add memory deallocators
            freeLargeArrays.clear();
            inUseLargeArrays.clear();
            int* array = new int[intCacheSize];
            inUseLargeArrays.push_back(array);
            return array;
        }
        else if (freeLargeArrays.empty()) {
            int* array = new int[intCacheSize];
            inUseLargeArrays.push_back(array);
            return array;
        }
        else {
            int* array = freeLargeArrays.back();
            freeLargeArrays.pop_back();
            inUseLargeArrays.push_back(array);
            return array;
        }
    }

    static void resetIntCache() {
        std::lock_guard<std::mutex> lock(mutex);  // Add mutex lock for thread safety

        if (!freeLargeArrays.empty()) {
            delete[] freeLargeArrays.back();
            freeLargeArrays.pop_back();
        }

        if (!freeSmallArrays.empty()) {
            delete[] freeSmallArrays.back();
            freeSmallArrays.pop_back();
        }

        for (auto array : inUseLargeArrays) {
            freeLargeArrays.push_back(array);
        }
        for (auto array : inUseSmallArrays) {
            freeSmallArrays.push_back(array);
        }

        inUseLargeArrays.clear();
        inUseSmallArrays.clear();
    }

    static std::string getCacheSizes() {
        std::lock_guard<std::mutex> lock(mutex);  // Add mutex lock for thread safety

        return "cache: " + std::to_string(freeLargeArrays.size()) +
            ", tcache: " + std::to_string(freeSmallArrays.size()) +
            ", allocated: " + std::to_string(inUseLargeArrays.size()) +
            ", tallocated: " + std::to_string(inUseSmallArrays.size());
    }

private:
    static std::mutex mutex; // Add mutex for thread safety
};

// Initialize static variables
inline int IntCache::intCacheSize = 256;
inline std::vector<int*> IntCache::freeSmallArrays;
inline std::vector<int*> IntCache::inUseSmallArrays;
inline std::vector<int*> IntCache::freeLargeArrays;
inline std::vector<int*> IntCache::inUseLargeArrays;
inline std::mutex IntCache::mutex;
"./Level\\TerrainGeneration\\MapGen\\MapGenBase.h"
#pragma once
#include "../Random/JavaRandom.h"
#include "../../Chunk/TallChunk.h"
#include "../../TerrainGeneration/Generator.h"

class MapGenBase {
protected:
    JavaRandom rand = JavaRandom();
    int range = 0;

    void generate(int x, int z, TallChunk* chunk)
    {
        int i = range;
        rand.SetSeed(WorldGenerator::world_seed_);
        long long j = rand.NextLong();
        long long k = rand.NextLong();

        for (int l = x - i; l <= x + i; ++l)
        {
            for (int i1 = z - i; i1 <= z + i; ++i1)
            {
                long long j1 = (long long)l * j;
                long long k1 = (long long)i1 * k;
                rand.SetSeed(j1 ^ k1 ^ WorldGenerator::world_seed_);
                recursiveGenerate(l, i1, x, z, chunk);
            }
        }
    }

    static void setupChunkSeed(long long seed, JavaRandom randIn, int p_191068_3_, int p_191068_4_)
    {
        randIn.SetSeed(seed);
        long i = randIn.NextLong();
        long j = randIn.NextLong();
        long k = (long)p_191068_3_ * i;
        long l = (long)p_191068_4_ * j;
        randIn.SetSeed(k ^ l ^ seed);
    }

    virtual void recursiveGenerate(int chunkX, int chunkZ, int originalX, int originalZ, TallChunk* chunk)
    {
    }
};
"./Level\\TerrainGeneration\\MapGen\\MapGenCaves.h"
//#pragma once
//#include "MapGenBase.h"
//#include "../../Chunk/Block/Blocks.h"
//
//class MapGenCaves : public MapGenBase
//{
//protected:
//    static BlockID BLK_LAVA;
//    static BlockID BLK_AIR;
//    static BlockID BLK_SANDSTONE;
//    static BlockID BLK_RED_SANDSTONE;
//
//    void addRoom(long p_180703_1_, int p_180703_3_, int p_180703_4_, Chunk* p_180703_5_, double p_180703_6_, double p_180703_8_, double p_180703_10_)
//    {
//        addTunnel(p_180703_1_, p_180703_3_, p_180703_4_, p_180703_5_, p_180703_6_, p_180703_8_, p_180703_10_, 1.0F + rand.nextFloat() * 6.0F, 0.0F, 0.0F, -1, -1, 0.5);
//    }
//
//    void addTunnel(long p_180702_1_, int p_180702_3_, int p_180702_4_, Chunk* p_180702_5_, double p_180702_6_, double p_180702_8_, double p_180702_10_, float p_180702_12_, float p_180702_13_, float p_180702_14_, int p_180702_15_, int p_180702_16_, double p_180702_17_)
//    {
//        double d0 = (double)(p_180702_3_ * 16 + 8);
//        double d1 = (double)(p_180702_4_ * 16 + 8);
//        float f = 0.0F;
//        float f1 = 0.0F;
//        JavaRandom random = JavaRandom(p_180702_1_);
//
//        if (p_180702_16_ <= 0)
//        {
//            int i = range * 16 - 16;
//            p_180702_16_ = i - random.nextInt(i / 4);
//        }
//
//        bool flag2 = false;
//
//        if (p_180702_15_ == -1)
//        {
//            p_180702_15_ = p_180702_16_ / 2;
//            flag2 = true;
//        }
//
//        int j = random.nextInt(p_180702_16_ / 2) + p_180702_16_ / 4;
//
//        for (bool flag = random.nextInt(6) == 0; p_180702_15_ < p_180702_16_; ++p_180702_15_)
//        {
//            double d2 = 1.5 + (double)(sin((float)p_180702_15_ * (float)3.14159265358979323 / (float)p_180702_16_) * p_180702_12_);
//            double d3 = d2 * p_180702_17_;
//            float f2 = cos(p_180702_14_);
//            float f3 = sin(p_180702_14_);
//            p_180702_6_ += (double)(cos(p_180702_13_) * f2);
//            p_180702_8_ += (double)f3;
//            p_180702_10_ += (double)(sin(p_180702_13_) * f2);
//
//            if (flag)
//            {
//                p_180702_14_ = p_180702_14_ * 0.92F;
//            }
//            else
//            {
//                p_180702_14_ = p_180702_14_ * 0.7F;
//            }
//
//            p_180702_14_ = p_180702_14_ + f1 * 0.1F;
//            p_180702_13_ += f * 0.1F;
//            f1 = f1 * 0.9F;
//            f = f * 0.75F;
//            f1 = f1 + (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 2.0F;
//            f = f + (random.nextFloat() - random.nextFloat()) * random.nextFloat() * 4.0F;
//
//            if (!flag2 && p_180702_15_ == j && p_180702_12_ > 1.0F && p_180702_16_ > 0)
//            {
//                addTunnel(random.nextLong(), p_180702_3_, p_180702_4_, p_180702_5_, p_180702_6_, p_180702_8_, p_180702_10_, random.nextFloat() * 0.5F + 0.5F, p_180702_13_ - ((float)3.14159265358979323 / 2F), p_180702_14_ / 3.0F, p_180702_15_, p_180702_16_, 1.0);
//                addTunnel(random.nextLong(), p_180702_3_, p_180702_4_, p_180702_5_, p_180702_6_, p_180702_8_, p_180702_10_, random.nextFloat() * 0.5F + 0.5F, p_180702_13_ + ((float)3.14159265358979323 / 2F), p_180702_14_ / 3.0F, p_180702_15_, p_180702_16_, 1.0);
//                return;
//            }
//
//            if (flag2 || random.nextInt(4) != 0)
//            {
//                double d4 = p_180702_6_ - d0;
//                double d5 = p_180702_10_ - d1;
//                double d6 = (double)(p_180702_16_ - p_180702_15_);
//                double d7 = (double)(p_180702_12_ + 2.0F + 16.0F);
//
//                if (d4 * d4 + d5 * d5 - d6 * d6 > d7 * d7)
//                {
//                    return;
//                }
//
//                if (p_180702_6_ >= d0 - 16.0 - d2 * 2.0 && p_180702_10_ >= d1 - 16.0 - d2 * 2.0 && p_180702_6_ <= d0 + 16.0 + d2 * 2.0 && p_180702_10_ <= d1 + 16.0 + d2 * 2.0)
//                {
//                    int k2 = floor(p_180702_6_ - d2) - p_180702_3_ * 16 - 1;
//                    int k = floor(p_180702_6_ + d2) - p_180702_3_ * 16 + 1;
//                    int l2 = floor(p_180702_8_ - d3) - 1;
//                    int l = floor(p_180702_8_ + d3) + 1;
//                    int i3 = floor(p_180702_10_ - d2) - p_180702_4_ * 16 - 1;
//                    int i1 = floor(p_180702_10_ + d2) - p_180702_4_ * 16 + 1;
//
//                    if (k2 < 0)
//                    {
//                        k2 = 0;
//                    }
//
//                    if (k > 16)
//                    {
//                        k = 16;
//                    }
//
//                    if (l2 < 1)
//                    {
//                        l2 = 1;
//                    }
//
//                    if (l > 248)
//                    {
//                        l = 248;
//                    }
//
//                    if (i3 < 0)
//                    {
//                        i3 = 0;
//                    }
//
//                    if (i1 > 16)
//                    {
//                        i1 = 16;
//                    }
//
//                    bool flag3 = false;
//
//                    for (int j1 = k2; !flag3 && j1 < k; ++j1)
//                    {
//                        for (int k1 = i3; !flag3 && k1 < i1; ++k1)
//                        {
//                            for (int l1 = l + 1; !flag3 && l1 >= l2 - 1; --l1)
//                            {
//                                if (l1 >= 0 && l1 < 256)
//                                {
//                                    BlockID iblockstate = p_180702_5_.getBlockState(j1, l1, k1);
//
//                                    if (iblockstate == Blocks.FLOWING_WATER || iblockstate == Blocks.WATER)
//                                    {
//                                        flag3 = true;
//                                    }
//
//                                    if (l1 != l2 - 1 && j1 != k2 && j1 != k - 1 && k1 != i3 && k1 != i1 - 1)
//                                    {
//                                        l1 = l2;
//                                    }
//                                }
//                            }
//                        }
//                    }
//
//                    if (!flag3)
//                    {
//                        BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
//
//                        for (int j3 = k2; j3 < k; ++j3)
//                        {
//                            double d10 = ((double)(j3 + p_180702_3_ * 16) + 0.5 - p_180702_6_) / d2;
//
//                            for (int i2 = i3; i2 < i1; ++i2)
//                            {
//                                double d8 = ((double)(i2 + p_180702_4_ * 16) + 0.5 - p_180702_10_) / d2;
//                                bool flag1 = false;
//
//                                if (d10* d10 + d8 * d8 < 1.0)
//                                {
//                                    for (int j2 = l; j2 > l2; --j2)
//                                    {
//                                        double d9 = ((double)(j2 - 1) + 0.5 - p_180702_8_) / d3;
//
//                                        if (d9 > -0.7 && d10 * d10 + d9 * d9 + d8 * d8 < 1.0)
//                                        {
//                                            BlockID iblockstate1 = p_180702_5_->GetBlockUnsafe(j3, j2, i2);
//                                            BlockID iblockstate2 = (BlockID)MoreObjects.firstNonNull(p_180702_5_, BLK_AIR);
//
//                                            if (iblockstate1 == Blocks.GRASS || iblockstate1 == Blocks.MYCELIUM)
//                                            {
//                                                flag1 = true;
//                                            }
//
//                                            if (canReplaceBlock(iblockstate1, iblockstate2))
//                                            {
//                                                if (j2 - 1 < 10)
//                                                {
//                                                    p_180702_5_->SetBlockUnsafe(j3, j2, i2, BLK_LAVA);
//                                                }
//                                                else
//                                                {
//                                                    p_180702_5_->SetBlockUnsafe(j3, j2, i2, BLK_AIR);
//
//                                                    if (flag1 && p_180702_5_.getBlockState(j3, j2 - 1, i2) == Blocks.DIRT)
//                                                    {
//                                                        blockpos$mutableblockpos.setPos(j3 + p_180702_3_ * 16, 0, i2 + p_180702_4_ * 16);
//                                                        p_180702_5_.setBlockState(j3, j2 - 1, i2, world.getBiome(blockpos$mutableblockpos).topBlock.getDefaultState());
//                                                    }
//                                                }
//                                            }
//                                        }
//                                    }
//                                }
//                            }
//                        }
//
//                        if (flag2)
//                        {
//                            break;
//                        }
//                    }
//                }
//            }
//        }
//    }
//
//    bool canReplaceBlock(BlockID p_175793_1_, BlockID p_175793_2_)
//    {
//        if (p_175793_1_ == Blocks.STONE)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.DIRT)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.GRASS)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.TERRACOTTA)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.WHITE_TERRACOTTA)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.SANDSTONE)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.RED_SANDSTONE)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.MYCELIUM)
//        {
//            return true;
//        }
//        else if (p_175793_1_ == Blocks.SNOW_BLOCK)
//        {
//            return true;
//        }
//        else
//        {
//            return (p_175793_1_ == Blocks.SAND || p_175793_1_ == Blocks.GRAVEL) && p_175793_2_ != Blocks.WATER;
//        }
//    }
//
//    /**
//     * Recursively called by generate()
//     */
//    void recursiveGenerate(int chunkX, int chunkZ, int originalX, int originalZ, Chunk* chunk) override {
//        int i = rand.nextInt(rand.nextInt(rand.nextInt(15) + 1) + 1);
//
//        if (rand.nextInt(7) != 0)
//        {
//            i = 0;
//        }
//
//        for (int j = 0; j < i; ++j)
//        {
//            double d0 = (double)(chunkX * 16 + rand.nextInt(16));
//            double d1 = (double)rand.nextInt(rand.nextInt(120) + 8);
//            double d2 = (double)(chunkZ * 16 + rand.nextInt(16));
//            int k = 1;
//
//            if (rand.nextInt(4) == 0)
//            {
//                addRoom(rand.nextLong(), originalX, originalZ, chunk, d0, d1, d2);
//                k += rand.nextInt(4);
//            }
//
//            for (int l = 0; l < k; ++l)
//            {
//                float f = rand.nextFloat() * ((float)3.14159265358979323 * 2.0F);
//                float f1 = (rand.nextFloat() - 0.5F) * 2.0F / 8.0F;
//                float f2 = rand.nextFloat() * 2.0F + rand.nextFloat();
//
//                if (rand.nextInt(10) == 0)
//                {
//                    f2 *= rand.nextFloat() * rand.nextFloat() * 3.0F + 1.0F;
//                }
//
//                addTunnel(rand.nextLong(), originalX, originalZ, chunk, d0, d1, d2, f2, f, f1, 0, 0, 1.0);
//            }
//        }
//    }
//};
//
//BlockID MapGenCaves::BLK_LAVA = Blocks.LAVA;
//BlockID MapGenCaves::BLK_AIR = Blocks.AIR;
//BlockID MapGenCaves::BLK_SANDSTONE = Blocks;
//BlockID MapGenCaves::BLK_RED_SANDSTONE = Blocks;
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGenerator.cpp"
#include "MinecraftNoiseGenerator.h"

static constexpr const double GRAD_X[16] = { 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0, 0.0 };
static constexpr const double GRAD_Y[16] = { 1.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0 };
static constexpr const double GRAD_Z[16] = { 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, -1.0 };
static constexpr const double GRAD_2X[16] = { 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0, 0.0 };
static constexpr const double GRAD_2Z[16] = { 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, -1.0 };

double NoiseGeneratorImproved::lerp(double p_76311_1_, double p_76311_3_, double p_76311_5_) {
    return p_76311_3_ + p_76311_1_ * (p_76311_5_ - p_76311_3_);
}

double NoiseGeneratorImproved::grad2(int p_76309_1_, double p_76309_2_, double p_76309_4_) {
    int i = p_76309_1_ & 15;
    return GRAD_2X[i] * p_76309_2_ + GRAD_2Z[i] * p_76309_4_;
}

double NoiseGeneratorImproved::grad(int p_76310_1_, double p_76310_2_, double p_76310_4_, double p_76310_6_) {
    int i = p_76310_1_ & 15;
    return GRAD_X[i] * p_76310_2_ + GRAD_Y[i] * p_76310_4_ + GRAD_Z[i] * p_76310_6_;
}

/**
 * noiseArray should be xSize*ySize*zSize in size
 */
void NoiseGeneratorImproved::populateNoiseArray(std::vector<double>& noiseArray, double xOffset, double yOffset, double zOffset, int xSize, int ySize, int zSize, double xScale, double yScale, double zScale, double noiseScale) {
    if (ySize == 1) {
        int i5 = 0;
        int j5 = 0;
        int j = 0;
        int k5 = 0;
        double d14 = 0.0;
        double d15 = 0.0;
        int l5 = 0;
        double d16 = 1.0 / noiseScale;

        for (int j2 = 0; j2 < xSize; ++j2) {
            double d17 = xOffset + (double)j2 * xScale + xCoord;
            int i6 = (int)d17;

            if (d17 < (double)i6) {
                --i6;
            }

            int k2 = i6 & 255;
            d17 = d17 - (double)i6;
            double d18 = d17 * d17 * d17 * (d17 * (d17 * 6.0 - 15.0) + 10.0);

            for (int j6 = 0; j6 < zSize; ++j6) {
                double d19 = zOffset + (double)j6 * zScale + zCoord;
                int k6 = (int)d19;

                if (d19 < (double)k6) {
                    --k6;
                }

                int l6 = k6 & 255;
                d19 = d19 - (double)k6;
                double d20 = d19 * d19 * d19 * (d19 * (d19 * 6.0 - 15.0) + 10.0);
                i5 = permutations[k2] + 0;
                j5 = permutations[i5] + l6;
                j = permutations[k2 + 1] + 0;
                k5 = permutations[j] + l6;
                d14 = lerp(d18, grad2(permutations[j5], d17, d19), grad(permutations[k5], d17 - 1.0, 0.0, d19));
                d15 = lerp(d18, grad(permutations[j5 + 1], d17, 0.0, d19 - 1.0), grad(permutations[k5 + 1], d17 - 1.0, 0.0, d19 - 1.0));
                double d21 = lerp(d20, d14, d15);
                int i7 = l5++;
                noiseArray[i7] += d21 * d16;
            }
        }
    } else {
        int i = 0;
        double d0 = 1.0 / noiseScale;
        int k = -1;
        int l = 0;
        int i1 = 0;
        int j1 = 0;
        int k1 = 0;
        int l1 = 0;
        int i2 = 0;
        double d1 = 0.0;
        double d2 = 0.0;
        double d3 = 0.0;
        double d4 = 0.0;

        for (int l2 = 0; l2 < xSize; ++l2) {
            double d5 = xOffset + (double)l2 * xScale + xCoord;
            int i3 = (int)d5;

            if (d5 < (double)i3) {
                --i3;
            }

            int j3 = i3 & 255;
            d5 = d5 - (double)i3;
            double d6 = d5 * d5 * d5 * (d5 * (d5 * 6.0 - 15.0) + 10.0);

            for (int k3 = 0; k3 < zSize; ++k3) {
                double d7 = zOffset + (double)k3 * zScale + zCoord;
                int l3 = (int)d7;

                if (d7 < (double)l3) {
                    --l3;
                }

                int i4 = l3 & 255;
                d7 = d7 - (double)l3;
                double d8 = d7 * d7 * d7 * (d7 * (d7 * 6.0 - 15.0) + 10.0);

                for (int j4 = 0; j4 < ySize; ++j4) {
                    double d9 = yOffset + (double)j4 * yScale + yCoord;
                    int k4 = (int)d9;

                    if (d9 < (double)k4) {
                        --k4;
                    }

                    int l4 = k4 & 255;
                    d9 = d9 - (double)k4;
                    double d10 = d9 * d9 * d9 * (d9 * (d9 * 6.0 - 15.0) + 10.0);

                    if (j4 == 0 || l4 != k) {
                        k = l4;
                        l = permutations[j3] + l4;
                        i1 = permutations[l] + i4;
                        j1 = permutations[l + 1] + i4;
                        k1 = permutations[j3 + 1] + l4;
                        l1 = permutations[k1] + i4;
                        i2 = permutations[k1 + 1] + i4;
                        d1 = lerp(d6, grad(permutations[i1], d5, d9, d7), grad(permutations[l1], d5 - 1.0, d9, d7));
                        d2 = lerp(d6, grad(permutations[j1], d5, d9 - 1.0, d7), grad(permutations[i2], d5 - 1.0, d9 - 1.0, d7));
                        d3 = lerp(d6, grad(permutations[i1 + 1], d5, d9, d7 - 1.0), grad(permutations[l1 + 1], d5 - 1.0, d9, d7 - 1.0));
                        d4 = lerp(d6, grad(permutations[j1 + 1], d5, d9 - 1.0, d7 - 1.0), grad(permutations[i2 + 1], d5 - 1.0, d9 - 1.0, d7 - 1.0));
                    }

                    double d11 = lerp(d10, d1, d2);
                    double d12 = lerp(d10, d3, d4);
                    double d13 = lerp(d8, d11, d12);
                    int j7 = i++;
                    noiseArray[j7] += d13 * d0;
                }
            }
        }
    }
}
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGenerator.h"
#pragma once
#include "../Random/JavaRandom.h"
//directly copied from mc source code


class NoiseGeneratorImproved {
private:
    std::vector<int> permutations;

public:
    double xCoord;
    double yCoord;
    double zCoord;
    
    ~NoiseGeneratorImproved() {
    }

    NoiseGeneratorImproved(JavaRandom& random) {

        permutations.resize(512);
        xCoord = random.NextDouble() * 256.0;
        yCoord = random.NextDouble() * 256.0;
        zCoord = random.NextDouble() * 256.0;

        for (int i = 0; i < 256; permutations[i] = i++) {
        }

        for (int l = 0; l < 256; ++l) {
            int j = random.NextInt(256 - l) + l;
            int k = permutations[l];
            permutations[l] = permutations[j];
            permutations[j] = k;
            permutations[l + 256] = permutations[l];
        }
    }

    double lerp(double p_76311_1_, double p_76311_3_, double p_76311_5_);

    double grad2(int p_76309_1_, double p_76309_2_, double p_76309_4_);

    double grad(int p_76310_1_, double p_76310_2_, double p_76310_4_, double p_76310_6_);
    /**
     * noiseArray should be xSize*ySize*zSize in size
     */
    void populateNoiseArray(std::vector<double>& noiseArray, double xOffset, double yOffset, double zOffset, int xSize, int ySize, int zSize, double xScale, double yScale, double zScale, double noiseScale);
};
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGeneratorPerlin.cpp"
#include "MinecraftNoiseGeneratorPerlin.h"

double NoiseGeneratorPerlin::getValue(double p_151601_1_, double p_151601_3_) {
    double d0 = 0.0;
    double d1 = 1.0;

    for (int i = 0; i < levels; ++i)
    {
        d0 += noiseLevels[i].getValue(p_151601_1_ * d1, p_151601_3_ * d1) / d1;
        d1 /= 2.0;
    }

    return d0;
}

std::vector<double> NoiseGeneratorPerlin::getRegion(std::vector<double>& p_151599_1_, double p_151599_2_, double p_151599_4_, int p_151599_6_, int p_151599_7_, double p_151599_8_, double p_151599_10_, double p_151599_12_) {
    return getRegion(p_151599_1_, p_151599_2_, p_151599_4_, p_151599_6_, p_151599_7_, p_151599_8_, p_151599_10_, p_151599_12_, 0.5);
}

std::vector<double> NoiseGeneratorPerlin::getRegion(std::vector<double>& p_151600_1_, double p_151600_2_, double p_151600_4_, int p_151600_6_, int p_151600_7_, double p_151600_8_, double p_151600_10_, double p_151600_12_, double p_151600_14_) {
    if ((p_151600_1_.size() == 0) && p_151600_1_.size() >= p_151600_6_ * p_151600_7_) {
        for (int i = 0; i < p_151600_1_.size(); ++i) {
            p_151600_1_[i] = 0.0;
        }
    }
    else {
        p_151600_1_ = std::vector<double>(p_151600_6_ * p_151600_7_);
    }

    double d1 = 1.0;
    double d0 = 1.0;

    for (int j = 0; j < levels; ++j) {
        noiseLevels[j].add(p_151600_1_, p_151600_2_, p_151600_4_, p_151600_6_, p_151600_7_, p_151600_8_ * d0 * d1, p_151600_10_ * d0 * d1, 0.55 / d1);
        d0 *= p_151600_12_;
        d1 *= p_151600_14_;
    }

    return p_151600_1_;
}
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGeneratorPerlin.h"
#pragma once
#include "MinecraftNoiseGeneratorSimplex.h"

//copy paste mc src ported to c++


class NoiseGeneratorPerlin
{

private:
    std::vector<NoiseGeneratorSimplex> noiseLevels;
    int levels;

public:

    ~NoiseGeneratorPerlin() {
    }

    NoiseGeneratorPerlin(JavaRandom seed, int levelsIn) {
        levels = levelsIn;
        noiseLevels = std::vector<NoiseGeneratorSimplex>(levelsIn);

        for (int i = 0; i < levelsIn; ++i)
        {
            noiseLevels[i] = NoiseGeneratorSimplex(seed);
        }
    }

    double getValue(double p_151601_1_, double p_151601_3_);

    std::vector<double> getRegion(std::vector<double>& p_151599_1_, double p_151599_2_, double p_151599_4_, int p_151599_6_, int p_151599_7_, double p_151599_8_, double p_151599_10_, double p_151599_12_);

    std::vector<double> getRegion(std::vector<double>& p_151600_1_, double p_151600_2_, double p_151600_4_, int p_151600_6_, int p_151600_7_, double p_151600_8_, double p_151600_10_, double p_151600_12_, double p_151600_14_);
};
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGeneratorSimplex.cpp"
#include "MinecraftNoiseGeneratorSimplex.h"

static constexpr const int grad3[12][3]{ {1, 1, 0}, { -1, 1, 0}, {1, -1, 0}, { -1, -1, 0}, {1, 0, 1}, { -1, 0, 1}, {1, 0, -1}, { -1, 0, -1}, {0, 1, 1}, {0, -1, 1}, {0, 1, -1}, {0, -1, -1} };

int NoiseGeneratorSimplex::fastFloor(double value) {
    return value > 0.0 ? (int)value : (int)value - 1;
}

double NoiseGeneratorSimplex::dot(const int p_151604_0_[], double p_151604_1_, double p_151604_3_) {
    return (double)p_151604_0_[0] * p_151604_1_ + (double)p_151604_0_[1] * p_151604_3_;
}

double NoiseGeneratorSimplex::getValue(double p_151605_1_, double p_151605_3_) {
    double d3 = 0.5 * (SQRT_3 - 1.0);
    double d4 = (p_151605_1_ + p_151605_3_) * d3;
    int i = fastFloor(p_151605_1_ + d4);
    int j = fastFloor(p_151605_3_ + d4);
    double d5 = (3.0 - SQRT_3) / 6.0;
    double d6 = (double)(i + j) * d5;
    double d7 = (double)i - d6;
    double d8 = (double)j - d6;
    double d9 = p_151605_1_ - d7;
    double d10 = p_151605_3_ - d8;
    int k;
    int l;

    if (d9 > d10) {
        k = 1;
        l = 0;
    }
    else {
        k = 0;
        l = 1;
    }

    double d11 = d9 - (double)k + d5;
    double d12 = d10 - (double)l + d5;
    double d13 = d9 - 1.0 + 2.0 * d5;
    double d14 = d10 - 1.0 + 2.0 * d5;
    int i1 = i & 255;
    int j1 = j & 255;
    int k1 = p[i1 + p[j1]] % 12;
    int l1 = p[i1 + k + p[j1 + l]] % 12;
    int i2 = p[i1 + 1 + p[j1 + 1]] % 12;
    double d15 = 0.5 - d9 * d9 - d10 * d10;
    double d0;

    if (d15 < 0.0) {
        d0 = 0.0;
    }
    else {
        d15 = d15 * d15;
        d0 = d15 * d15 * dot(grad3[k1], d9, d10);
    }

    double d16 = 0.5 - d11 * d11 - d12 * d12;
    double d1;

    if (d16 < 0.0) {
        d1 = 0.0;
    }
    else {
        d16 = d16 * d16;
        d1 = d16 * d16 * dot(grad3[l1], d11, d12);
    }

    double d17 = 0.5 - d13 * d13 - d14 * d14;
    double d2;

    if (d17 < 0.0) {
        d2 = 0.0;
    }
    else {
        d17 = d17 * d17;
        d2 = d17 * d17 * dot(grad3[i2], d13, d14);
    }

    return 70.0 * (d0 + d1 + d2);
}

void NoiseGeneratorSimplex::add(std::vector<double>& p_151606_1_, double p_151606_2_, double p_151606_4_, int p_151606_6_, int p_151606_7_, double p_151606_8_, double p_151606_10_, double p_151606_12_) {
    int i = 0;

    for (int j = 0; j < p_151606_7_; ++j) {
        double d0 = (p_151606_4_ + (double)j) * p_151606_10_ + yo;
        for (int k = 0; k < p_151606_6_; ++k) {
            double d1 = (p_151606_2_ + (double)k) * p_151606_8_ + xo;
            double d5 = (d1 + d0) * F2;
            int l = fastFloor(d1 + d5);
            int i1 = fastFloor(d0 + d5);
            double d6 = (double)(l + i1) * G2;
            double d7 = (double)l - d6;
            double d8 = (double)i1 - d6;
            double d9 = d1 - d7;
            double d10 = d0 - d8;
            int j1;
            int k1;

            if (d9 > d10) {
                j1 = 1;
                k1 = 0;
            }
            else {
                j1 = 0;
                k1 = 1;
            }

            double d11 = d9 - (double)j1 + G2;
            double d12 = d10 - (double)k1 + G2;
            double d13 = d9 - 1.0 + 2.0 * G2;
            double d14 = d10 - 1.0 + 2.0 * G2;
            int l1 = l & 255;
            int i2 = i1 & 255;
            int j2 = p[l1 + p[i2]] % 12;
            int k2 = p[l1 + j1 + p[i2 + k1]] % 12;
            int l2 = p[l1 + 1 + p[i2 + 1]] % 12;
            double d15 = 0.5 - d9 * d9 - d10 * d10;
            double d2;

            if (d15 < 0.0) {
                d2 = 0.0;
            }
            else {
                d15 = d15 * d15;
                d2 = d15 * d15 * dot(grad3[j2], d9, d10);
            }

            double d16 = 0.5 - d11 * d11 - d12 * d12;
            double d3;

            if (d16 < 0.0) {
                d3 = 0.0;
            }
            else {
                d16 = d16 * d16;
                d3 = d16 * d16 * dot(grad3[k2], d11, d12);
            }

            double d17 = 0.5 - d13 * d13 - d14 * d14;
            double d4;

            if (d17 < 0.0) {
                d4 = 0.0;
            }
            else {
                d17 = d17 * d17;
                d4 = d17 * d17 * dot(grad3[l2], d13, d14);
            }

            int i3 = i++;
            p_151606_1_[i3] += 70.0 * (d2 + d3 + d4) * p_151606_12_;
        }
    }
}
"./Level\\TerrainGeneration\\Noisemaps\\MinecraftNoiseGeneratorSimplex.h"
#pragma once
#include "../Random/JavaRandom.h"
#include <cmath>
#include <vector>

//copy paste mc src ported to c++

class NoiseGeneratorSimplex {
private:

    std::vector<int> p;

    int fastFloor(double value);

    double dot(const int p_151604_0_[], double p_151604_1_, double p_151604_3_);

    double SQRT_3 = sqrt(3.0);

    double F2 = 0.5 * (SQRT_3 - 1.0);
    double G2 = (3.0 - SQRT_3) / 6.0;

public:

    double xo;
    double yo;
    double zo;

    void Initialize(JavaRandom& seed) {
        p.resize(512);
        xo = seed.NextDouble() * 256.0;
        yo = seed.NextDouble() * 256.0;
        zo = seed.NextDouble() * 256.0;

        for (int i = 0; i < 256; p[i] = i++)
        {
            ;
        }

        for (int l = 0; l < 256; ++l)
        {
            int j = seed.NextInt(256 - l) + l;
            int k = p[l];
            p[l] = p[j];
            p[j] = k;
            p[l + 256] = p[l];
        }
    }

    ~NoiseGeneratorSimplex() {
    }

    
    NoiseGeneratorSimplex(JavaRandom& seed) {
        Initialize(seed);
    }

    NoiseGeneratorSimplex() {
        JavaRandom random;
        Initialize(random);
    }


    double getValue(double p_151605_1_, double p_151605_3_);

    void add(std::vector<double>& p_151606_1_, double p_151606_2_, double p_151606_4_, int p_151606_6_, int p_151606_7_, double p_151606_8_, double p_151606_10_, double p_151606_12_);
};
"./Level\\TerrainGeneration\\Noisemaps\\Noise.h"
#pragma once
#include "../../../Utils/FastNoiseLite.h"
#include "../Random/JavaRandom.h"

class NoiseGenerator {
private:
    FastNoiseLite noise;

public:
    NoiseGenerator(JavaRandom seed) {
        (void)seed; //TODO Check this again later
    }
};
"./Level\\TerrainGeneration\\Noisemaps\\Noisemap.cpp"
#include "Noisemap.h"

void NoiseMapTypes::Initialize(int32_t SEED) {
    IslandLayer4096.SetNoiseType(IslandLayer4096.NoiseType_OpenSimplex2);
    IslandLayer4096.SetFrequency(1.f / 256.f);
    IslandLayer4096.SetSeed(SEED);

    IslandLayer2048.SetNoiseType(IslandLayer4096.NoiseType_OpenSimplex2);
    IslandLayer2048.SetFrequency(1.f / 128.f);
    IslandLayer2048.SetSeed(SEED + SEED_OFFSET);

    TemperatureLayer512.SetNoiseType(TemperatureLayer512.NoiseType_OpenSimplex2);
    TemperatureLayer512.SetFrequency(1.f / 32.f);
    TemperatureLayer512.SetSeed(SEED + SEED_OFFSET * 3);

    RainfallLayer512.SetNoiseType(RainfallLayer512.NoiseType_OpenSimplex2);
    RainfallLayer512.SetFrequency(1.f / 32.f);
    RainfallLayer512.SetSeed(SEED + SEED_OFFSET * 5);

    OctaveNoise.SetNoiseType(OctaveNoise.NoiseType_OpenSimplex2);
    OctaveNoise.SetFrequency(1.f);
    OctaveNoise.SetSeed(SEED + SEED_OFFSET * 5);

    float Half = 1.0;
    float Two = 1;

    for (int i = 0; i < 32; i++) {
        PowTableHalf[i] = Half;
        PowTable[i] = Two;
        Half = Half * 0.5f;
        Two = Two * 2.0f;
    }
}

template <typename T> float NoiseMapTypes::GetNoise(T x, T y, T z, int Octaves, float zoom_) {
    float gx = static_cast<float>(x);
    float gy = static_cast<float>(y);
    float gz = static_cast<float>(z);

    float out = 0.0f;

    for (int i = 0; i < Octaves; i++) {
        float n = (OctaveNoise.GetNoise(gx * PowTable[i], gy * PowTable[i], gz * PowTable[i]) + 1) * 0.5f;
        out += n * PowTableHalf[i];
    }

    out = out * ((-0.5f) / (PowTableHalf[Octaves] - 1));

    return out;
}
"./Level\\TerrainGeneration\\Noisemaps\\Noisemap.h"
#pragma once
#include "../../../Utils/FastNoiseLite.h"

class NoiseMapTypes {
public:
    void Initialize(int32_t SEED);

    template <typename T> float GetNoise(T x, T y, T z, int Octaves, float zoom_);

    FastNoiseLite IslandLayer4096;
    FastNoiseLite IslandLayer2048;
    FastNoiseLite TemperatureLayer512;
    FastNoiseLite RainfallLayer512;
private:

    float PowTableHalf[32]{};
    float PowTable[32]{};

    FastNoiseLite OctaveNoise;

    int32_t SEED_OFFSET = 0x93496;
};

class NoiseMaps1122 {
public:
    FastNoiseLite minLimitPerlinNoise;
    FastNoiseLite maxLimitPerlinNoise;
    FastNoiseLite mainPerlinNoise;
    FastNoiseLite surfaceNoise;
    FastNoiseLite scaleNoise;
    FastNoiseLite depthNoise;
    FastNoiseLite forestNoise;
};
"./Level\\TerrainGeneration\\Noisemaps\\NoiseOctave.cpp"
#include "NoiseOctave.h"

int64_t NoiseOctave::lfloor(double value) {
    int64_t i = (int64_t)value;
    return value < (double)i ? i - 1L : i;
}

std::vector<double> NoiseOctave::generateNoiseOctaves(std::vector<double>& noiseArray, int xOffset, int yOffset, int zOffset, int xSize, int ySize, int zSize, double xScale, double yScale, double zScale) {
    if (noiseArray.size() == 0) {
        noiseArray.resize(xSize * ySize * zSize);
    }
    else {
        for (int i = 0; i < noiseArray.size(); ++i)
        {
            noiseArray[i] = 0.0;
        }
    }

    double d3 = 1.0;

    for (int j = 0; j < octaves; ++j)
    {
        double d0 = (double)xOffset * d3 * xScale;
        double d1 = (double)yOffset * d3 * yScale;
        double d2 = (double)zOffset * d3 * zScale;
        int64_t k = lfloor(d0);
        int64_t l = lfloor(d2);
        d0 = d0 - (double)k;
        d2 = d2 - (double)l;
        k = k % 16777216LL;
        l = l % 16777216LL;
        d0 = d0 + (double)k;
        d2 = d2 + (double)l;
        generatorCollection[j].populateNoiseArray(noiseArray, d0, d1, d2, xSize, ySize, zSize, xScale * d3, yScale * d3, zScale * d3, d3);

        d3 /= 2.0;
    }

    return noiseArray;

}

std::vector<double> NoiseOctave::generateNoiseOctaves(std::vector<double>& noiseArray, int xOffset, int zOffset, int xSize, int zSize, double xScale, double zScale, double p_76305_10_) {
    return generateNoiseOctaves(noiseArray, xOffset, 10, zOffset, xSize, 1, zSize, xScale, 1.0, zScale);
}
"./Level\\TerrainGeneration\\Noisemaps\\NoiseOctave.h"
#pragma once
#include <vector>
#include "Noise.h"
#include "MinecraftNoiseGenerator.h"

class NoiseOctave {

private:

    static int64_t lfloor(double value);

    int octaves = NULL;
    std::vector<NoiseGeneratorImproved> generatorCollection;
public:
    NoiseOctave(JavaRandom& seed, int octavesIn) {
        octaves = octavesIn;
        
        for (int i = 0; i < octavesIn; i++) {
            generatorCollection.emplace_back(seed);
        }
    }

    NoiseOctave() {

    }

    std::vector<double> generateNoiseOctaves(std::vector<double>& noiseArray, int xOffset, int yOffset, int zOffset, int xSize, int ySize, int zSize, double xScale, double yScale, double zScale);

    std::vector<double> generateNoiseOctaves(std::vector<double>& noiseArray, int xOffset, int zOffset, int xSize, int zSize, double xScale, double zScale, double p_76305_10_);


};
"./Level\\TerrainGeneration\\Noisemaps\\TerrainParameters.h"
#pragma once

struct TerrainParamters {
    float HeightIntensity = 96.f;
    float HeightOffset = -16.f;
};
struct ChunkGeneratorSettings {
     float coordinateScale = 684.412F;
     float heightScale = 684.412F;
     float upperLimitScale = 512.0F;
     float lowerLimitScale = 512.0F;
     float depthNoiseScaleX = 200.0F;
     float depthNoiseScaleZ = 200.0F;
     float depthNoiseScaleExponent = 0.5F;
     float mainNoiseScaleX = 80.0F;
     float mainNoiseScaleY = 160.0F;
     float mainNoiseScaleZ = 80.0F;
     float baseSize = 8.5F;
     float stretchY = 12.0F;
     float biomeDepthWeight = 1.0F;
     float biomeDepthOffset = 0.0F;
     float biomeScaleWeight = 1.0F;
     float biomeScaleOffset = 0.0F;
     int seaLevel = 63;
     bool useCaves = true;
     bool useDungeons = true;
     int dungeonChance = 8;
     bool useStrongholds = true;
     bool useVillages = true;
     bool useMineShafts = true;
     bool useTemples = true;
     bool useMonuments = true;
     bool useMansions = true;
     bool useRavines = true;
     bool useWaterLakes = true;
     int waterLakeChance = 4;
     bool useLavaLakes = true;
     int lavaLakeChance = 80;
     bool useLavaOceans = NULL;
     int fixedBiome = -1;
     int biomeSize = 4;
     int riverSize = 4;
     int dirtSize = 33;
     int dirtCount = 10;
     int dirtMinHeight = NULL;
     int dirtMaxHeight = 256;
     int gravelSize = 33;
     int gravelCount = 8;
     int gravelMinHeight = NULL;
     int gravelMaxHeight = 256;
     int graniteSize = 33;
     int graniteCount = 10;
     int graniteMinHeight = NULL;
     int graniteMaxHeight = 80;
     int dioriteSize = 33;
     int dioriteCount = 10;
     int dioriteMinHeight = NULL;
     int dioriteMaxHeight = 80;
     int andesiteSize = 33;
     int andesiteCount = 10;
     int andesiteMinHeight = NULL;
     int andesiteMaxHeight = 80;
     int coalSize = 17;
     int coalCount = 20;
     int coalMinHeight = NULL;
     int coalMaxHeight = 128;
     int ironSize = 9;
     int ironCount = 20;
     int ironMinHeight = NULL;
     int ironMaxHeight = 64;
     int goldSize = 9;
     int goldCount = 2;
     int goldMinHeight = NULL;
     int goldMaxHeight = 32;
     int redstoneSize = 8;
     int redstoneCount = 8;
     int redstoneMinHeight = NULL;
     int redstoneMaxHeight = 16;
     int diamondSize = 8;
     int diamondCount = 1;
     int diamondMinHeight = NULL;
     int diamondMaxHeight = 16;
     int lapisSize = 7;
     int lapisCount = 1;
     int lapisCenterHeight = 16;
     int lapisSpread = 16;
};
"./Level\\TerrainGeneration\\Random\\JavaRandom.cpp"
#include "JavaRandom.h"

void JavaRandom::SetSeed(int64_t seed) {
    rseed_ = (seed ^ 0x5DEECE66DLL) & ((1LL << 48) - 1);
    have_next_next_gaussian_ = false;
}

int JavaRandom::Next(int bits) {
    rseed_ = (rseed_ * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
    return (int)(rseed_ >> (48 - bits));
}

int JavaRandom::NextInt(int n) {
    if (n <= 0)
        throw std::exception("n must be positive");
    if ((n & (-n)) == n) //n is power of 2
        return (int)((n * (int64_t)Next(31)) >> 31);
    int bits, val;
    do
    {
        bits = Next(31);
        val = bits % n;
    } while (bits - val + (n - 1) < 0);
    return val;
}

int JavaRandom::NextInt() {
    return Next(32);
}

uint64_t JavaRandom::NextLong() {
    return ((long long)Next(32) << 32) + Next(32);
}

bool JavaRandom::NextBoolean() {
    return Next(1) != 0;
}

float JavaRandom::NextFloat() {
    return Next(24) / (float)(1 << 24);
}

double JavaRandom::NextDouble() {
    return (((int64_t)Next(26) << 27) + Next(27)) / (double)(1LL << 53);
}
"./Level\\TerrainGeneration\\Random\\JavaRandom.h"
#pragma once
#include <random>
#include <exception>

class JavaRandom {
private:
    bool have_next_next_gaussian_;
    double next_next_gaussian;
    int64_t rseed_;
    int64_t serial_version_uid_ = 3905348978240129619L;

public:
    JavaRandom() : JavaRandom{static_cast<uint64_t>(time(NULL))} {
    }

    JavaRandom(uint64_t seed) {
        SetSeed(seed);
    }

    void SetSeed(int64_t seed);

    int Next(int bits);

    int NextInt(int n);

    int NextInt();

    uint64_t NextLong();

    bool NextBoolean();

    float NextFloat();

    double NextDouble();
};
"./Level\\TerrainGeneration\\Structures\\Structure.cpp"
#include "Structure.h"

SetBlockRelative::SetBlockRelative(BlockID block, int8_t x, int8_t y, int8_t z) : x_{ x }, y_{ y }, z_{ z }, block_{ block } {}

void SetBlockRelative::SetPos(int8_t x, int8_t y, int8_t z) {
    x_ = x;
    y_ = y;
    z_ = z;
}
"./Level\\TerrainGeneration\\Structures\\Structure.h"
#pragma once
#include <cctype>
#include "../../Chunk/Block/Block.h"

struct SetBlockRelative {
    int8_t x_;
    int8_t y_;
    int8_t z_;

    BlockID block_;

    SetBlockRelative(BlockID block, int8_t x, int8_t y, int8_t z);

    void SetPos(int8_t x, int8_t y, int8_t z);
};

struct Structure {
    std::vector<SetBlockRelative> build_;
};
"./Level\\Timer\\Timer.cpp"
﻿#include "Timer.h"

void Timer::Set() {
    first_ = std::chrono::high_resolution_clock::now();
}

double Timer::GetTimePassed_s() const {
    return (double)(std::chrono::high_resolution_clock::now() - first_).count() / 1000000000.0;
}

double Timer::GetTimePassed_ms() const {
    return (double)(std::chrono::high_resolution_clock::now() - first_).count() / 1000000.0;
}

double Timer::GetTimePassed_μs()const {
    return (double)(std::chrono::high_resolution_clock::now() - first_).count() / 1000.0;
}

double Timer::GetTimePassed_ns()const {
    return (double)(std::chrono::high_resolution_clock::now() - first_).count();
}

std::string Timer::StrGetTimePassed_s() const {
    return std::to_string(GetTimePassed_s());
}

std::string Timer::StrGetTimePassed_ms()const {
    return std::to_string(GetTimePassed_ms());
}

std::string Timer::StrGetTimePassed_μs() const {
    return std::to_string(GetTimePassed_μs());
}

std::string Timer::StrGetTimePassed_ns() const {
    return std::to_string(GetTimePassed_ns());
}
"./Level\\Timer\\Timer.h"
﻿#pragma once
#include <chrono>
#include <string>

class Timer {
public:
    
    Timer() {
        first_ = std::chrono::high_resolution_clock::now();
    }

    double GetTimePassed_ns() const;
    double GetTimePassed_μs() const;
    double GetTimePassed_ms() const;
    double GetTimePassed_s() const;

    std::string StrGetTimePassed_ns() const;
    std::string StrGetTimePassed_μs() const;
    std::string StrGetTimePassed_ms() const;
    std::string StrGetTimePassed_s() const;

    void Set();

private:
    std::chrono::steady_clock::time_point first_;

};
"./Level\\Typenames.h"
#pragma once
#include <vector>
#include "../Utils/Containers/robin_hood.h"
#include "Chunk/ChunkPos/ChunkPos.h"

typedef unsigned int EventID;
typedef unsigned short int BlockID;
typedef unsigned long long int EntityUUID; //UUID
typedef unsigned short EntityTypeID;
typedef unsigned int ItemID;
typedef uint64_t WorldGeneratorID;

 
template <class K, class V, class _Hash = robin_hood::hash<K>>
using FastHashMap = robin_hood::unordered_flat_map<K, V, _Hash>;

template <class V, class _Hash = robin_hood::hash<V>>
using FastHashSet = robin_hood::unordered_flat_set<V, _Hash>;

template <class T>
using FastVector = std::vector<T>;


inline constexpr int FRONT = 0x00;
inline constexpr int BACK = 0x01;
inline constexpr int TOP = 0x02;
inline constexpr int BOTTOM = 0x03;
inline constexpr int RIGHT = 0x04;
inline constexpr int LEFT = 0x05;

inline constexpr int  PX = 0x00;
inline constexpr int  NX = 0x01;
inline constexpr int  PY = 0x02;
inline constexpr int  NY = 0x03;
inline constexpr int  PZ = 0x04;
inline constexpr int  NZ = 0x05;

"./Level\\World\\Collusion\\WorldCollusion.cpp"
#include "WorldCollusion.h"
#include "../../DataContainer/ChunkMapData.h"
#include "../../Entity/Entity.h"
#include "../../Entity/Entities.h"
#include "../../Entity/Collusion/Hitbox.h"
#include "../../../Utils/Math/vectorOperations.h"
#include "../../../Utils/Math/Ray/Ray.h"

void WorldCollusionDetector::Initialize(ChunkMap* w) {
    world_ = w;
}

float WorldCollusionDetector::GetDistanceUntilCollusionSingleDirection(glm::vec3 origin, int direction, int distanceTest) {
    float displacement = 0;

    glm::ivec3 flooredPos(floor(origin.x), floor(origin.y), floor(origin.z));
    int move = 0;

    int axis_ = direction >> 1;

    if (direction & 0b1) {
        displacement = origin[axis_] - (float)flooredPos[axis_];
        move = -1;
    }
    else {
        displacement = 1 - (origin[axis_] - (float)flooredPos[axis_]);
        move = 1;
    }

    for (int i = 0; i < distanceTest; i++) {

        flooredPos[axis_] += move * (int)(i != 0);

        BlockID b = world_->GetBlockGlobal(BlockPos{ flooredPos.x, flooredPos.y, flooredPos.z });

        if (g_blocks.GetBlockType(b)->properties_->is_solid_) {
            return (float)i + displacement - 1.f;
        }
    }

    return -1.f;
}

glm::dvec3 WorldCollusionDetector::GetTimeTillCollusion(Entity* entity) {
    AABB hitbox = g_entity_list.GetEntity(entity->properties_.type_)->GetHitbox();

    glm::vec3 hitboxStart = entity->properties_.position_ - (hitbox.size_ / 2.f);
    glm::vec3 hitboxEnd = entity->properties_.position_ + (hitbox.size_ / 2.f);

    int ix = (int)floor(hitbox.size_.x) + 1;
    int iy = (int)floor(hitbox.size_.y) + 1;
    int iz = (int)floor(hitbox.size_.z) + 1;

    glm::ivec3 i_bound = glm::ivec3(ix, iy, iz);

    glm::vec3 leastTime(-1.f, -1.f, -1.f);

    int searchDistance = 5;

    float leastDistance = (float)searchDistance;

    for (int axis_ = 0; axis_ < 3; axis_++) {

        //0 = x; 1 = y; 2 = z

        int u_axis = (axis_ + 1) % 3;
        int v_axis = (axis_ + 2) % 3;

        for (int u = 0; u <= i_bound[u_axis]; u++) {
            for (int v = 0; v <= i_bound[v_axis]; v++) {
                glm::ivec3 offset(0, 0, 0);

                offset[axis_] = i_bound[axis_] * (entity->properties_.velocity_[axis_] >= 0);
                offset[u_axis] = u;
                offset[v_axis] = v;

                glm::vec3 origin_ = hitboxStart + (glm::vec3)offset;

                if (origin_.x > hitboxEnd.x)
                    origin_.x = hitboxEnd.x;
                if (origin_.y > hitboxEnd.y)
                    origin_.y = hitboxEnd.y;
                if (origin_.z > hitboxEnd.z)
                    origin_.z = hitboxEnd.z;

                bool IsPointOnHitboxSurface =
                    (origin_.x == hitboxStart.x) ||
                    (origin_.x == hitboxEnd.x) ||
                    (origin_.y == hitboxStart.y) ||
                    (origin_.y == hitboxEnd.y) ||
                    (origin_.z == hitboxStart.z) ||
                    (origin_.z == hitboxEnd.z);

                if (!IsPointOnHitboxSurface) //Checks if the origin is on the surface to optimize stuff
                    continue;

                if (entity->properties_.velocity_[axis_] == 0.f) //First checks if the velocity isn't 0 because if it is 0, it's not moving in that axis so it's not going to collide in that direction
                    continue;

                int direction = axis_ * 2 + (entity->properties_.velocity_[axis_] < 0); // The "+1" indicates that the direction is negative 

                float distance = GetDistanceUntilCollusionSingleDirection(origin_, direction, (int)floor(leastDistance) + 2);

                if ((distance < leastDistance) && (distance != -1.f))
                    leastDistance = distance;

                if (distance == -1.f) // -1.f means that it cannot find any blocks that could collide in that range (5)
                    continue;

                float time = abs(distance / entity->properties_.velocity_[axis_]);// This gets the time it takes for the entity to travel that distance

                if (time < leastTime[axis_]) {
                    leastTime[axis_] = time;
                    continue;
                }

                if (leastTime[axis_] == -1.f) //leasttime[axis] == -1.f means that a "time" value haven't been inputted yet
                    leastTime[axis_] = time;
            }
        }
    }

    return leastTime;
}

bool WorldCollusionDetector::CheckRayIntersection(Ray& ray) {

    //Direction with magnitude
    glm::vec3 delta = ray.direction_;

    //Direction to Step
    glm::ivec3 direction = Sign(delta);

    //Location in grid
    glm::ivec3 blockPos = glm::ivec3(floor(ray.origin_.x), floor(ray.origin_.y), floor(ray.origin_.z));

    //To keep track of point location
    glm::vec3 endPoint = ray.origin_;

    glm::vec3 deltaDist(
        abs(1 / delta[0]), abs(1 / delta[1]), abs(1 / delta[2])
    );

    //Stepping Variable
    glm::vec3 sideDist(
        ((float)direction[0] * ((float)blockPos[0] - endPoint[0]) + ((float)direction[0] * 0.5f) + 0.5f) * deltaDist[0],
        ((float)direction[1] * ((float)blockPos[1] - endPoint[1]) + ((float)direction[1] * 0.5f) + 0.5f) * deltaDist[1],
        ((float)direction[2] * ((float)blockPos[2] - endPoint[2]) + ((float)direction[2] * 0.5f) + 0.5f) * deltaDist[2]
    );

    //Max Iterations
    const uint32_t maxIterations = 50;
    uint32_t iterations = 0;

    glm::bvec3 mask(false, false, false);

    while (iterations < maxIterations) {
        iterations++;
        
        BlockID b = world_->GetBlockGlobal(BlockPos{ blockPos.x, blockPos.y, blockPos.z });

        if (g_blocks.GetBlockType(b)->properties_->is_solid_) {

            ray.end_point_ = (glm::vec3)blockPos;

            ray.length_ = sqrtf(powf(ray.end_point_.x - ray.origin_.x, 2) + powf(ray.end_point_.y - ray.origin_.y, 2) + powf(ray.end_point_.z - ray.origin_.z, 2));

            for (int axis_ = 0; axis_ < 3; axis_++) {
                if (mask[axis_]) {
                    ray.bounce_surface_ = delta[axis_] < 0 ? axis_ * 2 + 1 : axis_ * 2; //Set the surface it bounces off. + 1 means that the surface is behind, bottom, etc
                    return true;
                }
            }
            return false;
        }

        glm::bvec3 l1 = LessThan(sideDist[0], sideDist[1], sideDist[2], sideDist[1], sideDist[2], sideDist[0]);
        glm::bvec3 l2 = LessThanEqual(sideDist[0], sideDist[1], sideDist[2], sideDist[2], sideDist[0], sideDist[1]);

        mask[0] = l1[0] && l2[0];
        mask[1] = l1[1] && l2[1];
        mask[2] = l1[2] && l2[2];

        sideDist[0] += (float)mask[0] * deltaDist[0];
        sideDist[1] += (float)mask[1] * deltaDist[1];
        sideDist[2] += (float)mask[2] * deltaDist[2];

        blockPos[0] += ((int)mask[0]) * direction[0];
        blockPos[1] += ((int)mask[1]) * direction[1];
        blockPos[2] += ((int)mask[2]) * direction[2];
    }

    return false;
}

bool WorldCollusionDetector::isEntityOnGround(Entity* entity) {
    AABB hitbox = g_entity_list.GetEntity(entity->properties_.type_)->GetHitbox();

    glm::vec3 hitboxStart = entity->properties_.position_ - (hitbox.size_ / 2.f);
    glm::vec3 hitboxEnd = entity->properties_.position_ + (hitbox.size_ / 2.f);

    int ix = (int)floor(hitbox.size_.x) + 1;
    int iz = (int)floor(hitbox.size_.z) + 1;

    int searchDistance = 5;

    float leastLength = (float)searchDistance;

    float onGroundError = 0.001f;

    if (entity->properties_.velocity_.y > 0.f) {
        return false;
    }

    for (int x = 0; x <= ix; x++) {
        for (int z = 0; z <= iz; z++) {
            glm::vec3 origin = hitboxStart + glm::vec3(x, 0, z);

            if (origin.x > hitboxEnd.x)
                origin.x = hitboxEnd.x;
            if (origin.z > hitboxEnd.z)
                origin.z = hitboxEnd.z;

            float distance = 0.f;

            //Set the distance to check to the previose least length from collusion to optimize searching
            distance = GetDistanceUntilCollusionSingleDirection(origin, NY, (int)floor(leastLength) + 2);

            if (distance < leastLength) {
                leastLength = distance;
            }

            if ((distance != -1) && (distance < onGroundError)) {
                return true;
            }

        }
    }
    return false;
}
"./Level\\World\\Collusion\\WorldCollusion.h"
#pragma once
#include <glm/vec3.hpp>

class ChunkMap;

struct Entity;
struct Ray;

class WorldCollusionDetector {
private:
    ChunkMap* world_;

public:
    void Initialize(ChunkMap* w);

    bool CheckRayIntersection(Ray& ray);

    float GetDistanceUntilCollusionSingleDirection(glm::vec3 Origin, int direction, int distanceTest);

    glm::dvec3 GetTimeTillCollusion(Entity* entity);

    bool isEntityOnGround(Entity* entity);
};
"./Level\\World\\World.cpp"
#include "World.h"

void World::Initialize() {

}
"./Level\\World\\World.h"
#pragma once
#include "WorldDataAccess.h"
#include "Collusion/WorldCollusion.h"

class World : public WorldAccess {
private:
public:
    void Initialize();
};
"./Level\\World\\WorldDataAccess.cpp"
#include <exception>

#include "WorldDataAccess.h"
#include "../DataContainer/ChunkMapData.h"
#include "../DataContainer/EntityContainer.h"

WorldAccess::WorldAccess() :
    chunk_container_{ std::make_unique<ChunkMap>() },
    entities_{ std::make_unique<EntityContainer>() } {
}

WorldAccess::~WorldAccess() = default;

BlockID WorldAccess::GetBlock(const BlockPos& pos) {
    return chunk_container_->GetBlockGlobal(pos);
}

void WorldAccess::SetBlock(BlockID block, const BlockPos& pos) {
    if (!chunk_container_->SetBlockGlobal(block, pos)) {
        throw std::exception("Tried to place block outside of the world");
    }
}

void WorldAccess::SetChunk(std::unique_ptr<Chunk> chunk) {
    chunk_container_->InsertChunk(std::move(chunk));
}

Chunk* WorldAccess::GetChunk(const ChunkPos& pos) const {
    return chunk_container_->GetChunk(pos);
}

bool WorldAccess::CheckChunk(const ChunkPos& pos) const {
    return chunk_container_->GetChunk(pos) != nullptr;
}

Heightmap& WorldAccess::GetColumnHeightmap(const ChunkColumnPos& v) const {
    ChunkColumn* col = chunk_container_->GetColumn(v);
    return col->GetHeightmap();
}

ChunkColumn* WorldAccess::GetColumn(const ChunkPos& v) const {
    return chunk_container_->GetColumn(v);
}
"./Level\\World\\WorldDataAccess.h"
#pragma once
#include <memory>

#include "../Typenames.h"

class ChunkMap;
class EntityContainer;
class Heightmap;
class ChunkColumn;
class Chunk;

struct WorldAccess {
    std::unique_ptr<ChunkMap> chunk_container_;
    std::unique_ptr<EntityContainer> entities_; //Remove tick later, this is going to be specific to dimension stuff

    WorldAccess();
    ~WorldAccess();

    BlockID GetBlock(const BlockPos& pos);
    
    void SetBlock(BlockID block, const BlockPos& pos);

    void SetChunk(std::unique_ptr<Chunk> chunk);

    Chunk* GetChunk(const ChunkPos& ID) const;

    bool CheckChunk(const ChunkPos& ID) const;
    
    Heightmap& GetColumnHeightmap(const ChunkColumnPos& v) const;

    ChunkColumn* GetColumn(const ChunkPos& v) const;
};
"./Level\\World\\WorldInteraction\\WorldInteractions.cpp"
#include <exception>

#include "WorldInteractions.h"
#include "WorldLoader.h"
#include "../Collusion/WorldCollusion.h"
#include "../WorldParameters.h"
#include "../../Chunk/Chunk.h"
#include "../../Chunk/Lighting/ChunkLighting.h"
#include "../../DataContainer/EntityContainer.h"
#include "../../Entity/Entity.h"

WorldInteractions::WorldInteractions() = default;

WorldInteractions::WorldInteractions(World* w, WorldParameters parameters) {
    init(w, parameters);
}

void WorldInteractions::UseTallGeneration() {
    worldLoader_->tall_generation_ = true;
}

void WorldInteractions::init(World* w, WorldParameters parameters) {
    world = w;
    settings_ = std::make_unique<WorldParameters>(parameters);
    collusions_ = std::make_unique<WorldCollusionDetector>();
    worldLoader_ = new WorldLoader(w, parameters);
    collusions_->Initialize(w->chunk_container_.get());
}

void WorldInteractions::summonEntity(Entity& entity) {
    if (world == nullptr) throw std::exception("Cannot summon entity. World is null");
    world->entities_->AddEntities(entity);

    if (entity.properties_.is_chunk_loader_)
        worldLoader_->AddEntityChunkLoader(entity.properties_.entity_uuid_);
}

std::vector<ChunkPos> WorldInteractions::GetUpdatedChunkPos() {
    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };
    std::vector<ChunkPos> chunkIDs = {};
    chunkIDs.insert(chunkIDs.end(), updated_chunk_.begin(), updated_chunk_.end());
    updated_chunk_.clear();

    return chunkIDs;
}

std::vector<ChunkPos> WorldInteractions::GetRequestedLightUpdates() {
    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };
    std::vector<ChunkPos> pos = std::move(light_updates_);
    light_updates_.clear();
    for (const ChunkPos& p : pos) {
        requested_light_update_[p].second = SIZE_MAX;
    }
    return pos;
}

std::vector<EntityProperty> WorldInteractions::GetUpdatedEntities() {
    FastHashMap<EntityUUID, EntityProperty> m = world->entities_->ClientGetEntityUpdate();
    std::vector<EntityProperty> properties = {};

    for (const auto& e : m) {
        properties.push_back(e.second);
    }

    return properties;
}

std::vector<EntityUUID> WorldInteractions::GetRemovedEntities() {
    FastHashSet<EntityUUID> m = world->entities_->getRemovedEntities();
    std::vector<EntityUUID> ids = {};
    ids.insert(ids.end(), m.begin(), m.end());
    return ids;
}

void WorldInteractions::RequestLightUpdate(const ChunkPos& pos) {
    ChunkColumnPos columnPos = pos;
    columnPos.y /= 32;
    int y = pos.y & 31;

    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };

    if (requested_light_update_.count(pos)) {
        auto& info = requested_light_update_[pos];

        int currY = info.first;
        size_t index = info.second;

        if (currY < y) {
            if (index == SIZE_MAX) {
                info.second = light_updates_.size();
                light_updates_.push_back(pos);
            }
            else {
                info.first = y;
                light_updates_[index].y = y;
            }
        }
    }
    else {
        requested_light_update_.emplace(columnPos, std::pair<int, size_t>{y, light_updates_.size()});
        light_updates_.push_back(pos);
    }



}

void WorldInteractions::KillEntity(EntityUUID id) {
    world->entities_->RemoveEntity(id);
    if (worldLoader_->CheckEntityExistChunkLoader(id)) {
        worldLoader_->DeleteEntityChunkLoader(id);
    }
}

void WorldInteractions::Update() {
    worldLoader_->Load();
}

void WorldInteractions::UpdateLighting(std::unique_ptr<ChunkLightingContainer> chunkLighting) {
    ChunkPos pos = chunkLighting->position_;

    world->GetColumn(chunkLighting->position_);
    worldLoader_->ReplaceLightInfomation(std::move(chunkLighting));

    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };
    if (!updated_chunk_.count(pos)) {
        updated_chunk_.insert(pos);
    }
    pos.y /= 32;

    requested_light_update_.erase(pos);
}

void WorldInteractions::UpdateLighting(std::vector<std::unique_ptr<ChunkLightingContainer>> chunkLighting) {
    std::stack<ChunkPos> chunkToUpdate;

    for (auto& chunk : chunkLighting) {
        chunkToUpdate.push(chunk->position_);
        worldLoader_->ReplaceLightInfomation(std::move(chunk));
    }

    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };

    while (!chunkToUpdate.empty()) {
        ChunkPos pos = chunkToUpdate.top();
        chunkToUpdate.pop();
        if (!updated_chunk_.count(pos)) {
            updated_chunk_.insert(pos);
        }
        pos.y /= 32;
        // TODO: Fix this with Chunk Column ID
        requested_light_update_.erase(pos);

    }
}

void WorldInteractions::AddChunk(std::unique_ptr<Chunk> chunk) {
    std::stack<ChunkPos> chunkToUpdate;

    const ChunkPos& position = chunk->position_;

    world->SetChunk(std::move(chunk));
    RequestLightUpdate(position);
    chunkToUpdate.push(position);

    //Update neighbor chunks

    for (int side = 0; side < 6; side++) {
        ChunkPos neighborPos = position;
        neighborPos.incrementSide(side, 1);

        if (world->CheckChunk(neighborPos)) {
            chunkToUpdate.push(neighborPos);
        }
    }

    std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };

    while (!chunkToUpdate.empty()) {
        ChunkPos pos = chunkToUpdate.top();
        chunkToUpdate.pop();
        if (!updated_chunk_.count(pos)) {
            updated_chunk_.insert(pos);
        }

    }
}

void WorldInteractions::AddChunks(std::vector<std::unique_ptr<Chunk>> chunks) {
    std::vector<ChunkPos> chunkToUpdate;
    FastHashSet<ChunkPos> duplicatedInputs;

    for (auto& chunk : chunks) {

        const ChunkPos& position = chunk->position_;

        chunkToUpdate.push_back(position);
        //Update neighbor chunks

        for (int side = 0; side < 6; side++) {
            ChunkPos neighborPos = position;
            neighborPos.incrementSide(side, 1);

            if (!duplicatedInputs.count(neighborPos) && world->CheckChunk(neighborPos)) {
                chunkToUpdate.push_back(neighborPos);
                duplicatedInputs.insert(neighborPos);
            }
        }
        RequestLightUpdate(position);
        world->SetChunk(std::move(chunk));
    }

    {
        std::lock_guard<std::mutex> lock{ updated_chunk_lock_ };
        for (const ChunkPos& pos : chunkToUpdate) {
            if (!updated_chunk_.count(pos)) {
                updated_chunk_.insert(pos);
            }

        }
    }
    chunkToUpdate.clear();
}

Chunk* WorldInteractions::GetChunk(const ChunkPos& pos) const {
    if (!world->CheckChunk(pos)) {
        return nullptr;
    }

    return world->GetChunk(pos);
}

void WorldInteractions::SetBlock(BlockID b, const BlockPos& bpos) {
    //UpdatedChunkLock.lock();
    try {
        int x = bpos.x;
        int y = bpos.y;
        int z = bpos.z;

        ChunkPos pos = ChunkPos{ x >> 4, y >> 4, z >> 4 };

        world->SetBlock(b, bpos);
        if (!updated_chunk_.count(pos)) {
            updated_chunk_.insert(pos);
        }

        int v[3]{ x % 16, y % 16, z % 16 };

        for (int axis_ = 0; axis_ < 3; axis_++) {
            ChunkPos p = pos;

            int direction = 0;

            if (v[axis_] == 15)
                direction = 1;
            if (v[axis_] == 0)
                direction = -1;

            if (direction == 0) continue;

            p[axis_] += direction;
            if (!updated_chunk_.count(p))
                updated_chunk_.insert(p);
        }


        RequestLightUpdate(pos);
    }
    catch (std::exception& e) {
        g_logger.LogError("WorldInteractions::SetBlock", e.what());
    }
}

BlockID WorldInteractions::GetBlock(const BlockPos& pos) {
    try {
        return world->GetBlock(pos);
    }
    catch (std::exception& e) {
        g_logger.LogError("WorldInteractions::GetBlock", e.what());
        return g_blocks.AIR;
    }
}

Entity* WorldInteractions::GetEntity(EntityUUID id) {
    return world->entities_->GetEntity(id);
}

void WorldInteractions::AddEntity(Entity& entity) {
    world->entities_->AddEntities(entity);
}

void WorldInteractions::AddEntity(Entity* entity) {
    world->entities_->AddEntities(entity);
}
"./Level\\World\\WorldInteraction\\WorldInteractions.h"
#pragma once
#include "../World.h"
#include <mutex>
#include <memory>
#include <stack>
#include <vector>

#include "../../Typenames.h"

// Provides a way for the world to be interacted like summoning entities and what chunks are updated and what chunks needs updates
// TODO: IMPORTANT FIX LIGHT UPDATE 

class WorldLoader;
class WorldCollusionDetector;
class Chunk;
class ChunkLightingContainer;

struct WorldParameters;
struct EntityProperty;

class WorldInteractions {
private:
    World* world = nullptr;
    std::mutex updated_chunk_lock_;
    FastHashSet<ChunkPos> updated_chunk_;
    FastHashMap<ChunkPos, std::pair<int, size_t>> requested_light_update_; // pair<y height, index in update vector>
    std::vector<ChunkPos> light_updates_;
public:
    WorldLoader* worldLoader_ = nullptr;
    std::unique_ptr<WorldParameters> settings_;
    std::unique_ptr<WorldCollusionDetector> collusions_;

    WorldInteractions();

    WorldInteractions(World* w, WorldParameters parameters);

    void UseTallGeneration();

    void init(World* w, WorldParameters parameters);

    void summonEntity(Entity& entity);

    std::vector<ChunkPos> GetUpdatedChunkPos();

    std::vector<ChunkPos> GetRequestedLightUpdates();

    std::vector<EntityProperty> GetUpdatedEntities(); // TODO: Rename

    std::vector<EntityUUID> GetRemovedEntities(); // TODO: Rename

    void RequestLightUpdate(const ChunkPos& pos);

    void KillEntity(EntityUUID id);

    void Update();

    void UpdateLighting(std::unique_ptr<ChunkLightingContainer> chunkLighting);

    void UpdateLighting(std::vector<std::unique_ptr<ChunkLightingContainer>> chunkLighting);

    void AddChunk(std::unique_ptr<Chunk> chunk);

    void AddChunks(std::vector<std::unique_ptr<Chunk>> chunks);

    Chunk* GetChunk(const ChunkPos& pos) const;

    void SetBlock(BlockID b, const BlockPos& pos);

    BlockID GetBlock(const BlockPos& pos);

    Entity* GetEntity(EntityUUID id);

    void AddEntity(Entity& entity);

    void AddEntity(Entity* entity);
};
"./Level\\World\\WorldInteraction\\WorldLoader.cpp"
#include <glm/vec3.hpp>

#include "WorldLoader.h"
#include "../World.h"
#include "../WorldParameters.h"
#include "../../Chunk/Lighting/ChunkLighting.h"
#include "../../Chunk/ChunkColumn.h"
#include "../../Entity/Entity.h"
#include "../../DataContainer/EntityContainer.h"

using namespace glm;

WorldLoader::WorldLoader(World* w, WorldParameters p) : settings_{ std::make_unique<WorldParameters>( p ) }, world{ w } {}

void WorldLoader::loadSummonEntitySurrounding(EntityUUID uuid) {
    Entity* e = world->entities_->GetEntity(uuid);

    if (e == nullptr) throw std::exception(std::string("Entity with UUID " + std::to_string(uuid) + " not found").c_str());

    vec3 pos = e->properties_.position_ / 16.f;
    // vec3 velocity = e->Properties.Velocity;

    ivec3 initalPos{ (int)pos.x, (int)pos.y, (int)pos.z };

    // TODO: Use light engine FIFO 
    std::deque<ivec3> FIFO;

    FIFO.push_back(initalPos);
    while (!FIFO.empty()) {

        ivec3 chunkPos = FIFO.front();
        FIFO.pop_front();

        //Gets relative position from the entity
        ivec3 offset = initalPos - chunkPos;

        //Checks if it is in range
        if ((abs(offset.x) > settings_->horizontal_ticking_distance_) || (abs(offset.z) > settings_->horizontal_ticking_distance_))
            continue;
        if (abs(offset.y) > settings_->vertical_ticking_distance_)
            continue;

        bool isSuccess = RequestLoad(ChunkPos{ chunkPos.x, chunkPos.y, chunkPos.z });
        if (!isSuccess) continue;

        for (int side = 0; side < 6; side++) {

            ivec3 newObj = chunkPos;

            newObj[side >> 1] += (side & 0b1) * 2 - 1;

            FIFO.push_back(newObj);
        }
    }

}

bool WorldLoader::RequestLoad(const ChunkPos& pos) {
    ChunkPos p = pos;
    if (world->GetChunk(p) != nullptr)
        return false;

    if (tall_generation_)
        p.y /= 16;

    if (generating_chunk_.count(p))
        return false;

    //Request chunk
    generating_chunk_.insert(p);

    std::lock_guard<std::mutex> lock{ lock_ };
    chunk_request_.push_back(p);
    return true;
}

//Only work on loading chunks for not. Unloading for later
void WorldLoader::loadSurroundedMovedEntityChunk() {
    std::vector<ivec3> centerPositionList = {};
    std::vector<vec3> centerVelocityList = {};

    //Get entity chunk position

    for (const auto& e : entity_chunk_loaders_) {
        Entity* entity = world->entities_->GetEntity(e);

        if (entity == nullptr) throw std::exception(std::string("Entity with UUID " + std::to_string(e) + " not found").c_str());

        int x = static_cast<int>(entity->properties_.position_.x / 16.f);
        int y = static_cast<int>(entity->properties_.position_.y / 16.f);
        int z = static_cast<int>(entity->properties_.position_.z / 16.f);

        if ((entity->properties_.velocity_.x == 0.f) && (entity->properties_.velocity_.y == 0.f) && (entity->properties_.velocity_.z == 0.f)) {
            continue;
        }

        centerPositionList.emplace_back(x, y, z);
        centerVelocityList.emplace_back(entity->properties_.velocity_);
    }

    if (centerPositionList.empty()) return;

    ivec3 axisTickingDistance{ settings_->horizontal_ticking_distance_, settings_->vertical_ticking_distance_, settings_->horizontal_ticking_distance_ };

    int chunkPadding = 4;

    for (size_t i = 0; i < centerPositionList.size(); i++) {
        ivec3 pos = centerPositionList[i];
        vec3 vel = centerVelocityList[i];

        for (int j = 0; j < 3; j++) {
            int side = 0;

            if (vel[j] > 0) {
                side = 1;
            }

            if (vel[j] < 0) {
                side = -1;
            }

            if (side == 0) continue;

            int uDistance = axisTickingDistance[(j + 1) % 3] + chunkPadding;
            int vDistance = axisTickingDistance[(j + 2) % 3] + chunkPadding;
            int sideDistanceOffset = axisTickingDistance[j] + 1;

            for (int u = -uDistance; u <= uDistance; u++) {
                for (int v = -vDistance; v <= uDistance; v++) {
                    ivec3 testPosition = pos;

                    testPosition[(j + 1) % 3] += u;
                    testPosition[(j + 2) % 3] += v;
                    testPosition[j] += sideDistanceOffset * side;

                    //Test if it exist of generating
                    bool isSuccess = RequestLoad(ChunkPos{ testPosition.x, testPosition.y, testPosition.z });
                    if (!isSuccess) continue;
                }
            }




        }
    }
}

void WorldLoader::loadSpawnChunks() {
    if (world == nullptr) throw std::exception("World is not initialized. Couldn't set spawn chunks");
    return;
    for (long long int x = -settings_->spawn_chunk_horizontal_radius_; x <= settings_->spawn_chunk_horizontal_radius_; x++) {
        for (long long int z = -settings_->spawn_chunk_horizontal_radius_; z <= settings_->spawn_chunk_horizontal_radius_; z++) {
            for (long long int y = -settings_->spawn_chunk_vertical_radius_; y <= settings_->spawn_chunk_vertical_radius_; y++) {
                bool isSuccess = RequestLoad(ChunkPos{ x, y, z });

                if (!isSuccess) {
                    continue;
                }

            }
        }
    }

    is_spawn_chunks_loaded_ = true;
}

WorldAccess* WorldLoader::GetWorld() const {
    return static_cast<WorldAccess*>(world);
}

//TODO: Fix me
void WorldLoader::ReplaceLightInfomation(std::unique_ptr<ChunkLightingContainer> lighting) {
    ChunkColumn* col = world->GetColumn(lighting->position_);
    int y = lighting->position_.y & 0b11111;
    if (col == nullptr) return; //fix this nullptr

    col->ReplaceLightContainer(y, std::move(lighting));
}

std::vector<ChunkPos> WorldLoader::GetRequestedChunks() {
    std::lock_guard<std::mutex> lock{ lock_ };

    std::vector<ChunkPos> tmp = std::move(chunk_request_);
    chunk_request_.clear();

    return tmp;

}

void WorldLoader::AddEntityChunkLoader(EntityUUID uuid) {
    entity_chunk_loaders_.insert(uuid);
    loadSummonEntitySurrounding(uuid);
}

void WorldLoader::DeleteEntityChunkLoader(EntityUUID uuid) {
    if (!entity_chunk_loaders_.count(uuid))
        throw std::exception(std::string("Could not find entity with UUID " + std::to_string(uuid)).c_str());

    entity_chunk_loaders_.erase(uuid);
}

bool WorldLoader::CheckEntityExistChunkLoader(EntityUUID uuid) const {
    return entity_chunk_loaders_.count(uuid);
}

void WorldLoader::Load() {
    if (!is_spawn_chunks_loaded_) loadSpawnChunks();

    loadSurroundedMovedEntityChunk();
}

void WorldLoader::AddChunk(std::unique_ptr<Chunk> chunk) {
    const ChunkPos& pos = chunk->position_;

    if (generating_chunk_.count(pos)) generating_chunk_.erase(pos);

    world->SetChunk(std::move(chunk));
}
"./Level\\World\\WorldInteraction\\WorldLoader.h"
#pragma once
#include <mutex>
#include <memory>

#include "../../Typenames.h"

class World;
class Chunk;
class ChunkLightingContainer;

struct WorldAccess;
struct WorldParameters;

// Add chunk unloading later when entity goes out of range
class WorldLoader {
private:
    std::unique_ptr<WorldParameters> settings_;
    World* world = nullptr;
    std::mutex lock_;
    bool is_spawn_chunks_loaded_ = false;
    std::vector<ChunkPos> chunk_request_;

    FastHashSet<EntityUUID> entity_chunk_loaders_; //List of entities that force loads chunks 
    FastHashSet<ChunkPos> generating_chunk_;

    void loadSpawnChunks();

    void loadSurroundedMovedEntityChunk();

    bool RequestLoad(const ChunkPos& pos);

    void loadSummonEntitySurrounding(EntityUUID uuid);

public:
    bool tall_generation_ = false;

    WorldLoader(World* w, WorldParameters p);

    WorldAccess* GetWorld() const;

    void ReplaceLightInfomation(std::unique_ptr<ChunkLightingContainer> lighting);

    std::vector<ChunkPos> GetRequestedChunks();

    void AddEntityChunkLoader(EntityUUID uuid);

    void DeleteEntityChunkLoader(EntityUUID uuid);

    bool CheckEntityExistChunkLoader(EntityUUID uuid) const;

    void Load();

    void AddChunk(std::unique_ptr<Chunk> chunk);

};
"./Level\\World\\WorldParameters.h"
#pragma once

struct WorldParameters {
    size_t horizontal_ticking_distance_ = 16;
    size_t vertical_ticking_distance_ = 8;

    size_t spawn_chunk_horizontal_radius_ = 10;
    size_t spawn_chunk_vertical_radius_ = 10;

    float gravity_ = 10.f;

    WorldParameters() = default;
    ~WorldParameters() = default;
    WorldParameters(const WorldParameters&) = default;
};
"./main.cpp"
#include <gl/glew.h>
#include <GLFW/glfw3.h>


#include "Utils/LogUtils.h"
#include "Client/Client.h"
#include "Level/Chunk/Block/Blocks.h"
#define STB_IMAGE_IMPLEMENTATION
#include "Utils/stb_image.h"
#include "Level/Chunk/Block/Blocks.h"
#include "Core/Initializer.h"
#include <cstdlib> 
#include <time.h>
#include "Core/Options/Option.h"

int main() {
    
    stbi_set_flip_vertically_on_load(true);
    srand(static_cast<unsigned int>(time(NULL)));//Set rng seed

    Initialize();

    Client GameClient;
    GameClient.run();

    Options options;

    g_logger.Stop();
    return 0;
}
"./RenderEngine\\BlockModel\\BlockModels.cpp"
#include "BlockModels.h"
#include "../../Level/typenames.h"
#include "../../Utils/LogUtils.h"

void Model::BlockModel::AddDisplay(BlockDisplay display, DisplayPosition position) {
    display_[position] = display;
}

bool Model::BlockModel::CheckDisplay(DisplayPosition position) {
    return display_[position].initialized_;
}

void Model::BlockModel::AddElement(Cuboid element) {
    elements_.push_back(element);
}

void Model::BlockModel::GetVertices(std::vector<float>& vertices, std::vector<unsigned int>& indices) {
    for (Cuboid& element : elements_) {
        glm::vec3 from = element.from_;
        glm::vec3 to = element.to_;
        from = from / 16.f;
        to = to / 16.f;
        for (uint8_t i = 0; i < 6; i++) {
            BlockFace face = element.faces_[i];
            if (face.reference_texture_.length() == 0) continue;

            glm::vec2 uv0{ face.uv_.x,  face.uv_.y };
            glm::vec2 uv1{ face.uv_.z,  face.uv_.w };

            uv0 = uv0 / 16.f;
            uv1 = uv1 / 16.f;

            uint8_t axis_ = i >> 1;

            uint32_t currIndex = static_cast<uint32_t>(vertices.size()) / 7;

            switch (axis_) {
            case 0:
                (i & 1) == 1 ?
                    vertices.insert(vertices.end(),
                        {
                            from.x,    from.y, from.z,        uv1.x, uv0.y,    (float)face.texture_id_,    8.f,
                            from.x, to.y,    from.z,        uv1.x, uv1.y,    (float)face.texture_id_,    8.f,
                            from.x, to.y,    to.z,        uv0.x, uv1.y,    (float)face.texture_id_,    8.f,
                            from.x, from.y,    to.z,        uv0.x, uv0.y,    (float)face.texture_id_,    8.f,
                        }
                        ) :
                    vertices.insert(vertices.end(),
                        {
                            to.x, from.y,   from.z,        uv1.x, uv0.y,    (float)face.texture_id_,    8.f,
                            to.x, to.y,        from.z,        uv1.x, uv1.y,    (float)face.texture_id_,    8.f,
                            to.x, to.y,        to.z,        uv0.x, uv1.y,    (float)face.texture_id_,    8.f,
                            to.x, from.y,    to.z,        uv0.x, uv0.y,    (float)face.texture_id_,    8.f,
                        }
                        );
                break;
            case 1:
                (i & 1) == 1 ?
                    vertices.insert(vertices.end(),
                        {
                            from.x, from.y, from.z,        uv1.x, uv0.y,    (float)face.texture_id_,    15.f,
                            to.x,    from.y, from.z,        uv0.x, uv0.y,    (float)face.texture_id_,    15.f,
                            to.x,    from.y, to.z,        uv0.x, uv1.y,    (float)face.texture_id_,    15.f,
                            from.x, from.y, to.z,        uv1.x, uv1.y,    (float)face.texture_id_,    15.f,
                        }
                        ) :
                    vertices.insert(vertices.end(),
                        {
                            from.x, to.y,    from.z,        uv1.x, uv0.y,    (float)face.texture_id_,    15.f,
                            to.x,    to.y,    from.z,        uv0.x, uv0.y,    (float)face.texture_id_,    15.f,
                            to.x,    to.y,    to.z,        uv0.x, uv1.y,    (float)face.texture_id_,    15.f,
                            from.x, to.y,    to.z,        uv1.x, uv1.y,    (float)face.texture_id_,    15.f,
                        }
                        );
                break;
            case 2:
                (i & 1) == 1 ?
                    vertices.insert(vertices.end(),
                        {
                            from.x, from.y, from.z,        uv1.x, uv0.y,    (float)face.texture_id_,    12.f,
                            to.x,    from.y, from.z,        uv0.x, uv0.y,    (float)face.texture_id_,    12.f,
                            to.x,    to.y,    from.z,        uv0.x, uv1.y,    (float)face.texture_id_,    12.f,
                            from.x, to.y,    from.z,        uv1.x, uv1.y,    (float)face.texture_id_,    12.f,
                        }
                        ) :
                    vertices.insert(vertices.end(),
                        {
                            from.x, from.y, to.z,        uv1.x, uv0.y,    (float)face.texture_id_,    12.f,
                            to.x,    from.y, to.z,        uv0.x, uv0.y,    (float)face.texture_id_,    12.f,
                            to.x,    to.y,    to.z,        uv0.x, uv1.y,    (float)face.texture_id_,    12.f,
                            from.x, to.y,    to.z,        uv1.x, uv1.y,    (float)face.texture_id_,    12.f,
                        }
                        );
                break;

            }

            if ((i & 1) == 0) {
                indices.insert(indices.end(),
                    {
                        0 + currIndex, 1 + currIndex, 2 + currIndex,
                        2 + currIndex, 3 + currIndex, 0 + currIndex
                    }
                );
            }
        }
    }
}

void Model::BlockModel::BakeTextureRotation() {
    for (Cuboid& element : elements_) {
        for (BlockFace& face : element.faces_) {
            if (face.reference_texture_.length() == 0) continue; //means not initialized

            int rotation_ = face.rotation_;

            face.uv_coord_nn = glm::ivec2(face.uv_.x, face.uv_.y);
            face.uv_coord_np = glm::ivec2(face.uv_.x, face.uv_.w);
            face.uv_coord_pp = glm::ivec2(face.uv_.z, face.uv_.w);
            face.uv_coord_pn = glm::ivec2(face.uv_.z, face.uv_.y);

            for (int r = 0; r < rotation_; r += 90) {
                std::swap(face.uv_coord_nn, face.uv_coord_np);
                std::swap(face.uv_coord_nn, face.uv_coord_pn);
                std::swap(face.uv_coord_pn, face.uv_coord_pp);
            }
        }
    }
}

void Model::BlockModel::FlattenVariables() {
    FastHashMap<std::string, std::string> variableMatcher{};
    FastHashSet<std::string> variableNames{};
    

    //This will set all of the texture variables

    for (const auto& [key, value] : texture_variable_) {
        //Check if there is a # at the beginning
        variableNames.insert('#' + key);
        if (value[0] == '#') {
            variableNames.insert(value);
        }

        //In this case, i am inserting both key and values because a variable could be referencing another variable
    }

    //Then it will find the absolute value corresponding to those variables


    for (const std::string& variable : variableNames) {
        std::string textureName = variable;
        std::vector<std::string> variableCorrspondingToSameTexture = {};

        FastHashSet<std::string> variableVisitMap{};

        

        int i = 0;
        while (textureName[0] == '#') {
            if (variableMatcher.count(textureName)) { //top down memorization
                textureName = variableMatcher[textureName];
                break;
            }
            if (i > 10000) { //too lazy to fix infinite loop  issues for now
                break;
            }
            i++;
            variableCorrspondingToSameTexture.push_back(textureName);
            textureName = texture_variable_[textureName.substr(1, textureName.length() - 1)];
        }

        for (const std::string& var : variableCorrspondingToSameTexture) {
            variableMatcher[var] = textureName;
        }
        variableCorrspondingToSameTexture.clear();
    }

    //After all of the texture are flatten it will go through the faces and set the textures
    for (Cuboid& element : elements_) {
        for (BlockFace& face : element.faces_) {
            if (face.reference_texture_.empty()) continue; //if there is no texture face is not initialized (skip)
            if (face.reference_texture_[0] != '#') continue;
            face.reference_texture_ = variableMatcher[face.reference_texture_];
        }
    }
}
"./RenderEngine\\BlockModel\\BlockModels.h"
#pragma once
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
#include <glm/vec4.hpp>
#include <string>
#include "../../Level/Typenames.h"

#define EAST 0x01
#define WEST 0x02
#define UP 0x03
#define DOWN 0x04
#define SOUTH 0x05
#define NORTH 0x06

enum DisplayPosition {
    thirdperson_righthand = 0,
    thirdperson_lefthand = 1,
    firstperson_righthand = 2,
    firstperson_lefthand = 3,
    gui = 4,
    head = 5,
    ground = 6,
    fixed = 7
};

struct BlockFace {
    glm::ivec3 normal_ = glm::ivec3(0, 0, 0);
    std::string reference_texture_ = ""; // variables starts with #
    int cull_face_ = -1;
    int tint_index_ = -1;
    size_t texture_id_ = NULL;
    size_t texture_count_ = NULL; //For amination purposes.
    unsigned int rotation_ = 0;
    bool has_transparency_ = false;
    bool is_see_through_ = false;
    glm::ivec4 uv_ = glm::ivec4(0, 0, 16, 16);

    glm::ivec2 uv_coord_nn{ 0, 0 };
    glm::ivec2 uv_coord_np{ 0, 0 };
    glm::ivec2 uv_coord_pp{ 0, 0 };
    glm::ivec2 uv_coord_pn{ 0, 0 };
};

struct BlockDisplay { //Positions {thirdperson_righthand, thirdperson_lefthand, firstperson_righthand, firstperson_lefthand, gui, head, ground, or fixed}
    //fixed = item frame
    DisplayPosition position; // TODO: Rename this
    glm::vec3 rotation_ = glm::vec3(0.f, 0.f, 0.f);
    glm::vec3 translation_ = glm::vec3(0.f, 0.f, 0.f);
    glm::vec3 scale_ = glm::vec3(0.f, 0.f, 0.f);
    bool initialized_ = false;
};

struct CuboidRotationInfo {
    glm::vec3 origin_ = glm::vec3(0.f, 0.f, 0.f);
    int axis_ = 0;
    int angle_ = 0;
    bool rescale_ = false;
    bool initialized_ = false;
};

struct Cuboid {
    glm::ivec3 from_ = glm::ivec3(0,0,0);
    glm::ivec3 to_ = glm::ivec3(16, 16, 16); //Relative inner block position from -16 to 32
    BlockFace faces_[6]{};
    CuboidRotationInfo rotation_;
    std::string comments_ = "";
    bool shade_ = true;

    void EditFace(int location, BlockFace f) {
        faces_[location - 1] = f;
    }
};

namespace Model {
    struct BlockModel {
        std::vector<Cuboid> elements_{};
        bool ambient_occlusion_ = true; //default value
        bool is_initialized_ = false;
        FastHashMap<std::string, std::string > texture_variable_;
        BlockDisplay display_[8]{};

        void AddDisplay(BlockDisplay display, DisplayPosition position);

        bool CheckDisplay(DisplayPosition position);

        void AddElement(Cuboid element);

        void GetVertices(std::vector<float>& vertices, std::vector<unsigned int>& indices);

        void FlattenVariables();

        void BakeTextureRotation();
    };
}

"./RenderEngine\\BlockModel\\ModelLoader.cpp"
#include <nlohmann/json.hpp>
#include <fstream>
#include <iostream>
#include "ModelLoader.h"
#include "../../FileManager/Files.h"
#include "../../Utils/LogUtils.h"

const std::string DEFAULT_NAMESPACE = "minecraft";

using json = nlohmann::json;

static std::vector<int> getJSONArrayValues(json JsonData) {
    std::vector<int> arr{};

    for (auto& value : JsonData.items()) {    
        arr.push_back(value.value());
    }

    return arr;
}

static std::vector<float> getJSONArrayValuesFloat(json JsonData) {
    std::vector<float> arr{};

    for (auto& value : JsonData.items()) {
        arr.push_back(value.value());
    }

    return arr;
}

static int ConvertStringFaceToIndex(const std::string& str) {
    if (!strcmp(str.c_str(), "down")) {
        return DOWN;
    }
    else if (!strcmp(str.c_str(), "up")) {
        return UP;
    }
    else if (!strcmp(str.c_str(), "north")) {
        return NORTH;
    }
    else if (!strcmp(str.c_str(), "south")) {
        return SOUTH;
    }
    else if (!strcmp(str.c_str(), "west")) {
        return WEST;
    }
    else if (!strcmp(str.c_str(), "east")) {
        return EAST;
    }
    else {
        g_logger.LogError("ConvertStringFaceToIndex", "Unknown direction: " + str);
        return NULL;
    }

}

static void ProcessSingleCubeFaces(Cuboid& cube, json JsonData) {
    for (auto& face : JsonData.items()) {
        int faceIndex = ConvertStringFaceToIndex(face.key());
        BlockFace bFace;
        for (auto& faceElements : face.value().items()) {

            if (!strcmp(faceElements.key().c_str(), "uv")) {
                std::vector<int> arr = getJSONArrayValues(faceElements.value());

                //flip
                arr[1] = 16 - arr[1];
                arr[3] = 16 - arr[3];

                std::swap(arr[1], arr[3]);

                for (int i = 0; i < 4; i++) {
                    bFace.uv_[i] = arr[i];
                }
            }
            else if (!strcmp(faceElements.key().c_str(), "texture")) {
                auto tokens = Tokenize(faceElements.value(),  ':');

                std::string texName = tokens.back();
                std::string texNamespace = DEFAULT_NAMESPACE;

                if (tokens.size() == 2) {
                    texNamespace = tokens.front();
                }

                bool isVariable = texName[0] == '#';

                if (isVariable) {
                    bFace.reference_texture_ = texName;
                }
                else {
                    bFace.reference_texture_ = texName + ":" + texNamespace;
                }
            }
            else if (!strcmp(faceElements.key().c_str(), "cullface")) {
                bFace.cull_face_ = ConvertStringFaceToIndex(faceElements.value()) - 1;
            }
            else if (!strcmp(faceElements.key().c_str(), "tintindex")) {
                bFace.tint_index_ = faceElements.value();
            }
            else if (!strcmp(faceElements.key().c_str(), "rotation")) {
                bFace.rotation_ = faceElements.value();
            }
            else {
                g_logger.LogError("ProcessSingleCubeFaces", "Unknown face attribute: " + faceElements.key());
            }


        }
        cube.EditFace(faceIndex, bFace);
    }
}

static CuboidRotationInfo getRotationalData(json JsonData) {
    CuboidRotationInfo rotationInfo;
    for (auto& attribute : JsonData.items()) {
        if (!strcmp(attribute.key().c_str(), "origin")) {
            std::vector<float> arr = getJSONArrayValuesFloat(attribute.value());

            for (int i = 0; i < 3; i++) {
                rotationInfo.origin_[i] = arr[i];
            }
        }
        else if (!strcmp(attribute.key().c_str(), "axis")) {
            char axis_ = static_cast<std::string>(attribute.value())[0];

            if (axis_ == 'x') {
                rotationInfo.axis_ = 0;
            }
            else if (axis_ == 'y') {
                rotationInfo.axis_ = 1;
            }
            else if (axis_ == 'z') {
                rotationInfo.axis_ = 2;
            }
            else {
                g_logger.LogError("getRotationalData", "Unknown rotational axis: " + attribute.value());
            }
            
        }
        else if (!strcmp(attribute.key().c_str(), "axis")) {
            int angle_ = attribute.value();
            rotationInfo.angle_ = angle_;
        }
        else if (!strcmp(attribute.key().c_str(), "rescale")) {
            rotationInfo.rescale_ = true;
        }
        rotationInfo.initialized_ = true;
    }

    return rotationInfo;
}

static void UpdateModelElements(std::unique_ptr<Model::BlockModel>& model, json JsonData) {
    for (auto& item : JsonData.items()) {

        Cuboid cuboid;

        for (auto& subElements : item.value().items()) {

            if (!strcmp(subElements.key().c_str(), "from")) {
                std::vector<int> arr = getJSONArrayValues(subElements.value());
                for (int i = 0; i < 3; i++) {
                    cuboid.from_[i] = arr[i];
                }
                arr.clear();
            }
            else if (!strcmp(subElements.key().c_str(), "to")) {
                std::vector<int> arr = getJSONArrayValues(subElements.value());
                for (int i = 0; i < 3; i++) {
                    cuboid.to_[i] = arr[i];
                }
                arr.clear();
            }
            else if (!strcmp(subElements.key().c_str(), "faces")) {
                ProcessSingleCubeFaces(cuboid, subElements.value());
            }
            else if (!strcmp(subElements.key().c_str(), "rotation")) { 
                CuboidRotationInfo rotation = getRotationalData(subElements.value());
                cuboid.rotation_ = rotation;
            }
            else if (!strcmp(subElements.key().c_str(), "__comment")) {
                cuboid.comments_ = subElements.value();
            }
            else if (!strcmp(subElements.key().c_str(), "shade")) {
                cuboid.shade_ = static_cast<bool>(subElements.value());
            }
            else {
                g_logger.LogError("UpdateModelElements", "Unknown element attribute: " + subElements.key());
            }
        }

        model->AddElement(cuboid);
    }
}

static void ProcessCuboidTexture(std::unique_ptr<Model::BlockModel>& model, json JsonData) {
    for (auto& TextureElement : JsonData.items()) {
        auto tokens = Tokenize(TextureElement.value(), ':');

        std::string textureName = tokens.back();
        std::string textureNamespace = tokens.front();
        

        if (tokens.size() == 1) {
            textureNamespace = DEFAULT_NAMESPACE;
        }

        std::string textureVariableName = TextureElement.key();

        bool isVariable = textureName[0] == '#';

        if (isVariable) {
            model->texture_variable_[textureVariableName] = textureName;
        }
        else {
            model->texture_variable_[textureVariableName] = textureName + ":" + textureNamespace;
        }

        
    }
}

static void ProcessModelDisplay(std::unique_ptr<Model::BlockModel>& model, json JsonData) {
    for (auto& displayPlaces : JsonData.items()) {

        std::string position = displayPlaces.key();
        BlockDisplay display;

        for (auto& transitions : displayPlaces.value().items()) {
            std::vector<float> arr = getJSONArrayValuesFloat(transitions.value());

            if (!strcmp(transitions.key().c_str(), "rotation")) {
                for (int i = 0; i < 3; i++) {
                    display.rotation_[i] = arr[i];
                }
            }
            else if (!strcmp(transitions.key().c_str(), "translation")) {
                for (int i = 0; i < 3; i++) {
                    display.translation_[i] = arr[i];
                }
            }
            else if (!strcmp(transitions.key().c_str(), "scale")) {
                for (int i = 0; i < 3; i++) {
                    display.scale_[i] = arr[i];
                }
            }
            else {
                g_logger.LogError("ProcessModelDisplay", "Unknown display attribute: " + transitions.key());
            }
        }

        if (!strcmp(position.c_str(), "thirdperson_righthand")) {
            display.position = DisplayPosition::thirdperson_righthand;
        }
        else if (!strcmp(position.c_str(), "thirdperson_lefthand")) {
            display.position = DisplayPosition::thirdperson_lefthand;
        }
        else if (!strcmp(position.c_str(), "firstperson_righthand")) {
            display.position = DisplayPosition::firstperson_righthand;
        }
        else if (!strcmp(position.c_str(), "firstperson_lefthand")) {
            display.position = DisplayPosition::firstperson_lefthand;
        }
        else if (!strcmp(position.c_str(), "gui")) {
            display.position = DisplayPosition::gui;
        }
        else if (!strcmp(position.c_str(), "head")) {
            display.position = DisplayPosition::head;
        }
        else if (!strcmp(position.c_str(), "ground")) {
            display.position = DisplayPosition::ground;
        }
        else if (!strcmp(position.c_str(), "fixed")) {
            display.position = DisplayPosition::fixed;
        }
        else {
            g_logger.LogError("ProcessModelDisplay", "Unknown display position: " + position);
            return;
        }

        display.initialized_ = true;

        model->AddDisplay(display, display.position);
    }
}

//TODO: Work on caching
static std::unique_ptr<Model::BlockModel> recursiveGetBlockModel(std::string jsonName, std::string namespaceIn) {
    std::unique_ptr<Model::BlockModel> model = nullptr;

    std::string jsonPath = "assets/" + namespaceIn + "/models/" + jsonName + ".json";
    
    json JSONData;

    try {
        std::ifstream file(jsonPath);
        if (!file.good()) { //checks if  it exist
            return nullptr;
        }
        JSONData = json::parse(file);
    }
    catch (const std::exception& e) {
        g_logger.LogError("recursiveGetBlockModel", e.what());
        return nullptr;
    }

    //Search for the parent
    for (auto& item : JSONData.items()) {
        if (item.key() == "parent") {
            std::string parentData = item.value();

            //Parse for the parent json

            std::vector<std::string> tokens = Tokenize(parentData, ':'); //This assumes that the parent is always in the same folder
            std::string parentJSON = tokens.back();
            std::string parentNamespace = tokens.front();
            
            if (tokens.size() == 1) { //default namespace is minecraft
                parentNamespace = DEFAULT_NAMESPACE;
            }

            model = recursiveGetBlockModel(parentJSON, parentNamespace);

            break;
        }
    }

    if (model == nullptr)
        model = std::make_unique<Model::BlockModel>();

    //Searches for the other stuff like textures and elements 

    for (auto& item : JSONData.items()) {
        if (!strcmp(item.key().c_str(), "elements")) {
            model->elements_.clear(); //Child elements override parent elements
            UpdateModelElements(model, item.value());
        }
        else if (!strcmp(item.key().c_str(), "textures")) {
            ProcessCuboidTexture(model, item.value());
        }
        else if (!strcmp(item.key().c_str(), "display")) {
            ProcessModelDisplay(model, item.value());
        }
        else if (!strcmp(item.key().c_str(), "ambientocclusion")) {
            model->ambient_occlusion_ = static_cast<bool>(item.value());
        }
    }

    return model;
}

std::unique_ptr<Model::BlockModel> getBlockModel(std::string blockNameIn, std::string namespaceIn) {
    //This will recursively go into parents files and build on it
    std::unique_ptr<Model::BlockModel> model = recursiveGetBlockModel(blockNameIn, namespaceIn);
    std::reverse(model->elements_.begin(), model->elements_.end());
    return model;

}
"./RenderEngine\\BlockModel\\ModelLoader.h"
#pragma once
#include "BlockModels.h"
#include <string>
#include <memory>

std::unique_ptr<Model::BlockModel> getBlockModel(std::string blockNameIn, std::string namespaceIn);
"./RenderEngine\\Camera\\camera.cpp"
"./RenderEngine\\Camera\\camera.h"
#pragma once

#include <vector>
// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods
enum Camera_Movement {
    CAM_FORWARD,
    CAM_BACKWARD,
    CAM_LEFT,
    CAM_RIGHT
};

// Default camera values

#include <gl/glew.h>
#include <GLFW/glfw3.h>
#include <glm/vec2.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>


const float YAW = -90.0f;
const float PITCH = 0.0f;
const float SPEED = 10.0f;
const float SENSITIVITY = 0.1f;
const float ZOOM = 45.0f;


// An abstract camera class that processes input and calculates the corresponding Euler Angles, Vectors and Matrices for use in OpenGL
class Camera
{
public:
    // camera Attributes
    glm::vec3 position_;
    glm::vec3 front_;
    glm::vec3 up_;
    glm::vec3 right_;
    glm::vec3 world_up_;

    glm::ivec2 screen_res_;
    // euler Angles
    float yaw_;
    float pitch_;
    // camera options
    float movement_speed_;
    float mouse_sensitivity_;
    float zoom_;
    float fov_ = 90;

    // constructor with vectors
    Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) : front_(glm::vec3(0.0f, 0.0f, -1.0f)), movement_speed_(SPEED), mouse_sensitivity_(SENSITIVITY), zoom_(ZOOM)
    {
        position_ = position;
        world_up_ = up;
        yaw_ = yaw;
        pitch_ = pitch;
        updateCameraVectors();
    }
    // constructor with scalar values
    Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : front_(glm::vec3(0.0f, 0.0f, -1.0f)), movement_speed_(SPEED), mouse_sensitivity_(SENSITIVITY), zoom_(ZOOM)
    {
        position_ = glm::vec3(posX, posY, posZ);
        world_up_ = glm::vec3(upX, upY, upZ);
        yaw_ = yaw;
        pitch_ = pitch;
        updateCameraVectors();
    }

    // returns the view matrix calculated using Euler Angles and the LookAt Matrix
    glm::mat4 GetViewMatrix()
    {
        return glm::lookAt(position_, position_ + front_, up_);
    }

    glm::mat4 GetModelMatrix()
    {
        return glm::mat4(1.0f);
    }

    // processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)
    void ProcessKeyboard(Camera_Movement direction, float deltaTime)
    {
        float velocity = movement_speed_ * deltaTime;
        if (direction == CAM_FORWARD)
            position_ += front_ * velocity;
        if (direction == CAM_BACKWARD)
            position_ -= front_ * velocity;
        if (direction == CAM_LEFT)
            position_ -= right_ * velocity;
        if (direction == CAM_RIGHT)
            position_ += right_ * velocity;
    }

    // processes input received from a mouse input system. Expects the offset value in both the x and y direction.
    void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true)
    {
        xoffset *= mouse_sensitivity_;
        yoffset *= mouse_sensitivity_;

        yaw_ += xoffset;
        pitch_ += yoffset;

        // make sure that when pitch is out of bounds, screen doesn't get flipped
        if (constrainPitch)
        {
            if (pitch_ > 89.0f)
                pitch_ = 89.0f;
            if (pitch_ < -89.0f)
                pitch_ = -89.0f;
        }

        // update Front, Right and Up Vectors using the updated Euler angles
        updateCameraVectors();
    }

    // processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis
    void ProcessMouseScroll(float yoffset)
    {
        zoom_ -= (float)yoffset;
        if (zoom_ < 1.0f)
            zoom_ = 1.0f;
        if (zoom_ > 70.0f)
            zoom_ = 70.0f;
    }

    // calculates the front vector from the Camera's (updated) Euler Angles
    void updateCameraVectors()
    {
        // calculate the new Front vector
        glm::vec3 front;
        front.x = cos(glm::radians(yaw_)) * cos(glm::radians(pitch_));
        front.y = sin(glm::radians(pitch_));
        front.z = sin(glm::radians(yaw_)) * cos(glm::radians(pitch_));
        front_ = glm::normalize(front);
        // also re-calculate the Right and Up vector
        right_ = glm::normalize(glm::cross(front_, world_up_));  // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.
        up_ = glm::normalize(glm::cross(right_, front_));
    }

private:
    
};
"./RenderEngine\\ChunkRenderer\\Batch\\ChunkBatch.cpp"
#include "ChunkBatch.h"

#include <iterator>
#include "../../../Level/Timer/Timer.h"

void ChunkDrawBatch::SetupBuffers() {
    memory_pool_.Allocate(max_buffer_size_);

    ibo_.GenBuffer();
    ssbo_.GenBuffer();
    array_.GenArray();

    ibo_.SetType(GL_DRAW_INDIRECT_BUFFER);
    ssbo_.SetType(GL_SHADER_STORAGE_BUFFER);

    ibo_.SetUsage(GL_STATIC_DRAW);
    ssbo_.SetUsage(GL_DYNAMIC_COPY);

    array_.Bind();

    ibo_.SetMaxSize((size_t)(max_buffer_size_ / 100));
    ibo_.InitializeData();

    memory_pool_.buffer_.Bind();
    array_.EnableAttriPTR(0, 1, GL_FLOAT, GL_FALSE, 2, 0);
    array_.EnableAttriPTR(1, 1, GL_FLOAT, GL_FALSE, 2, 1);
    memory_pool_.buffer_.Unbind();
    array_.Unbind();

    ssbo_.SetMaxSize((size_t)(max_buffer_size_ / 100));
    ssbo_.InitializeData();
}

void ChunkDrawBatch::Reset() {
//    MemoryPool.buffer.ResetBuffer();
    ibo_.ResetBuffer();
    ssbo_.ResetBuffer();
    array_.ResetArray();
    SetupBuffers();
}

void ChunkDrawBatch::Cleanup() {
    memory_pool_.buffer_.Delete();
    ibo_.Delete();
    ssbo_.Delete();
    array_.~VertexArray();

    draw_commands_.clear();
    render_list_.clear();
    chunk_shader_pos_.clear();
    render_list_offset_lookup_.clear();

}

void ChunkDrawBatch::GenDrawCommands(int renderDistance, int verticalRenderDistance) {

    Timer time;

    if (render_list_.size() > draw_commands_.size()) {
        UpdateCommandBufferSize();
    }

    if (!update_commands_)
        return;

    frustum_.CalculateFrustum(camera);

    glm::ivec3 position(floor(camera->position_.x / 16.f), floor(camera->position_.y / 16.f), floor(camera->position_.z / 16.f));
    
    bool useNew = false;

    if (useNew) {
        std::vector<DrawCommandIndirect> cmds = {};
        std::vector<int> cmdPos = {};

        amount_of_chunks_being_rendered_ = command_buffer_.GetDrawCommandsSorted(cmds, cmdPos);

        ssbo_.InsertSubData(0, (amount_of_chunks_being_rendered_ * 3) * sizeof(int), cmdPos.data());
        ibo_.InsertSubData(0, amount_of_chunks_being_rendered_ * sizeof(DrawCommandIndirect), cmds.data());
    }
    else {
        int index = 1;

        for (auto& data_ : render_list_) {
            auto& data = data_.second;

            int x = data.position_.x;
            int y = data.position_.y;
            int z = data.position_.z;
            
            float deltaX = static_cast<float>(x - position.x);
            float deltaY = static_cast<float>(y - position.y);
            float deltaZ = static_cast<float>(z - position.z);


            float dx2 = deltaX * deltaX / (renderDistance * renderDistance);
            float dy2 = deltaY * deltaY / (verticalRenderDistance * verticalRenderDistance);
            float dz2 = deltaZ * deltaZ / (renderDistance * renderDistance);

            if (dx2 + dy2 + dz2 < 1.f) {
                if (frustum_.SphereInFrustum((float)(x << 4), (float)(y << 4), (float)(z << 4), 24.3f)) { // << 4 means multiply by 4
                    draw_commands_[index - 1].set(static_cast<uint32_t>(data.mem_size_ >> 3), 1, static_cast<uint32_t>(data.mem_offset_ >> 3), index);
                    chunk_shader_pos_[(index - 1) * 3 + 0] = x;
                    chunk_shader_pos_[(index - 1) * 3 + 1] = y;
                    chunk_shader_pos_[(index - 1) * 3 + 2] = z;
                
                    index++;
                }
            }
        }


        index--;

        amount_of_chunks_being_rendered_ = index;

        ssbo_.InsertSubData(0, (amount_of_chunks_being_rendered_ * 3) * sizeof(int), chunk_shader_pos_.data());
        ibo_.InsertSubData(0, amount_of_chunks_being_rendered_ * sizeof(DrawCommandIndirect), draw_commands_.data());
        
    }

}

void ChunkDrawBatch::UpdateCommandBufferSize() {
    draw_commands_.resize(render_list_.size());
    chunk_shader_pos_.resize(render_list_.size() * 3);
}

bool ChunkDrawBatch::AddChunkVertices(const std::vector<uint32_t>& Data, const ChunkPos& pos) {
    //size_t DataSize = Data.size() * sizeof(uint32_t);

    ChunkMemoryPoolOffset memoryPoolBlockData = memory_pool_.AddChunk(Data, pos);

    if (memoryPoolBlockData.mem_offset_ == ULLONG_MAX) {
        return false;
    }
    
    render_list_[memoryPoolBlockData.mem_offset_] = memoryPoolBlockData;
    render_list_offset_lookup_[pos] = memoryPoolBlockData.mem_offset_;
    amount_of_chunks_++;
    update_commands_ = true;
//    CommandBuffer.AddDrawCommand(DrawCommandIndirect(memoryPoolBlockData.mem_size_ >> 3, 1, memoryPoolBlockData.mem_offset_ >> 3, 0),x,y,z);
    return true;
}

void ChunkDrawBatch::DeleteChunkVertices(const ChunkPos& id) {
    if (memory_pool_.CheckChunk(id)) {
        ChunkMemoryPoolOffset ChunkMemOffset = memory_pool_.GetChunkMemoryPoolOffset(id);
        if (ChunkMemOffset.mem_offset_ == ULLONG_MAX) {
            g_logger.LogError("ChunkDrawBatch::DeleteChunkVertices", "Failed to delete chunk: " + std::to_string(id));
            return;
        }
        render_list_.erase(ChunkMemOffset.mem_offset_);
        memory_pool_.DeleteChunk(id);
        render_list_offset_lookup_.erase(id);
//        CommandBuffer.DeleteDrawCommand(ChunkPosToPOS(id));
        amount_of_chunks_--;
        update_commands_ = true;
        
    }
}

void ChunkDrawBatch::SetMaxSize(size_t size) {
    max_buffer_size_ = size;
}

void ChunkDrawBatch::Bind() {
    array_.Bind();
    ibo_.Bind();
    memory_pool_.buffer_.Bind();
    ssbo_.Bind();
    ssbo_.BindBase(2);
}

void ChunkDrawBatch::Unbind() {
    ssbo_.UnbindBase(2);
    ssbo_.Unbind();
    ibo_.Unbind();
    memory_pool_.buffer_.Unbind();
    array_.Unbind();
}

void ChunkDrawBatch::Draw() {
    glMultiDrawArraysIndirect(GL_TRIANGLES, (GLvoid*)0, (GLsizei)amount_of_chunks_being_rendered_, 0);
}

void ChunkDrawBatch::Defrager(size_t iterations) {
    int i = 0;

    size_t fragmentCount = memory_pool_.memory_pool_.GetFreeSpaceFragmentCount();

    if (fragmentCount == 1) {
        return;
    }

    iterations = std::min(iterations, fragmentCount - 1);

    while (i < iterations) {
        i++;

        if (memory_pool_.memory_pool_.free_memory_blocks_.size() == 1) {
            return;
        }

        MemoryManagement::MemoryBlock freeMemoryBlock = memory_pool_.memory_pool_.free_memory_blocks_.begin()->second;

        size_t freeSpaceOffset = freeMemoryBlock.offset_;

        const auto& reserveIt = memory_pool_.memory_pool_.reserved_memory_blocks_.getIterator(freeMemoryBlock.size_ + freeMemoryBlock.offset_);

        const MemoryManagement::MemoryBlock& reservedBlock = reserveIt->second;

        ChunkPos pos = memory_pool_.memory_chunk_offsets_[reservedBlock.offset_];

        // --- Temporarily remove from render list & pool ---
       // (Slightly inefficient to lookup again, but safer)
        if (render_list_offset_lookup_.count(pos)) {
            size_t render_list_offset = render_list_offset_lookup_[pos];
            render_list_.erase(render_list_offset);
            render_list_offset_lookup_.erase(pos);
        }
        else {
            g_logger.LogError("Defrager", "Chunk Pos not found in render_list_offset_lookup_ during defrag!");
            // This indicates a potential inconsistency, skip this defrag step
            continue;
        }
        // Delete logic needs the size from the offset lookup or reservedBlock
        memory_pool_.DeleteChunk(pos); // This calls DeallocateSpace internally

        // --- Perform the GPU Copy ---
        // 1. Copy from main buffer to staging buffer
        if (reservedBlock.size_ > memory_pool_.stagging_buffer_.GetMaxSize()) {
            g_logger.LogError("Defrager", "Chunk size too large for staging buffer! Skipping defrag for this block."); // TODO: Fix this later 
            // Need to re-add the chunk info we just removed, or handle this state
            // Re-adding is complex, maybe just log and accept fragmentation for this block.
            continue;
        }
        memory_pool_.buffer_.CopyTo(memory_pool_.stagging_buffer_, reservedBlock.offset_, 0, reservedBlock.size_);

        // 2. *** INSERT MEMORY BARRIER ***
        glMemoryBarrier(GL_ALL_BARRIER_BITS); // Or GL_COPY_WRITE_BARRIER_BIT or GL_ALL_BARRIER_BITS

        // 3. Add chunk back at the new location (copies from staging buffer)
        ChunkMemoryPoolOffset newMemoryPoolBlockData = memory_pool_.AddChunkStaggingBuffer(pos, freeMemoryBlock.offset_, reservedBlock.size_);

        if (newMemoryPoolBlockData.mem_offset_ == std::numeric_limits<size_t>::max()) {
            g_logger.LogError("Defrager", "Failed to re-add chunk from staging buffer during defrag!");
            // State is potentially inconsistent here, might need recovery logic
            continue;
        }

        // --- Update render list with new offset ---
        render_list_[newMemoryPoolBlockData.mem_offset_] = newMemoryPoolBlockData;
        render_list_offset_lookup_[pos] = newMemoryPoolBlockData.mem_offset_;

        update_commands_ = true; // Mark commands need regeneration
    }
}



void ChunkDrawBatch::ErrorCheck() {
    FastHashSet<ChunkPos> usedChunk;
    std::string logs = "";

    for (const auto& c : render_list_) {
        if (usedChunk.count(c.second.position_)) {
            logs += "Chunk: " + std::to_string(c.first) + "\n";
        }
        else {
            usedChunk.insert(c.second.position_);
        }

    }

    g_logger.LogDebug("ChunkDrawBatch::ErrorCheck", "Errors: \n" + logs);


}
"./RenderEngine\\ChunkRenderer\\Batch\\ChunkBatch.h"
#pragma once
#include <gl/glew.h>
#include <GLFW/glfw3.h>

#include "RenderCommandBuffer.h"
#include "../../../Utils/LogUtils.h"
#include "../../Camera/camera.h"
#include "../../Frustum/frustum.h"
#include "../../../Utils/MathHelper.h"
#include "../../../Level/Chunk/Chunk.h"
#include "../../OpenGL/Buffers/Buffer.h"
#include "../MemoryPool/ChunkMemoryPool.h"
#include <list>
#include <map>
#include <array>

class ChunkDrawBatch {
private:
    ChunkDrawCommandBuffer command_buffer_;
    CFrustum frustum_;
    Buffer ibo_, ssbo_;
    VertexArray array_;
    size_t max_buffer_size_ = NULL;

    bool update_commands_ = false;

    FastHashMap<ChunkPos, size_t> render_list_offset_lookup_; //f: ChunkPos  -> Offset
    std::vector<GLint> chunk_shader_pos_;

    std::vector<DrawCommandIndirect> draw_commands_;

    size_t amount_of_chunks_ = 0;
    size_t amount_of_chunks_being_rendered_ = 0;

    Buffer transfer_buffer_;
public:

    void SetupBuffers();

    void Reset();

    void GenDrawCommands(int RenderDistance, int verticalRenderDistance);

    bool AddChunkVertices(const std::vector<uint32_t>& Data, const ChunkPos& pos);

    void DeleteChunkVertices(const ChunkPos& ID);

    void SetMaxSize(size_t size);

    void Draw();

    void Bind();

    void Unbind();

    void Cleanup();

    void Defrager(size_t iterations);

    void UpdateCommandBufferSize();

    void ErrorCheck();

    Camera* camera = nullptr; // TODO: Rename

    std::map<size_t, ChunkMemoryPoolOffset> render_list_; //f: Offset -> RenderInfo

    double debug_time_ = 0.0;

    ChunkGPUMemoryPool memory_pool_;
};
"./RenderEngine\\ChunkRenderer\\Batch\\RenderCommandBuffer.h"
#pragma once
#include <unordered_map>
#include <vector>
#include <glm/vec3.hpp>
#include <stack>
#include "../../../Level/Chunk/ChunkPos/ChunkPos.h"
#include <iostream>
#include "../../../Level/Typenames.h"
struct DrawCommandIndirect {
    unsigned int  count_;
    unsigned int  instance_count_;
    unsigned int  first_;
    unsigned int  base_instance_;

    DrawCommandIndirect() :
        count_{ 0 },
        instance_count_{ 0 },
        first_{ 0 },
        base_instance_{ 0 } {

    }

    DrawCommandIndirect(uint32_t count, uint32_t instanceCount, uint32_t first, uint32_t baseInstance) : 
        count_{count},
        instance_count_{ instanceCount },
        first_{ first },
        base_instance_{ baseInstance } {

    }

    void set(uint32_t count, uint32_t instanceCount, uint32_t first, uint32_t baseInstance) {
        count_ = count;
        instance_count_ = instanceCount;
        first_ = first;
        base_instance_ = baseInstance;
    }
};

namespace CMDGraph {

    static const int GetOppositeSide(int side) {
        return ((side >> 1) * 2) + ((~side) & 0b1);
    }

    const int NX = 0x00;
    const int PX = 0x01;
    const int NY = 0x02;
    const int PY = 0x03;
    const int NZ = 0x04;
    const int PZ = 0x05;

    struct CommandPtr {
        CommandPtr* neighbor_[6]{ nullptr,nullptr,nullptr,nullptr,nullptr,nullptr };
        DrawCommandIndirect cmd_;
        ChunkPos position_;
        int visit_id_ = 0;

        CommandPtr() {
            for (int i = 0; i < 6; i++) {
                neighbor_[i] = nullptr;
            }
        }

        CommandPtr(DrawCommandIndirect cmd_) : cmd_(cmd_) {
            for (int i = 0; i < 6; i++) {
                neighbor_[i] = nullptr;
            }
        }

        CommandPtr(DrawCommandIndirect cmd_, ChunkPos pos) : cmd_(cmd_), position_(pos) {
            for (int i = 0; i < 6; i++) {
                neighbor_[i] = nullptr;
            }
        }

        ~CommandPtr() {
        //    std::cout << "destroy\n";
        }

        void PrepareDelete() {
            for (int i = 0; i < 3; i++) {
                int index1 = i * 2;
                int index2 = i * 2 + 1;

                if ((neighbor_[index1] != nullptr) && (neighbor_[index2] != nullptr)) {
                    neighbor_[index1]->neighbor_[index2] = neighbor_[index2];
                    neighbor_[index2]->neighbor_[index1] = neighbor_[index1];
                }
                else {
                    if ((neighbor_[index1] != nullptr)) {
                        neighbor_[index1]->neighbor_[index2] = nullptr;
                    }
                    if ((neighbor_[index2] != nullptr)) {
                        neighbor_[index2]->neighbor_[index1] = nullptr;
                    }
                }
            }
        }

        float GetSquareDistance(float px, float py, float pz) {
            return (px - (float)position_.x) * (px - (float)position_.x) +
                (py - (float)position_.y) * (py - (float)position_.y) +
                (pz - (float)position_.z) * (pz - (float)position_.z);
        }

        float GetSquareDistance(const ChunkPos& other) {
            return GetSquareDistance(static_cast<float>(other.x), static_cast<float>(other.y), static_cast<float>(other.z));
        }

        float GetSquareDistance(const glm::vec3& other) {
            return GetSquareDistance(other.x, other.y, other.z);
        }

        void SetNeighbor(CommandPtr* node, int side, int depth = 0) {

            // Early exit if trying to set a neighbor to itself
            if (node == this) return;

            if ((neighbor_[side] == nullptr) && (node->neighbor_[GetOppositeSide(side)] == nullptr)) {
                neighbor_[side] = node;
                node->neighbor_[GetOppositeSide(side)] = this;
                return;
            }

            CommandPtr* p1 = this;
            CommandPtr* p2 = node;
            CommandPtr* p3 = neighbor_[side];
            CommandPtr* p4 = node->neighbor_[GetOppositeSide(side)];

            //Temp set to null
            neighbor_[side] = nullptr;
            if (p3 != nullptr) {
                p3->neighbor_[GetOppositeSide(side)] = nullptr;
            }
            node->neighbor_[GetOppositeSide(side)] = nullptr;
            if (p4 != nullptr) {
                p4->neighbor_[side] = nullptr;
            }

            if ((p4 != nullptr) && (p3 == nullptr)) {
                int side_p4 = p1->GetSideLocation(p4->position_);

                if (side_p4 == side) { //OK
                    p1->SetNeighbor(p4, side, depth + 1);

                    p4->neighbor_[side] = p2;
                    p2->neighbor_[GetOppositeSide(side)] = p4;
                }
                else {
                    p1->SetNeighbor(p4, side_p4, depth + 1);

                    p1->neighbor_[side] = p2;
                    p2->neighbor_[GetOppositeSide(side)] = p1;
                }
                return;
            }

            if ((p4 == nullptr) && (p3 != nullptr)) {
                //first check if p4 or p3 is closer to p1

                float p1_distance_p3 = p1->GetSquareDistance(p3->position_);
                float p1_distance_p2 = p1->GetSquareDistance(p2->position_);

                if (p1_distance_p3 <= p1_distance_p2) { //this implies that p3 is the closest is is kept the same
                    
                    //reconnects p3 and p1
                    p1->neighbor_[side] = p3;
                    p3->neighbor_[GetOppositeSide(side)] = p1;

                    int side_p2 = p3->GetSideLocation(p2->position_);
                    p3->SetNeighbor(p2, side_p2, depth + 1);

                }
                else {
                    p1->neighbor_[side] = p2; //no data lost occur here since if p4 is null, it implies p2 neighbor is null
                    p2->neighbor_[GetOppositeSide(side)] = p1;

                    int side_p3 = p2->GetSideLocation(p3->position_);
                    p2->SetNeighbor(p3, side_p3, depth + 1);
                }
                return;
            }

            //return;
            //last case (p4 != nullptr) && (p3 != nullptr)
                
            float p1_distance_p3 = p1->GetSquareDistance(p3->position_);
            float p1_distance_p2 = p1->GetSquareDistance(p2->position_);
            float p1_distance_p4 = p1->GetSquareDistance(p4->position_);

            if ((p1_distance_p3 <= p1_distance_p2) && (p1_distance_p3 <= p1_distance_p4)) {  // p3 is closest to p1 //OK
                //reconnects p3 and p1
                p1->neighbor_[side] = p3;
                p3->neighbor_[GetOppositeSide(side)] = p1;

                //connect p4 to p3 at side p3_side_p4
                int p3_side_p4 = p3->GetSideLocation(p4->position_);
                p3->SetNeighbor(p4, p3_side_p4, depth + 1);
                
                p4->neighbor_[side] = p2;
                p2->neighbor_[GetOppositeSide(side)] = p4;
                

                return;
            }
            

            if ((p1_distance_p4 <= p1_distance_p3) && (p1_distance_p4 <= p1_distance_p2)) {  //p4 is closest

                //connect p4 and p1
                p1->SetNeighbor(p4, side, depth + 1);

                if (p1_distance_p3 >= p1_distance_p2) {
                    int p4_side_p2 = p4->GetSideLocation(p2->position_);

                    if (p4_side_p2 == side) {
                        p4->SetNeighbor(p2, p4_side_p2, depth + 1);

                        int p2_side_p3 = p2->GetSideLocation(p3->position_);
                        p2->SetNeighbor(p3, p2_side_p3, depth + 1);

                    }
                    else {
                        p4->SetNeighbor(p2, p4_side_p2, depth + 1);
                        int p4_side_p3 = p4->GetSideLocation(p3->position_);
                        p4->SetNeighbor(p3, p4_side_p3, depth + 1);
                    }
                }
                else {
                    std::cout << "test\n";
                }
                
                return;
                
            }

            if ((p1_distance_p2 <= p1_distance_p3) && (p1_distance_p2 <= p1_distance_p4)) { //if p2 is closer, it implies p4 is behind p1

                //connect p4 and p1
                int p1_side_p4 = p1->GetSideLocation(p4->position_);
                p1->SetNeighbor(p4, p1_side_p4, depth + 1);

                //connect p2 to p1
                p1->SetNeighbor(p2, side, depth + 1);

                //connect p3 to p2
                int p2_side_p3 = p2->GetSideLocation(p3->position_);
                p2->SetNeighbor(p3, p2_side_p3, depth + 1);
            }
        }

        int GetSideLocation(const ChunkPos& p2) const {
            ChunkPos relativePosition = p2 - position_;

            int x = relativePosition.x;
            int y = relativePosition.y;
            int z = relativePosition.z;

            if ((abs(x) >= abs(z)) && (abs(x) >= abs(y))) {
                if (x >= 0) {
                    return PX;
                }
                else {
                    return NX;
                }
            }
            if ((abs(z) >= abs(x)) && (abs(z) >= abs(y))) {
                if (z >= 0) {
                    return PZ;
                }
                else {
                    return NZ;
                }
            }
            if ((abs(y) >= abs( x)) && (abs(y) >= abs(z))) {
                if (y >= 0) {
                    return PY;
                }
                else {
                    return NY;
                }
            }
            throw std::exception("Error");
        }
    };
}

class ChunkDrawCommandBuffer {
public:
    void Initialize() {

    }

    void AddDrawCommand(DrawCommandIndirect cmd, const ChunkPos& pos) {
        CMDGraph::CommandPtr* ptr = new CMDGraph::CommandPtr(cmd, pos);
        command_map_[pos] = ptr;
        AddToGraph(ptr);
    }

    void UpdateCurrentPosition(glm::vec3 NewPosition) {
        current_position_ = NewPosition;
    }

    size_t GetDrawCommandsSorted(std::vector<DrawCommandIndirect>& cmds, std::vector<int>& cmdPos) {
        
        for (auto& arr : commands_) {
            arr.clear();
        }

        for (auto& arr : commands_position_) {
            arr.clear();
        }
        count = 0;
        size_t size = 0;
        TraverseTree(root_, 0);

        current_node_visit_id_++;

        if (current_node_visit_id_ == 16) {
            current_node_visit_id_ = 0;
        }

        for (long long i = static_cast<long long>(commands_.size()) - 1; i >= 0; i--) {
            size += commands_[i].size();
            cmds.insert(cmds.end(), commands_[i].begin(), commands_[i].end());
            cmdPos.insert(cmdPos.end(), commands_position_[i].begin(), commands_position_[i].end());
        }

        for (int i = 0; i < size; i++) {
            cmds.at(i).base_instance_ = i + 1;
        }

        //std::cout << count << ", " << CommandMap.size() << "\n";

        return size;
    }

    void DeleteDrawCommand(const ChunkPos& pos) {
        CMDGraph::CommandPtr* node = command_map_[pos];
        command_map_.erase(pos);

        if (node != root_) {
            node->PrepareDelete();
            delete node;
            return;
        }

        float distances[6]{0.f,0.f,0.f,0.f,0.f,0.f};

        CMDGraph::CommandPtr* rootNeighbors[6]{nullptr};

        for (int i = 0; i < 6; i++) {
            rootNeighbors[i] = node->neighbor_[i];
        }
        node->PrepareDelete();
        delete node;

        for (int i = 0; i < 6; i++) {
            if (rootNeighbors[i] == nullptr) {
                continue;
            }

            distances[i] = rootNeighbors[i]->GetSquareDistance(current_position_);
        }

        float min = FLT_MAX;

        for (int i = 0; i < 6; i++) {
            if (distances[i] == 0.f) {
                continue;
            }

            min = std::min(min, distances[i]);
        }

        if (min == FLT_MAX) {
            root_ = nullptr;
            return;
        }

        for (int i = 0; i < 6; i++) {
            if (distances[i] == min) {
                root_ = rootNeighbors[i];
                break;
            }
        }

    }

    int count = 0;

    void TraverseTree(CMDGraph::CommandPtr* node, int depth) {
        if (node == nullptr) {
            return;
        }

        if (node->visit_id_ == current_node_visit_id_) {
            return;
        }

        node->visit_id_ = current_node_visit_id_;

        if (commands_.size() <= depth) {
            commands_.emplace_back();
            commands_position_.emplace_back();
            commands_layer_.emplace_back();
        }

        commands_[depth].push_back(node->cmd_);
        commands_position_[depth].push_back(node->position_.x);
        commands_position_[depth].push_back(node->position_.y);
        commands_position_[depth].push_back(node->position_.z);
    //    CommandsLayer[depth].push_back(depth);
        count++;
        for (int side = 0; side < 6; side++) {
             TraverseTree(node->neighbor_[side], depth + 1);
        }
    }

    
private:
    bool VerifyTree(CMDGraph::CommandPtr* node) { //debug
        bool isCorrect = true;

        if (node->visit_id_ == current_node_visit_id_) {
            return isCorrect;
        }

        for (int i = 0; i < 6; i++) {
            if (node->neighbor_[i] == nullptr) {
                continue;
            }

            if (node->neighbor_[i]->neighbor_[CMDGraph::GetOppositeSide(i)] != node) {
                return false;
            }
            else {
                if (node->neighbor_[i]->visit_id_ != current_node_visit_id_) {
                    isCorrect = VerifyTree(node->neighbor_[i]);
                }
                
            }
        }

        node->visit_id_ = current_node_visit_id_;

        return isCorrect;
    }

    std::vector<std::vector<DrawCommandIndirect>> commands_; //[Tree Depth][Draw Commands]
    std::vector<std::vector<int>> commands_position_; //[Tree Depth][Draw Commands Position]
    std::vector<std::vector<int>> commands_layer_; //[Tree Depth][Layer]

    int current_node_visit_id_ = 1;

    void AddToGraph(CMDGraph::CommandPtr* node) {
        //If root doesn't exist add to root
        if (root_ == nullptr) {
            root_ = node;
            return;
        }

        //If root exist, check if the chunk is closer to the actual root if so change the root

        if (root_->GetSquareDistance(current_position_) > node->GetSquareDistance(current_position_)) {
            int loc = node->GetSideLocation(root_->position_);

            CMDGraph::CommandPtr* tmp = root_;
            root_ = node;
            node->SetNeighbor(tmp, loc);
            return;
        }

        CMDGraph::CommandPtr* curr = root_;

        while (true) {
            int side = curr->GetSideLocation(node->position_);

            if (curr->neighbor_[side] == nullptr) {
                curr->SetNeighbor(node, side);
                return;
            }

            if (curr->neighbor_[side]->GetSquareDistance(node->position_) >= curr->GetSquareDistance(node->position_)) {
                curr->SetNeighbor(node, side);
                return;
            }

            curr = curr->neighbor_[side];
        }
    }

    glm::vec3 current_position_ = glm::vec3(0.f,0.f,0.f);

    CMDGraph::CommandPtr* root_ = nullptr;
    FastHashMap<ChunkPos, CMDGraph::CommandPtr*> command_map_;
};


"./RenderEngine\\ChunkRenderer\\MemoryPool\\ChunkMemoryPool.h"
#pragma once
#include "../../OpenGL/Buffers/Buffer.h"
#include "../../../Level/Chunk/ChunkPos/ChunkPos.h"
#include "../../../Level/Typenames.h"
#include <vector>
#include <map>

struct ChunkMemoryPoolOffset {
    size_t mem_offset_ = NULL;
    size_t mem_size_ = NULL;
    ChunkPos position_;

    ChunkMemoryPoolOffset() {};
    ChunkMemoryPoolOffset(size_t offset, size_t size) : mem_offset_(offset), mem_size_(size) {};
    ChunkMemoryPoolOffset(size_t offset, size_t size, ChunkPos position) : mem_offset_(offset), mem_size_(size), position_(position) {};
};


namespace MemoryManagement {

    struct MemoryBlock {
        MemoryBlock() {};
        MemoryBlock(size_t memOffset, size_t memSize) : offset_(memOffset), size_(memSize){}

        size_t offset_ = NULL;
        size_t size_ = NULL;
    };

    class BlockManagement {
    public:
        void Add(MemoryBlock block) {
            std::map<size_t, MemoryBlock>::iterator it = mem_blocks_.emplace(block.offset_, block).first;
            mem_blocks_iterators_.emplace(block.offset_, it);
        }

        void Delete(size_t offset) {
            if (!mem_blocks_iterators_.count(offset)) {
                return;
            }
            std::map<size_t, MemoryBlock>::const_iterator it = mem_blocks_iterators_[offset];
            Delete(it);
        }

        void Delete(std::map<size_t, MemoryBlock>::const_iterator it) {
            size_t offset = it->first;

            mem_blocks_.erase(it);
            mem_blocks_iterators_.erase(offset);
        }

        std::map<size_t, MemoryBlock>::const_iterator getIterator(size_t offset) const {
            if (mem_blocks_iterators_.count(offset)) {
                const auto& it = mem_blocks_iterators_.find(offset);
                return it->second;
            }
            else {
                return end();
            }
        }

        std::map<size_t, MemoryBlock>::const_iterator begin() const {
            return mem_blocks_.begin();
        }

        std::map<size_t, MemoryBlock>::const_iterator end() const {
            return mem_blocks_.end();
        }

        std::map<size_t, MemoryBlock>::const_reverse_iterator rbegin() const  {
            return mem_blocks_.rbegin();
        }

        std::map<size_t, MemoryBlock>::const_reverse_iterator rend() const  {
            return mem_blocks_.rend();
        }

        std::map<size_t, MemoryBlock>::const_iterator lower_bound(size_t k) const { //Get latest element less than k
            auto it = mem_blocks_.lower_bound(k);
            it--;
            return it;
        }

        std::map<size_t, MemoryBlock>::const_iterator upper_bound(size_t k) const { //Get latest element greater than k
            return mem_blocks_.upper_bound(k);
        }

        size_t size() const {
            return mem_blocks_.size();
        }

        size_t GetFragmentCount() const {
            return mem_blocks_.size();
        }

    private:
        std::map<size_t, MemoryBlock> mem_blocks_;
        FastHashMap<size_t, std::map<size_t, MemoryBlock>::const_iterator> mem_blocks_iterators_;
    };

    class MemoryPoolManager {
    public:
        void Initialize(size_t spaceAvailable) {
            pool_size_ = spaceAvailable;
            free_memory_blocks_.Add(MemoryBlock{ 0, pool_size_ });
            std::multimap<size_t, size_t>::iterator it = sorted_mem_sizes_.emplace(pool_size_, 0); //use for deletions
            sorted_mem_sizes_iterators[0] = it;
        }

        void AllocateSpace(size_t memOffset, size_t memSize) { //Assumes input are valid

            reserved_memory_blocks_.Add(MemoryBlock{ memOffset, memSize });

            std::map<size_t, MemoryBlock>::const_iterator left = free_memory_blocks_.getIterator(memOffset);

            MemoryBlock current = left->second;

            sorted_mem_sizes_.erase(sorted_mem_sizes_iterators[left->first]);
            sorted_mem_sizes_iterators.erase(left->first);
            free_memory_blocks_.Delete(left);
            

            if (current.size_ == memSize)
                return;

            size_t newFreeSpaceOffset = memOffset + memSize;
            size_t newFreeSpaceSize = current.size_ - memSize;

            MemoryBlock newFreeBlock(newFreeSpaceOffset, newFreeSpaceSize);
            
            std::multimap<size_t, size_t>::iterator it = sorted_mem_sizes_.emplace(newFreeSpaceSize, newFreeSpaceOffset); //use for deletions
            sorted_mem_sizes_iterators[newFreeSpaceOffset] = it;

            free_memory_blocks_.Add(newFreeBlock);
        }

        void DeallocateSpace(size_t MemOffset, size_t MemSize) {
            std::map<size_t, MemoryBlock>::const_iterator rightBlockFree = free_memory_blocks_.upper_bound(MemOffset);
            std::map<size_t, MemoryBlock>::const_iterator leftBlockFree = free_memory_blocks_.lower_bound(MemOffset);

            bool isFreeBlockRight = true;
            bool isFreeBlockLeft = true;

            if (rightBlockFree == free_memory_blocks_.end()) {
                isFreeBlockRight = false;
            } else {
                if (rightBlockFree->second.offset_ != MemOffset + MemSize) {
                    isFreeBlockRight = false;
                }
            }

            if (leftBlockFree == free_memory_blocks_.end()) {
                isFreeBlockLeft = false;
            } else {
                if (leftBlockFree->second.offset_ + leftBlockFree->second.size_ != MemOffset) {
                    isFreeBlockLeft = false;
                }
            }

            size_t memoryRight = 0, memoryLeft = 0;

            if (isFreeBlockRight) {
                memoryRight = rightBlockFree->second.offset_ + rightBlockFree->second.size_;
            } else {
                memoryRight = MemOffset + MemSize;
            }

            if (isFreeBlockLeft) {
                memoryLeft = leftBlockFree->second.offset_;
            } else {
                memoryLeft = MemOffset;
            }

            size_t freeMemoryOffset = memoryLeft;
            size_t freeMemorySize = memoryRight - memoryLeft;

            //Clear Free Spaces

            if (isFreeBlockLeft) {
                sorted_mem_sizes_.erase(sorted_mem_sizes_iterators[leftBlockFree->first]);
                sorted_mem_sizes_iterators.erase(leftBlockFree->first);
                free_memory_blocks_.Delete(leftBlockFree);
            }
                
            if (isFreeBlockRight) {
                sorted_mem_sizes_.erase(sorted_mem_sizes_iterators[rightBlockFree->first]);
                sorted_mem_sizes_iterators.erase(rightBlockFree->first);
                free_memory_blocks_.Delete(rightBlockFree);
            }
                

            //Add Free Space
            free_memory_blocks_.Add(MemoryBlock(freeMemoryOffset, freeMemorySize));

            std::multimap<size_t, size_t>::iterator it = sorted_mem_sizes_.emplace(freeMemorySize, freeMemoryOffset); //use for deletions
            sorted_mem_sizes_iterators[freeMemoryOffset] = it;

            //Clear Reserve Space
            reserved_memory_blocks_.Delete(MemOffset);
        }

        size_t FindFreeSpace(size_t MemSize) const {
            auto it1 = sorted_mem_sizes_.lower_bound(MemSize);

            if (it1 != sorted_mem_sizes_.end())
                return it1->second;
            return ULLONG_MAX;
        }

        size_t GetFreeSpaceFragmentCount() const {
            return free_memory_blocks_.GetFragmentCount();
        }

        size_t GetReserveSpaceFragmentCount() const {
            return reserved_memory_blocks_.GetFragmentCount();
        }

        BlockManagement free_memory_blocks_;
        BlockManagement reserved_memory_blocks_;

    private:
        size_t pool_size_ = 0;
        
        std::multimap<size_t, size_t> sorted_mem_sizes_; // BlockSize, BlockOffset
        FastHashMap<size_t, std::multimap<size_t, size_t>::iterator> sorted_mem_sizes_iterators; // Offset, iterator
    };

    struct MemoryPoolStatistics {
        double fragmentation_rate_ = 0.0f;
        size_t memory_usage_ = 0;
        size_t full_memory_usage_ = 0;
    };
}

class ChunkGPUMemoryPool {
public:
    //TODO: Add some cleanup
    void Allocate(size_t memoryPoolSize) {
        if (memory_pool_size_ != 0) {
            g_logger.LogWarn("ChunkGPUMemoryPool::Allocate", "Allocate called on already allocated pool. Re-allocating.");

            buffer_.Delete();
            stagging_buffer_.Delete();
            memory_pool_ = MemoryManagement::MemoryPoolManager(); // Re-create manager
            chunk_memory_offsets_.clear();
            memory_chunk_offsets_.clear();
            statistics_ = MemoryManagement::MemoryPoolStatistics(); // Reset stats
        }

        memory_pool_size_ = memoryPoolSize;
        if (memory_pool_size_ == 0) {
            g_logger.LogError("ChunkGPUMemoryPool::Allocate", "Attempted to allocate with zero size.");
            return;
        }

        // Use the modified Create method with dynamic=true
        buffer_.Create(GL_ARRAY_BUFFER, memory_pool_size_, true, nullptr);
        if (!buffer_.IsInitialized()) {
            g_logger.LogError("ChunkGPUMemoryPool::Allocate", "Failed to create main buffer storage.");
            memory_pool_size_ = 0; // Reset size on failure
            return;
        }


        size_t stagingSize = 10000000; 
        stagging_buffer_.Create(GL_COPY_WRITE_BUFFER, stagingSize, true, nullptr); // Dynamic for potential reuse
        if (!stagging_buffer_.IsInitialized()) {
            g_logger.LogError("ChunkGPUMemoryPool::Allocate", "Failed to create staging buffer storage.");
            buffer_.Delete(); // Clean up main buffer if staging fails
            memory_pool_size_ = 0;
            return;
        }
        memory_pool_.Initialize(memory_pool_size_);
        g_logger.LogInfo("ChunkGPUMemoryPool::Allocate", "Allocated GPU memory pool. Size: " + std::to_string(memory_pool_size_) + " bytes.");
    }

    void DeleteChunk(ChunkPos pos) {
        if (!chunk_memory_offsets_.count(pos)) {
            g_logger.LogDebug("ChunkGPUMemoryPool::AddChunk","Attempted to delete non-existant chunk with ID " + std::to_string(pos));
            return;
        }

        ChunkMemoryPoolOffset chunkOffsetData = chunk_memory_offsets_[pos];
        memory_pool_.DeallocateSpace(chunkOffsetData.mem_offset_, chunkOffsetData.mem_size_);
        chunk_memory_offsets_.erase(pos);

        memory_chunk_offsets_.erase(chunkOffsetData.mem_offset_);

        statistics_.memory_usage_ -= chunkOffsetData.mem_size_;
        Update();
    }

    ChunkMemoryPoolOffset AddChunk(const std::vector<uint32_t>& vertices, ChunkPos pos) { //assumes vertices.size() != 0
        size_t blockSize = vertices.size() * sizeof(uint32_t);
        size_t blockOffset = memory_pool_.FindFreeSpace(blockSize);

        if (blockOffset == ULLONG_MAX) { //Check if it is out of space
            g_logger.LogError("ChunkGPUMemoryPool::AddChunk", "Out of space!");
            return ChunkMemoryPoolOffset{ ULLONG_MAX, ULLONG_MAX };
        }

        ChunkMemoryPoolOffset chunkMemoryBlock;
        chunkMemoryBlock.mem_offset_ = blockOffset;
        chunkMemoryBlock.mem_size_ = blockSize;
        chunkMemoryBlock.position_ = pos;

        memory_pool_.AllocateSpace(blockOffset, blockSize);

        //Send Vertices Data into GPU
        buffer_.InsertData(blockOffset, blockSize, vertices.data());

        //Store Memory Offset
        chunk_memory_offsets_[pos] = chunkMemoryBlock;
        memory_chunk_offsets_[blockOffset] = pos;

        statistics_.memory_usage_ += blockSize;
        Update();
        return chunkMemoryBlock;
    }

    ChunkMemoryPoolOffset GetChunkMemoryPoolOffset(ChunkPos pos) const {
        const auto& it = chunk_memory_offsets_.find(pos);
        if (it != chunk_memory_offsets_.end()) {
            return it->second;
        }    
        return ChunkMemoryPoolOffset{ ULLONG_MAX, ULLONG_MAX, pos };
    }

    bool CheckChunk(ChunkPos pos) const {
        return chunk_memory_offsets_.count(pos);
    }

    ChunkMemoryPoolOffset AddChunkStaggingBuffer(ChunkPos pos, uint64_t blockOffset, uint64_t blockSize) { //assumes vertices.size() != 0
        ChunkMemoryPoolOffset chunkMemoryBlock;
        chunkMemoryBlock.mem_offset_ = blockOffset;
        chunkMemoryBlock.mem_size_ = blockSize;
        chunkMemoryBlock.position_ = pos;

        memory_pool_.AllocateSpace(blockOffset, blockSize);

        buffer_.CopyFrom(stagging_buffer_, 0, blockOffset, blockSize);

        chunk_memory_offsets_[pos] = chunkMemoryBlock;
        memory_chunk_offsets_[blockOffset] = pos;

        statistics_.memory_usage_ += blockSize;
        Update();
        return chunkMemoryBlock;
    }

    void Update() {
        if (memory_pool_.reserved_memory_blocks_.size() == 0) {
            return;
        }

        statistics_.full_memory_usage_ = memory_pool_.reserved_memory_blocks_.rbegin()->first +
            memory_pool_.reserved_memory_blocks_.rbegin()->second.size_;

        if (statistics_.full_memory_usage_ != 0) {
            statistics_.fragmentation_rate_ = (double)statistics_.memory_usage_ / (double)statistics_.full_memory_usage_;
        }
    }

    MemoryManagement::MemoryPoolStatistics statistics_;
    BufferStorage stagging_buffer_; 
    BufferStorage buffer_;

    MemoryManagement::MemoryPoolManager memory_pool_;
    FastHashMap<ChunkPos, ChunkMemoryPoolOffset> chunk_memory_offsets_;
    FastHashMap<size_t, ChunkPos> memory_chunk_offsets_;

    size_t memory_pool_size_ = 0;

};
"./RenderEngine\\ChunkRenderer\\Mesh\\ChunkMeshingV2.cpp"
#include "ChunkMeshingV2.h"
#include "../../BlockModel/BlockModels.h"
#include "../../../Level/Chunk/Chunk.h"
#include "../../../Level/Chunk/Block/Blocks.h"
#include <cstdint>

constexpr int POSITION_OFFSET = 16;

constexpr int BitShiftAmount = 9; //27 bits
constexpr int NormBitOffset = 27; //2 bits
constexpr int tintBitOffset = 29; // 1 bit

constexpr int textureBitOffset = 10; // 18 bits
constexpr int blockShadingBitOffset = 28; // 4 bits
#define PROFILE_DEBUG

void Mesh::ChunkMeshData::Reset() {
    if (vertices_buffer_.size() != BUFFER_SIZE_STEP) {
        vertices_buffer_.resize(BUFFER_SIZE_STEP, 0);
    }

    if (transparent_vertices_buffer_.size() != BUFFER_SIZE_STEP) {
        transparent_vertices_buffer_.resize(BUFFER_SIZE_STEP, 0);
    }

    transparent_face_count_ = 0;
    solid_face_count_ = 0;

    memset(chunk_cache_, NULL, 18 * 18 * 18 * sizeof(BlockID));
}

void Mesh::ChunkMeshData::GenerateCache() {
    int pos[3]{ 0, 0, 0 };
    int localPos[3]{ 0, 0, 0 };

    for (int x = 0; x < 16; x++) {
        for (int z = 0; z < 16; z++) {
            for (int y = 0; y < 16; ++y) {
                SetCachedBlockID(chunk_->GetBlockUnsafe(x, y, z), x, y, z);
            }
        }
    }

    for (int side = 0; side < 6; side++) {
        int axis = side >> 1;
        int direction = side & 0b1;

        if (chunk_->neighbors_[side] == nullptr) {
            continue;
        }

        for (int u = 0; u < 16; u++) {
            for (int v = 0; v < 16; v++) {

                pos[axis] = direction * 15;
                pos[(axis + 1) % 3] = u;
                pos[(axis + 2) % 3] = v;
                
                localPos[axis] = 17 - 17 * direction;
                localPos[(axis + 1) % 3] = u + 1;
                localPos[(axis + 2) % 3] = v + 1;

                chunk_cache_[localPos[0] * 18 * 18 + localPos[2] * 18 + localPos[1]] = chunk_->neighbors_[side]->GetBlockUnsafe(pos[0], pos[1], pos[2]);
            }
        }
    }
}

void Mesh::ChunkMeshData::SetChunk(Chunk* pChunk) {
    chunk_ = pChunk;
}

void Mesh::ChunkMeshData::GenerateMesh() {
    //Initialize
    if (chunk_ == nullptr) {
        return;
    }

    chunk_->Use();
    GenerateCache();
    chunk_->Unuse();
    
    GenerateFaceCollection();
}

//Loops through all the blocks in the chunk and check if each block side is visible. If a block side is visible, it generates the quad and puts it in the cache
void Mesh::ChunkMeshData::GenerateFaceCollection() {
    std::vector<uint8_t> faceVisibilityBack(4096, 0b00);
    std::vector<uint8_t> faceVisibility(4096, 0b00);
    std::vector<uint8_t> usedBlock(16 * 16, 0b00);

    for (int axis = 0; axis < 3; axis++) {
        int axisU = (axis + 2) % 3;
        int axisV = (axis + 1) % 3;
        int pos[3]{ 0,0,0 };

        for (pos[axis] = 0; pos[axis] < 17; ++pos[axis]) {//Slice
            memset(usedBlock.data(), 0x00, 16 * 16);
            for (pos[axisU] = 0; pos[axisU] < 16; ++pos[axisU]) {
                for (pos[axisV] = 0; pos[axisV] < 16; ++pos[axisV]) {

                    if (usedBlock[(pos[axisU] << 4) + pos[axisV]] != 0x00) {
                        pos[axisV] += usedBlock[(pos[axisU] << 4) + pos[axisV]] - 1; 
                        continue;
                    }

                    usedBlock[(pos[axisU] << 4) + pos[axisV]] = 0xFF;

                    const BlockID& currBlock = GetCachedBlockID(pos[0], pos[1], pos[2]);
                    --pos[axis];
                    const BlockID& backBlock = GetCachedBlockID(pos[0], pos[1], pos[2]);
                    ++pos[axis];

                    const Model::BlockModel& currModel = g_blocks.GetBlockModelDereferenced(currBlock);
                    const Model::BlockModel& backModel = g_blocks.GetBlockModelDereferenced(backBlock);

                    bool blankCurrModel = !currModel.is_initialized_ || pos[axis] == 16;
                    bool blankBackModel = !backModel.is_initialized_ || pos[axis] == 0;

                    //Check if it is visible from the back and front
                    if (!blankCurrModel) {
                        for (int i = 0; i < currModel.elements_.size(); ++i) {
                            faceVisibility[i] = 0;
                            const Cuboid& element = currModel.elements_[i];

                            if (element.faces_[axis * 2 + 1].reference_texture_.length() == 0)
                                continue;

                            if (element.faces_[axis * 2 + 1].cull_face_ != -1) {
                                if (!IsFaceVisible(element, pos[0], pos[1], pos[2], element.faces_[axis * 2 + 1].cull_face_)) continue;
                            }

                            faceVisibility[i] |= 0b1;
                        }

                    }
                    //Check if it is visible from the back and front
                    --pos[axis];
                    if (!blankBackModel) {
                        for (int i = 0; i < backModel.elements_.size(); ++i) {
                            faceVisibilityBack[i] = 0;
                            const Cuboid& element = backModel.elements_[i];

                            if (element.faces_[axis * 2].reference_texture_.length() == 0)
                                continue;

                            if (element.faces_[axis * 2].cull_face_ != -1) {
                                if (!IsFaceVisible(element, pos[0], pos[1], pos[2], element.faces_[axis * 2].cull_face_)) continue;
                            }

                            faceVisibilityBack[i] |= 0b1;
                        }
                    }
                    ++pos[axis];

                    //Spread

                    int uLength = 1;
                    int vLength = 1;

                    int qPos[3]{ pos[0], pos[1], pos[2] };

                    for (qPos[axisV] = pos[axisV] + 1; qPos[axisV] < 16; ++qPos[axisV]) {
                        //Check if they are the same
                        const BlockID& currBlock2 = GetCachedBlockID(qPos[0], qPos[1], qPos[2]);
                        --qPos[axis];
                        const BlockID& backBlock2 = GetCachedBlockID(qPos[0], qPos[1], qPos[2]);
                        ++qPos[axis];

                        if (currBlock2 != currBlock || backBlock2 != backBlock)
                            break;

                        usedBlock[(qPos[axisU] << 4) + qPos[axisV]] = 0xFFU;
                        vLength++;
                    }

                    //memset(usedBlock.data() + (pos[axisU] << 4) + pos[axisV], vLength, vLength);

                    qPos[0] = pos[0];
                    qPos[1] = pos[1];
                    qPos[2] = pos[2];

                    for (qPos[axisU] = pos[axisU] + 1; qPos[axisU] < 16; ++qPos[axisU]) {
                        bool isValid = true;

                        for (qPos[axisV] = pos[axisV]; qPos[axisV] < pos[axisV] + vLength; ++qPos[axisV]) {
                            const BlockID& currBlock2 = GetCachedBlockID(qPos[0], qPos[1], qPos[2]);
                            --qPos[axis];
                            const BlockID& backBlock2 = GetCachedBlockID(qPos[0], qPos[1], qPos[2]);
                            ++qPos[axis];

                            if (currBlock2 != currBlock || backBlock2 != backBlock) {
                                isValid = false;
                                break;
                            }
                        }

                        if (!isValid) {
                            break;
                        }

                        memset(usedBlock.data() + (static_cast<long long>(qPos[axisU]) << 4) + pos[axisV], vLength, vLength);

                        ++uLength;
                    }

                    qPos[0] = pos[0];
                    qPos[1] = pos[1];
                    qPos[2] = pos[2];

                    //Memorize & Add Faces

                    // TODO: Add some AO Checks and Greedy Meshing here

                    /*
                    * Center wont have AO check as it is no sides
                    * Do lighting checks when combining faces
                    */
                    if (!blankCurrModel) {
                        for (int i = 0; i < currModel.elements_.size(); i++) {
                            if (faceVisibility[i] != 1) continue;
                            const Cuboid& element = currModel.elements_[i];
                            for (qPos[axisU] = pos[axisU]; qPos[axisU] < pos[axisU] + uLength; ++qPos[axisU]) {
                                for (qPos[axisV] = pos[axisV]; qPos[axisV] < pos[axisV] + vLength; ++qPos[axisV]) {
                                    AddFacetoMesh(element.faces_[axis * 2 + 1], axis * 2 + 1, element.from_, element.to_, currModel.ambient_occlusion_, qPos[0], qPos[1], qPos[2]);
                                }
                            }
                        }
                    }
                    --qPos[axis];
                    if (!blankBackModel) {
                        for (int i = 0; i < backModel.elements_.size(); i++) {
                            if (faceVisibilityBack[i] != 1) continue;
                            const Cuboid& element = backModel.elements_[i];
                            for (qPos[axisU] = pos[axisU]; qPos[axisU] < pos[axisU] + uLength; ++qPos[axisU]) {
                                for (qPos[axisV] = pos[axisV]; qPos[axisV] < pos[axisV] + vLength; ++qPos[axisV]) {
                                    AddFacetoMesh(element.faces_[axis * 2], axis * 2, element.from_, element.to_, backModel.ambient_occlusion_, qPos[0], qPos[1], qPos[2]);
                                }
                            }
                        }
                    }

                    qPos[0] = pos[0];
                    qPos[1] = pos[1];
                    qPos[2] = pos[2];

                    if (vLength == 16 && uLength == 16) { //Skip entire layer
                        pos[axisV] = 15;
                        pos[axisU] = 15;
                    }
                    else {
                        pos[axisV] += vLength - 1;
                    }
                }
            }
        }
    }
}

inline void Mesh::ChunkMeshData::AddFacetoMesh(const BlockFace& face, uint8_t axis_, glm::ivec3 from_, glm::ivec3 to_, bool allowAO, int x, int y, int z) {
    uint8_t NN = 15, PN = 15, PP = 15, NP = 15;
    uint8_t direction = axis_ & 0b1;
    uint8_t facing = axis_ >> 1;

    x *= 16;
    y *= 16;
    z *= 16;

    glm::ivec3 P0{ x + from_[0] + POSITION_OFFSET, y + from_[1] + POSITION_OFFSET, z + from_[2] + POSITION_OFFSET };
    glm::ivec3 P1{ x + to_[0] + POSITION_OFFSET, y + to_[1] + POSITION_OFFSET, z + to_[2] + POSITION_OFFSET };

    glm::ivec2 texNN = face.uv_coord_nn;
    glm::ivec2 texPN = face.uv_coord_np;
    glm::ivec2 texPP = face.uv_coord_pp;
    glm::ivec2 texNP = face.uv_coord_pn;

    texNN.y <<= 5;
    texNP.y <<= 5;
    texPP.y <<= 5;
    texPN.y <<= 5;

    P0.x <<= 0;
    P1.x <<= 0;
    P0.y <<= BitShiftAmount;
    P1.y <<= BitShiftAmount;
    P0.z <<= BitShiftAmount * 2;
    P1.z <<= BitShiftAmount * 2;

    glm::ivec3 tP0 = P0;
    glm::ivec3 tP1 = P1;

    P0.x = tP0[facing % 3];
    P1.x = tP1[facing % 3];
    P0.y = tP0[(facing + 1) % 3];
    P1.y = tP1[(facing + 1) % 3];
    P0.z = tP0[(facing + 2) % 3];
    P1.z = tP1[(facing + 2) % 3];

    if (direction == 0)
        std::swap(P0.x, P1.x);
    if (facing == 2)
        std::swap(texPN, texNP);

    uint32_t tex = face.texture_id_ << textureBitOffset;
    uint32_t norm = facing << NormBitOffset;
    uint32_t tint = (static_cast<uint32_t>(!!face.tint_index_)) << tintBitOffset;

    std::vector<uint32_t>& out = face.has_transparency_ ? transparent_vertices_buffer_ : vertices_buffer_;

    uint64_t currIndex = face.has_transparency_ ? transparent_face_count_++ : solid_face_count_++;

    if (out.size() <= (currIndex + 1) * 12)
        out.resize(out.size() + BUFFER_SIZE_STEP);

    //Get AO
    glm::u8vec4 AO = allowAO ? getAO(axis_, x / 16, y / 16, z / 16) : glm::u8vec4{ 15, 15, 15, 15 };
   
    PP = AO[0], PN = AO[1], NP = AO[2], NN = AO[3];

    out[currIndex * 12 + 0]  = 0u | P0[0] | P0[1] | P0[2] | norm | tint;
    out[currIndex * 12 + 1]  = 0u | texNN.x | texNN.y | tex | (NN << blockShadingBitOffset);
    out[currIndex * 12 + 2]  = 0u | P0[0] | P1[1] | P0[2] | norm | tint;
    out[currIndex * 12 + 3]  = 0u | texPN.x | texPN.y | tex | (PN << blockShadingBitOffset);
    out[currIndex * 12 + 4]  = 0u | P0[0] | P0[1] | P1[2] | norm | tint;
    out[currIndex * 12 + 5]  = 0u | texNP.x | texNP.y | tex | (NP << blockShadingBitOffset);
    out[currIndex * 12 + 6]  = 0u | P0[0] | P0[1] | P1[2] | norm | tint;
    out[currIndex * 12 + 7]  = 0u | texNP.x | texNP.y | tex | (NP << blockShadingBitOffset);
    out[currIndex * 12 + 8]  = 0u | P0[0] | P1[1] | P0[2] | norm | tint;
    out[currIndex * 12 + 9]  = 0u | texPN.x | texPN.y | tex | (PN << blockShadingBitOffset);
    out[currIndex * 12 + 10] = 0u | P0[0] | P1[1] | P1[2] | norm | tint;
    out[currIndex * 12 + 11] = 0u | texPP.x | texPP.y | tex | (PP << blockShadingBitOffset);

    if (direction == 0) {
        std::swap(out[currIndex * 12 + 2], out[currIndex * 12 + 4]);
        std::swap(out[currIndex * 12 + 3], out[currIndex * 12 + 5]);

        std::swap(out[currIndex * 12 + 8], out[currIndex * 12 + 10]);
        std::swap(out[currIndex * 12 + 9], out[currIndex * 12 + 11]);
    }
}

inline const BlockID& Mesh::ChunkMeshData::GetCachedBlockID(int x, int y, int z) const {
    return chunk_cache_[(x + 1) * 18 * 18 + (z + 1) * 18 + (y + 1)];
}

inline const BlockID& Mesh::ChunkMeshData::GetCachedBlockID(int* pos) const {
    return GetCachedBlockID(pos[0], pos[1], pos[2]);
}

inline void Mesh::ChunkMeshData::SetCachedBlockID(BlockID b, int x, int y, int z) {
    chunk_cache_[(x + 1) * 18 * 18 + (z + 1) * 18 + (y + 1)] = b;
}

inline glm::u8vec4 Mesh::ChunkMeshData::getAO(uint8_t direction, int x, int y, int z) {
    const uint8_t AMBIENT_OCCLUSION_STRENGTH = 2;
    glm::ivec3 pos{x, y, z};

    char InitialLighting = chunk_->lighting_->GetLighting(x, y, z);

    uint8_t PP{ 15 }, PN{ 15 }, NP{ 15 }, NN{ 15 };

    uint8_t axis_ = direction >> 1;
    uint8_t facing = direction & 0b1;

    pos[axis_] += 1 - 2 * facing;

    //Check up down left right

    int axis1 = (axis_ + 1) % 3;
    int axis2 = (axis_ + 2) % 3;

    //Check up
    pos[axis1] += 1;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR) {
        PP -= AMBIENT_OCCLUSION_STRENGTH;
        PN -= AMBIENT_OCCLUSION_STRENGTH;
    }

    pos[axis1] -= 2;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR) {
        NP -= AMBIENT_OCCLUSION_STRENGTH;
        NN -= AMBIENT_OCCLUSION_STRENGTH;
    }

    pos[axis1] += 1;
    pos[axis2] += 1;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR) {
        NP -= AMBIENT_OCCLUSION_STRENGTH;
        PP -= AMBIENT_OCCLUSION_STRENGTH;
    }

    pos[axis2] -= 2;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR) {
        PN -= AMBIENT_OCCLUSION_STRENGTH;
        NN -= AMBIENT_OCCLUSION_STRENGTH;
    }

    pos[axis2] += 1;


    //Check corners now
    pos[axis1] += 1;
    pos[axis2] += 1;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR)
        PP -= AMBIENT_OCCLUSION_STRENGTH;

    pos[axis1] -= 2;
    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR)
        NP -= AMBIENT_OCCLUSION_STRENGTH;

    pos[axis2] -= 2;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR)
        NN -= AMBIENT_OCCLUSION_STRENGTH;

    pos[axis1] += 2;

    if (GetCachedBlockID(pos.x, pos.y, pos.z) != g_blocks.AIR)
        PN -= AMBIENT_OCCLUSION_STRENGTH;


    if (PP >= (15 - InitialLighting))
        PP = PP - (15 - InitialLighting);
    else
        PP = 0;

    if (PN >= (15 - InitialLighting))
        PN = PN - (15 - InitialLighting);
    else
        PN = 0;

    if (NN >= (15 - InitialLighting))
        NN = NN - (15 - InitialLighting);
    else
        NN = 0;

    if (NP >= (15 - InitialLighting))
        NP = NP - (15 - InitialLighting);
    else
        NP = 0;

    return glm::u8vec4(PP, PN, NP, NN);

}

//Checks if a block side is visible to the player
inline bool Mesh::ChunkMeshData::IsFaceVisible(const Cuboid& cube, int x, int y, int z, uint8_t side) {
    const uint8_t axis_ = (side >> 1); //Get side
    const uint8_t axis1 = (axis_ + 1) % 3;
    const uint8_t axis2 = (axis_ + 2) % 3;
    const uint8_t oppositeSide = axis_ * 2 + static_cast<uint8_t>(!(side & 0b1));

    int p[3]{ x, y, z };

    p[axis_] += 1 - 2 * (side & 0b1);
//    return getCachedBlockID(p[0], p[1], p[2]) == Blocks.AIR;

    const Model::BlockModel& model = g_blocks.GetBlockModelDereferenced(GetCachedBlockID(p[0], p[1], p[2]));

    if (!model.is_initialized_) return true;

    for (int i = 0; i < model.elements_.size(); ++i) {
        const Cuboid& element = model.elements_[i];
        if (element.faces_[oppositeSide].cull_face_ != oppositeSide ||
            element.faces_[oppositeSide].is_see_through_ ||
            element.faces_[oppositeSide].has_transparency_ ||
            element.faces_[oppositeSide].reference_texture_.empty())
            continue; 

        if (side & 1) //if the  block arent touching
            if (element.to_[axis_] < 16) continue;
        else
            if (element.from_[axis_] > 0) continue;
        
        //Check if the faces aren't overlapping

        if (element.from_[axis1] <= cube.from_[axis1] && element.to_[axis1] >= cube.to_[axis1] &&
            element.from_[axis2] <= cube.from_[axis2] && element.to_[axis2] >= cube.to_[axis2])
            return false;

    }
    return true;
}

inline bool Mesh::ChunkMeshData::IsFaceVisibleUnsafe(const Cuboid& cube, int x, int y, int z, uint8_t side) {
    uint8_t axis_ = (side >> 1); //Get side

    int p[3]{ x,y,z };

    p[axis_] += 1 - 2 * (side & 0b1);

    return g_blocks.GetBlockType(GetCachedBlockID(p[0], p[1], p[2]))->properties_->transparency_;
}

inline bool Mesh::ChunkMeshData::CompareBlockSide(int x, int y, int z, uint8_t side, BlockID b) {
    //IsFaceVisibleCalls++;

    uint8_t axis_ = (side >> 1); //Get side

    int p[3]{ x,y,z };

    p[axis_] += 1 - 2 * (side & 0b1);

    return GetCachedBlockID(p[0], p[1], p[2]) == b;
}

inline bool Mesh::ChunkMeshData::CompareBlockSideUnsafe(int x, int y, int z, uint8_t side, BlockID b) {
    uint8_t axis_ = (side >> 1); //Get side

    int p[3]{ x,y,z };

    p[axis_] += 1 - 2 * (side & 0b1);

    return GetCachedBlockID(p[0], p[1], p[2]) == b;
}
"./RenderEngine\\ChunkRenderer\\Mesh\\ChunkMeshingV2.h"
#pragma once
#include <vector>
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
#include <glm/ext.hpp>

#include "../../../Level/Typenames.h"

class Chunk;

struct Cuboid;
struct BlockFace;

namespace Mesh {
    struct CompactBooleanData {

        void InsertBit(size_t index) {
            size_t NumIndex = index >> 6;
            size_t Index = index & 0b111111;

            data[NumIndex] |= (0b1LL << Index);

        }

        bool Getbit(size_t index) const {
            size_t NumIndex = index >> 6;
            size_t Index = index & 0b111111;
            return (data[NumIndex] >> Index) & 0b1;
        }

        void InsertBitPos(uint16_t x, uint16_t y, uint16_t z) {
            InsertBit((x << 8) + (y << 4) + z);
        }

        bool GetBitPos(uint16_t x, uint16_t y, uint16_t z) const {
            return Getbit((x << 8) + (y << 4) + z);
        }

        void clear() {
            for (int i = 0; i < 64; i++) {
                data[i] = 0;
            }
        }

        uint64_t data[4 * 16]{};
    };

    struct ChunkVertexData {
        ChunkVertexData() {

        }

        ~ChunkVertexData() {
            solidVertices.clear();
            transparentVertices.clear();
        }

        std::vector<uint32_t> solidVertices;
        std::vector<uint32_t> transparentVertices;
        ChunkPos position_;
        size_t time_;
    };


    class ChunkMeshData {
    public:
        ChunkMeshData() {

        }

        void SetChunk(Chunk* pChunk);

        void Reset();

        //Mesh Vertices
        std::vector<unsigned int> vertices_buffer_;
        std::vector<unsigned int> transparent_vertices_buffer_;

        uint64_t transparent_face_count_ = 0;
        uint64_t solid_face_count_ = 0;

        //Generate the Mesh
        void GenerateMesh();

        void GenerateCache();

    private:
        

        //Generates all the faces and puts them in the cache
        void GenerateFaceCollection();

        //Check if the player can see the mesh
        inline bool IsFaceVisible(const Cuboid& cube, int x, int y, int z, uint8_t side);
        inline bool IsFaceVisibleUnsafe(const Cuboid& cube, int x, int y, int z, uint8_t side);

        inline bool CompareBlockSide(int x, int y, int z, uint8_t side, BlockID b);
        inline bool CompareBlockSideUnsafe(int x, int y, int z, uint8_t side, BlockID b);

        //Add faces to the mesh
        inline void AddFacetoMesh(const BlockFace& face, uint8_t axis_, glm::ivec3 from_, glm::ivec3 to_, bool allowAO, int x, int y, int z);

        inline const BlockID& GetCachedBlockID(int x, int y, int z) const;
        inline const BlockID& GetCachedBlockID(int* pos) const;
        inline void SetCachedBlockID(BlockID b, int x, int y, int z);


        inline glm::u8vec4 getAO(uint8_t direction, int x, int y, int z);

        //To check if a block had been used in the Greedy Meshing Algorithm
        CompactBooleanData boolean_map_;

        const uint64_t BUFFER_SIZE_STEP = 262144;

        Chunk* chunk_;

        BlockID chunk_cache_[18 * 18 * 18 * 3]{NULL}; // Use multiple copies of chunk in different ordering to optimize cache hits
    };
}
"./RenderEngine\\ChunkRenderer\\Occulsion\\Data\\OcculsionData.h"
#pragma once
#include "../../../../Level/Chunk/Chunk.h"


class ChunkOcculsionData {
public:
    bool IsVisible(unsigned char c) {
        
    }

    void AnalysisChunk(Chunk* chunk) {
        
    }

private:

 };
"./RenderEngine\\ChunkRenderer\\Occulsion\\Data\\OcculsionDataManager.h"
#pragma once
"./RenderEngine\\ChunkRenderer\\Occulsion\\Graph\\Graph.h"
#pragma once

#include <list>

template <class T>
struct Node {
    T* vertex_;
    Node* edge_;
};

template <class T> 
class Graph {

private:
    std::list<Node> nodes_;
public:

    void InsertVertex(T* vertex) {

    }

    void InsertEdge(T* vertex0, T* vertex1) {

    }

    void DeleteEdge() {

    }

    void DeleteVertex(T* vertex) {

    }


};
"./RenderEngine\\ChunkRenderer\\TerrainRenderer.cpp"
#include "TerrainRenderer.h"


#include "../Frustum/frustum.h"
#include "../OpenGL/Texture/Texture.h"
#include "../OpenGL/Texture/Types/TextureAtlas.h"
#include "../OpenGL/Buffers/Buffer.h"
#include "../../Utils/MathHelper.h"

#include <unordered_map>
#include <deque>
#include <queue>


void TerrainRenderer::Initialize(GLFWwindow* window, Camera* camera) {
    window_ = window;
    camera_ = camera;
    SetupShaders();
    LoadAssets();

    time_.Set();

    CreateNewSolidBatch();
    CreateNewTransparentBatch();
}

void TerrainRenderer::PrepareRenderer() {
    for (ChunkDrawBatch& DrawBatch : chunk_solid_batches_) {
        DrawBatch.GenDrawCommands(horizontal_render_distance_, vertical_render_distance_);
    }

    for (ChunkDrawBatch& DrawBatch : chunk_transparent_batches_) {
        DrawBatch.GenDrawCommands(horizontal_render_distance_, vertical_render_distance_);
    }
}

void TerrainRenderer::SetupCallSolid() {
    glDisable(GL_BLEND);
    glEnable(GL_DEPTH_TEST);
    glDepthMask(GL_TRUE);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);
    glFrontFace(GL_CCW);
}

void TerrainRenderer::SetupCallTransparent() {
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(GL_FALSE);
    glDisable(GL_CULL_FACE);
}

void TerrainRenderer::RenderSky() {
    glClearColor(0.46274509803f, 0.65882352941f, 1.0f, 1.0);
}

void TerrainRenderer::Render() {
    
    LoadAssets();

    SetupCallSolid();

    for (ChunkDrawBatch& DrawBatch : chunk_solid_batches_) {
        DrawBatch.Bind();
        cubic_shader_.Use();
        DrawBatch.Draw();
        DrawBatch.Unbind();
    }

    SetupCallTransparent();

    for (ChunkDrawBatch& DrawBatch : chunk_transparent_batches_) {
        DrawBatch.Bind();
        cubic_shader_.Use();
        DrawBatch.Draw();
        DrawBatch.Unbind();
    }

    
    glDepthMask(GL_TRUE);
    glDepthFunc(GL_LESS);
}

void TerrainRenderer::Defrag(int iterations) {
    for (auto& DrawBatch : chunk_solid_batches_) {
        DrawBatch.Defrager(iterations);
    }

    for (auto& DrawBatch : chunk_solid_batches_) {
        DrawBatch.Defrager(iterations);
    }
}


void TerrainRenderer::Update() {
    int width, height;

    glfwGetWindowSize(window_, &width, &height);
    glm::mat4 model = glm::mat4(1.f);

    camera_->screen_res_ = glm::vec2(width, height);

    glm::mat4 view = camera_->GetViewMatrix();

    int x = width;
    int y = height;
    glm::mat4 projection = glm::perspective(glm::radians(camera_->fov_), (float)x / (float)y, 0.1f, 1000000.0f);
    cubic_shader_.Use();

    float clrMultiplier = 1.4f;

    cubic_shader_.SetMat4("view", view);
    cubic_shader_.SetMat4("model", model);
    cubic_shader_.SetMat4("projection", projection);
    cubic_shader_.SetFloat("RenderDistance", (float)(horizontal_render_distance_ * 16));
    cubic_shader_.SetFloat("VerticalRenderDistance", (float)(vertical_render_distance_ * 16));
    cubic_shader_.SetVec3("camPos", camera_->position_);
    cubic_shader_.SetVec3("tintColor",  glm::vec3(0.40828402 * clrMultiplier, 0.5917159 * clrMultiplier, 0.2781065 * clrMultiplier));
    cubic_shader_.SetInt("TextureAimIndex", TextureAminationIndex);

    if (time_.GetTimePassed_ms() > 100) {
        time_.Set();
        TextureAminationIndex++;

        if (TextureAminationIndex == (1 << 15)) {
            TextureAminationIndex = 0;
        }
    }
}

void TerrainRenderer::setSettings(uint32_t renderDistance, uint32_t verticalRenderDistance, float fov) {
    horizontal_render_distance_ = renderDistance;
    vertical_render_distance_ = verticalRenderDistance;
    fov_ = fov;
}

void TerrainRenderer::LoadAssets() {
    cubic_shader_.BindTexture2D(0, g_blocks.block_texture_atlas_->get(), "BlockTexture");
}

void TerrainRenderer::AddChunk(const ChunkPos& pos, const std::vector<uint32_t>& data, std::vector<ChunkDrawBatch>& batchType, FastHashMap<ChunkPos, int>& lookUpMap) {
    if (lookUpMap.count(pos)) {
        size_t BatchIndex = lookUpMap[pos];
        batchType[BatchIndex].DeleteChunkVertices(pos);
        lookUpMap.erase(pos);
    }

    if (data.size() == 0)
        return;

    bool success = false;

    for (int batchIndex = 0; batchIndex < batchType.size(); batchIndex++) {
        size_t meshDataSize = data.size() * sizeof(uint32_t);

        if (batchType[batchIndex].memory_pool_.memory_pool_.FindFreeSpace(meshDataSize) == ULLONG_MAX)
            continue;

        bool InsertSuccess = batchType[batchIndex].AddChunkVertices(data, pos);

        if (!InsertSuccess) continue;

        lookUpMap.emplace(pos, batchIndex);
        success = true;
        break;
    }

    if (!success) {
        g_logger.LogInfo("TerrainRenderer::AddChunk", "Unable to add chunk. Solid buffers are full!");
    }
}

void TerrainRenderer::AddChunk(std::unique_ptr<Mesh::ChunkVertexData> MeshData) {
    AddChunk(MeshData->position_, MeshData->solidVertices, chunk_solid_batches_, chunk_batch_solid_lookup_);
    AddChunk(MeshData->position_, MeshData->transparentVertices, chunk_transparent_batches_, chunk_batch_transparent_lookup_);
}


double TerrainRenderer::getDebugTime() {
    double t = 0.0;

    for (int batchIndex = 0; batchIndex < chunk_solid_batches_.size(); batchIndex++) {
        t += chunk_solid_batches_[batchIndex].debug_time_;
    }

    return t;
}

double TerrainRenderer::getFragmentationRate() {
    size_t n = chunk_solid_batches_.size();

    double fragRate = 0;

    for (size_t batchIndex = 0; batchIndex < n; batchIndex++) {

        const auto& batch = chunk_solid_batches_[batchIndex];

        if (batch.render_list_.size() != 0) {
            fragRate += (batch.memory_pool_.statistics_.fragmentation_rate_ / (double)n);
        }
    }

    return 1.0 - fragRate;
}

size_t TerrainRenderer::getVRAMUsageFull() {
    size_t memUsage = 0;

    for (int batchIndex = 0; batchIndex < chunk_solid_batches_.size(); batchIndex++) {

        if (chunk_solid_batches_[batchIndex].render_list_.size() == 0) {
            continue;
        }

        memUsage += chunk_solid_batches_[batchIndex].memory_pool_.statistics_.full_memory_usage_;
    }

    return memUsage;
}

void TerrainRenderer::Cleanup() {
    for (ChunkDrawBatch& batch : chunk_solid_batches_) {
        batch.Cleanup();
    }

    for (ChunkDrawBatch& batch : chunk_transparent_batches_) {
        batch.Cleanup();
    }

    chunk_solid_batches_.clear();
    chunk_batch_solid_lookup_.clear();

    chunk_transparent_batches_.clear();
    chunk_batch_transparent_lookup_.clear();
}

void TerrainRenderer::SetupShaders() {
    cubic_shader_.Init("assets/shaders/vert.glsl", "assets/shaders/frag.glsl");
}

void TerrainRenderer::CreateNewSolidBatch() {
    chunk_solid_batches_.emplace_back();
    size_t i = chunk_solid_batches_.size() - 1;
    chunk_solid_batches_[i].SetMaxSize(g_app_options.solid_buffer_size_);
    chunk_solid_batches_[i].SetupBuffers();
    chunk_solid_batches_[i].camera = camera_;
}

void TerrainRenderer::CreateNewTransparentBatch() {
    chunk_transparent_batches_.emplace_back();
    size_t i = chunk_transparent_batches_.size() - 1;
    chunk_transparent_batches_[i].SetMaxSize(g_app_options.transparent_buffer_size_);
    chunk_transparent_batches_[i].SetupBuffers();
    chunk_transparent_batches_[i].camera = camera_;
}
"./RenderEngine\\ChunkRenderer\\TerrainRenderer.h"
#pragma once
#include  "Mesh/ChunkMeshingV2.h"
#include "../Camera/camera.h"
#include "Batch/ChunkBatch.h"
#include "../OpenGL/Shader/Shader.h"
#include "../../Core/Options/Option.h"
#include "../../Level/Timer/Timer.h"

#include <concurrent_vector.h>
#include <mutex>

class TerrainRenderer {
private:
    void AddChunk(const ChunkPos& pos, const std::vector<uint32_t>& data, std::vector<ChunkDrawBatch>& BatchType, FastHashMap<ChunkPos, int>& LookUpMap);

    void SetupShaders();

    void CreateNewSolidBatch();

    void CreateNewTransparentBatch();

    int horizontal_render_distance_ = 16;
    int vertical_render_distance_ = 16;
    float fov_ = 80.f;
    int TextureAminationIndex = 0;

    std::vector<ChunkDrawBatch> chunk_solid_batches_;
    FastHashMap<ChunkPos, int> chunk_batch_solid_lookup_; //f: ChunkPos -> SolidBatchIndex

    std::vector<ChunkDrawBatch> chunk_transparent_batches_;
    FastHashMap<ChunkPos, int> chunk_batch_transparent_lookup_; //f: ChunkPos -> TransparentBatchIndex

    GLFWwindow* window_ = nullptr;
    Shader cubic_shader_;
    Camera* camera_;
    Timer time_;
public:
    TerrainRenderer() : chunk_solid_batches_{ 0 },
        chunk_batch_solid_lookup_{ 0 },
        chunk_transparent_batches_{ 0 },
        chunk_batch_transparent_lookup_{ 0 },
        camera_{ nullptr } {

    }

    void Initialize(GLFWwindow* window_, Camera* camera_);

    void PrepareRenderer();

    void SetupCallSolid();

    void SetupCallTransparent();

    void RenderSky();

    void Render();

    void Defrag(int iterations);

    void Update();

    void setSettings(uint32_t RenderDistance, uint32_t verticalRenderDistance, float fov_);

    void LoadAssets();

    void AddChunk(std::unique_ptr<Mesh::ChunkVertexData> MeshData);

    double getDebugTime();

    double getFragmentationRate();

    size_t getVRAMUsageFull();

    void Cleanup();

    size_t amountOfMeshGenerated = 1;


};

"./RenderEngine\\EntityRenderer\\EntityRenderCache.cpp"
#include "EntityRenderCache.h"

void EntityRenderCache::AddEntity(EntityProperty& entity) {
    entity_container_[entity.entity_uuid_] = entity;
    entity_separated_[entity.type_][entity.entity_uuid_] = entity;
}

void EntityRenderCache::RemoveEntity(EntityUUID entityUUID) {
    EntityProperty e = entity_container_[entityUUID];

    entity_separated_[e.type_].erase(entityUUID);
    entity_container_.erase(entityUUID);
}

FastHashMap<EntityTypeID, FastHashMap<EntityUUID, EntityProperty>>& EntityRenderCache::GetEntitiesTypeSeparated() {
    return entity_separated_;
}
"./RenderEngine\\EntityRenderer\\EntityRenderCache.h"
#pragma once

#include "../../Level/Entity/Entity.h"
struct EntityRenderCache { // stores all entity to be rendered

    FastHashMap<EntityUUID, EntityProperty> entity_container_;

    FastHashMap<EntityTypeID, FastHashMap<EntityUUID, EntityProperty>> entity_separated_;

    void AddEntity(EntityProperty& entity);

    void RemoveEntity(EntityUUID entityUUID);

    FastHashMap<EntityTypeID, FastHashMap<EntityUUID, EntityProperty>>& GetEntitiesTypeSeparated();

};
"./RenderEngine\\EntityRenderer\\EntityRenderUpdate.cpp"
#include "EntityRenderUpdate.h"
#include "../../Utils/Clock.h"
#include "../../Level/Dimension/Dimension.h"

EntityRendererUpdater::EntityRendererUpdater() : stop_{ true }, dimension_{ nullptr } {

}

void EntityRendererUpdater::SetEntityRenderer(MultiEntityRenderer* render, Timer* time) {
    renderer_ = render;
    server_time_ = time;
}

void EntityRendererUpdater::UpdaterThread() {
    while (!stop_) {
        std::vector<EntityProperty> UpdatedEntities = dimension_->world_interactions_.GetUpdatedEntities();
        std::vector<EntityUUID> RemovedEntities = dimension_->world_interactions_.GetRemovedEntities();

        for (auto& entity : UpdatedEntities) {
            renderer_->AddEntity(entity);

        }
        for (auto& entity : RemovedEntities) {
            renderer_->RemoveEntity(entity);
        }
        
        
        timerSleep(0.05);
    }
}

void EntityRendererUpdater::Start(Dimension* dimension) {
    dimension_ = dimension;
    stop_ = false;
    update_thread_ = std::thread(&EntityRendererUpdater::UpdaterThread, this);
}

void EntityRendererUpdater::Stop() {
    stop_ = true;
    update_thread_.join();
}

"./RenderEngine\\EntityRenderer\\EntityRenderUpdate.h"
#pragma once
#include "MultiEntityRender.h"
#include "../../Level/Timer/Timer.h"
#include <thread>

class EntityRendererUpdater {
    MultiEntityRenderer* renderer_;
    Dimension* dimension_;

    bool stop_ = true;

    void UpdaterThread();

    std::thread update_thread_;

    Timer* server_time_;
public:
    EntityRendererUpdater();
    void SetEntityRenderer(MultiEntityRenderer* render, Timer* time);
    void Start(Dimension* dimension);
    void Stop();
};
"./RenderEngine\\EntityRenderer\\Models\\EntityModel.h"
#pragma once

#include <glm/vec3.hpp>
#include <glm/vec2.hpp>
#include <iostream>
#include <vector>

namespace Model {
    struct ModelData {
        std::vector<float> vertices_;
        std::vector<unsigned int> indices_;

        int vertices_count_ = 0;
    } ;

    struct UV {
        glm::vec2 p0_ = glm::vec2(0.f, 0.f);
        glm::vec2 p1_ = glm::vec2(0.f, 0.f);
    } ;

    struct RectangularPrism {

        RectangularPrism(float x, float y, float z) {
            size_.x = x;
            size_.y = y;
            size_.z = z;
        }

        RectangularPrism(glm::vec3 size, glm::vec3 offset) {
            size_ = size;
            offset_ = offset;
        }

        ModelData GetVertices();

        glm::vec3 offset_ = glm::vec3(0.f, 0.f, 0.f);

        glm::vec3 size_ = glm::vec3(0.f, 0.f, 0.f);

        UV uv_map_[6]{};
    };
}

class EntityModel {
public:

    Model::RectangularPrism* AddRectangle(glm::vec3 size, glm::vec3 offset) {
        shapes_.emplace_back(size, offset);
        return &shapes_.back();
    }

    Model::ModelData GetVertices() {

        Model::ModelData model;

        for (Model::RectangularPrism& shape : shapes_) {
            Model::ModelData SubModel = shape.GetVertices();

            size_t CurrentIndex = model.vertices_count_;

            for (size_t i = 0; i < SubModel.vertices_.size(); i++) {
                if ((i % 5) < 3) {
                    model.vertices_.push_back(SubModel.vertices_[i] + shape.offset_[i % 5]);
                }
                else {
                    model.vertices_.push_back(SubModel.vertices_[i]);
                }
                
            }

            for (size_t i = 0; i < SubModel.indices_.size(); i++) {
                model.indices_.push_back(static_cast<uint32_t>(SubModel.indices_[i] + CurrentIndex));
            }

            model.vertices_count_ += SubModel.vertices_count_;

        }

        return model;
    }

    void Clear() {
        shapes_.clear();
    }

private:
    std::vector<Model::RectangularPrism> shapes_;
};
"./RenderEngine\\EntityRenderer\\Models\\EntityModels.cpp"

#include "EntityModel.h"
#include <iostream>
#include "../../../Level/Typenames.h"

Model::ModelData Model::RectangularPrism::GetVertices() {
    ModelData model;

    model.vertices_.insert(model.vertices_.begin(), {
        //Front
        0.f,0.f,0.f,            // 0
        uv_map_[FRONT].p1_.x,uv_map_[FRONT].p0_.y,
        size_.x, 0.f,0.f,        // 1
        uv_map_[FRONT].p0_.x,uv_map_[FRONT].p0_.y,
        size_.x, size_.y, 0.f,    // 2
        uv_map_[FRONT].p0_.x,uv_map_[FRONT].p1_.y,
        0.f, size_.y, 0.f,        // 3
        uv_map_[FRONT].p1_.x,uv_map_[FRONT].p1_.y,

        //Back
        0.f,0.f,size_.z,            // 4
        uv_map_[BACK].p1_.x,uv_map_[BACK].p0_.y,
        size_.x, 0.f,size_.z,        // 5
        uv_map_[BACK].p0_.x,uv_map_[BACK].p0_.y,
        size_.x, size_.y, size_.z,    // 6
        uv_map_[BACK].p0_.x,uv_map_[BACK].p1_.y,
        0.f, size_.y, size_.z,    // 7
        uv_map_[BACK].p1_.x,uv_map_[BACK].p1_.y,

        //Right
        size_.x,0.f,0.f,            // 8
        uv_map_[RIGHT].p1_.x,uv_map_[RIGHT].p0_.y,
        size_.x,size_.y,0.f,        // 9
        uv_map_[RIGHT].p1_.x,uv_map_[RIGHT].p1_.y,
        size_.x,size_.y,size_.z,    // 10
        uv_map_[RIGHT].p0_.x,uv_map_[RIGHT].p1_.y,
        size_.x,0.f,size_.z,        // 11
        uv_map_[RIGHT].p0_.x,uv_map_[RIGHT].p0_.y,

        //Left
        0.f,0.f,0.f,            // 12
        uv_map_[LEFT].p1_.x,uv_map_[LEFT].p0_.y,
        0.f,size_.y,0.f,            // 13
        uv_map_[LEFT].p1_.x,uv_map_[LEFT].p1_.y,
        0.f,size_.y,size_.z,        // 14
        uv_map_[LEFT].p0_.x,uv_map_[LEFT].p1_.y,
        0.f,0.f,size_.z,            // 15
        uv_map_[LEFT].p0_.x,uv_map_[LEFT].p0_.y,

        //Top
        0.f,size_.y,0.f,            // 16
        uv_map_[TOP].p1_.x,uv_map_[TOP].p0_.y,
        size_.x,size_.y,0.f,        // 17
        uv_map_[TOP].p0_.x,uv_map_[TOP].p0_.y,
        size_.x,size_.y,size_.z,    // 18
        uv_map_[TOP].p0_.x,uv_map_[TOP].p1_.y,
        0.f,size_.y,size_.z,        // 19
        uv_map_[TOP].p1_.x,uv_map_[TOP].p1_.y,

        //Bottom
        0.f,0.f,0.f,            // 20
        uv_map_[BOTTOM].p1_.x,uv_map_[BOTTOM].p0_.y,
        size_.x,0.f,0.f,            // 21
        uv_map_[BOTTOM].p0_.x,uv_map_[BOTTOM].p0_.y,
        size_.x,0.f,size_.z,        // 22
        uv_map_[BOTTOM].p0_.x,uv_map_[BOTTOM].p1_.y,
        0.f,0.f,size_.z,            // 23
        uv_map_[BOTTOM].p1_.x,uv_map_[BOTTOM].p1_.y
        });


    model.indices_.insert(model.indices_.begin(), {
        //Front
        0,1,2,
        2,3,0,

        //Back
        4,6,5,
        6,4,7,

        //Right
        8,9,10,
        10,11,8,

        //Left
        12,14,13,
        14,12,15,

        //Top
        16,17,18,
        18,19,16,

        //Bottom
        20,22,21,
        22,20,23,
        });

    model.vertices_count_ = 24;

    return model;
}
"./RenderEngine\\EntityRenderer\\MultiEntityRender.cpp"
#include "MultiEntityRender.h"
#include "../Camera/camera.h"

size_t MultiEntityRenderer::GetNumEntityRendered() {
    return num_entity_rendered_;
}

void MultiEntityRenderer::AddEntity(EntityProperty& entity) {
    renderable_entities_.AddEntity(entity);
}

void MultiEntityRenderer::RemoveEntity(EntityUUID entityUUID) {
    renderable_entities_.RemoveEntity(entityUUID);
}

void MultiEntityRenderer::Clean() {
    vbo_.Delete();
    ebo_.Delete();
    ssbo_pos_.Delete();
    ssbo_vel_.Delete();
    ssbo_acc_.Delete();
    vao_.Delete();
}

void MultiEntityRenderer::Initialize(PerformanceProfiler* pProfilerIn) {
    for (int i = 0; i < g_entity_list.entity_type_list_.size(); i++) {
        EntityModel model = g_entity_list.entity_type_list_[i]->render_model_;
        entity_cached_models_[i] = model;
        profiler_ = pProfilerIn;

    }

    shader_.Init("assets/shaders/Entity/MultiEntityVert.glsl", "assets/shaders/Entity/MultiEntityFrag.glsl");
    camera_ = player_.GetCamera();

    //Initialize Buffers

    for (auto& EntityModels : entity_cached_models_) {
        Model::ModelData model = EntityModels.second.GetVertices();

        unsigned int ModelIndex = static_cast<unsigned int>(entity_vertices_.size() / 5);

        entity_element_index_[EntityModels.first] = entity_indices_.size(); //temp solution
        entity_element_size_[EntityModels.first] = model.indices_.size();

        for (int i = 0; i < model.indices_.size(); i++) {
            entity_indices_.emplace_back(ModelIndex + model.indices_[i]);
        }

        entity_vertices_.insert(entity_vertices_.end(), model.vertices_.begin(), model.vertices_.end());
    }


    vbo_.GenBuffer();
    ebo_.GenBuffer();
    ssbo_pos_.GenBuffer();
    ssbo_vel_.GenBuffer();
    ssbo_acc_.GenBuffer();
    vao_.GenArray();

    vao_.Bind();

    vbo_.SetType(GL_ARRAY_BUFFER);
    vbo_.SetUsage(GL_STATIC_DRAW);
    vbo_.InsertData(entity_vertices_.size() * sizeof(float), entity_vertices_.data(), GL_STATIC_DRAW);

    ebo_.SetUsage(GL_STATIC_DRAW);
    ebo_.SetType(GL_ELEMENT_ARRAY_BUFFER);
    ebo_.InsertData(entity_indices_.size() * sizeof(unsigned int), entity_indices_.data(), GL_STATIC_DRAW);

    ssbo_pos_.SetType(GL_SHADER_STORAGE_BUFFER);
    ssbo_pos_.SetUsage(GL_DYNAMIC_COPY);
    ssbo_pos_.SetMaxSize(3000000);
    ssbo_pos_.InitializeData();

    ssbo_vel_.SetType(GL_SHADER_STORAGE_BUFFER);
    ssbo_vel_.SetUsage(GL_DYNAMIC_COPY);
    ssbo_vel_.SetMaxSize(3000000);
    ssbo_vel_.InitializeData();

    ssbo_acc_.SetType(GL_SHADER_STORAGE_BUFFER);
    ssbo_acc_.SetUsage(GL_DYNAMIC_COPY);
    ssbo_acc_.SetMaxSize(3000000);
    ssbo_acc_.InitializeData();

    vbo_.Bind();
    vao_.EnableAttriPTR(0, 3, GL_FLOAT, GL_FALSE, 5, 0);
    vao_.EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 5, 3);
    vbo_.Unbind();
    vao_.Unbind();

    position_arr_.resize(3000000);
    velocity_arr_.resize(3000000);
    acceleration_arr_.resize(3000000);

}

void MultiEntityRenderer::SetTimePastTick(double t) {
    time_past_tick_ = t;
}

void MultiEntityRenderer::SetupCall() {
    glDisable(GL_BLEND);
    glEnable(GL_DEPTH_TEST);
    glDepthMask(GL_TRUE);
    glDisable(GL_CULL_FACE);
}

void MultiEntityRenderer::Render() {
    profiler_->ProfileStart("root/render/entity");
    SetupCall();

    size_t n = 0;

    for (auto& entityarr : renderable_entities_.entity_separated_) {
        //Fill SSBO POS data

        size_t i = 0;
        for (auto& e : entityarr.second) {
            EntityProperty properties = e.second;

            position_arr_[(i * 3 + 0)] = properties.position_.x;
            position_arr_[(i * 3 + 1)] = properties.position_.y;
            position_arr_[(i * 3 + 2)] = properties.position_.z;

            velocity_arr_[(i * 3 + 0)] = properties.velocity_.x;
            velocity_arr_[(i * 3 + 1)] = properties.velocity_.y;
            velocity_arr_[(i * 3 + 2)] = properties.velocity_.z;

            acceleration_arr_[(i * 3 + 0)] = properties.acceleration_.x;
            acceleration_arr_[(i * 3 + 1)] = properties.acceleration_.y;
            acceleration_arr_[(i * 3 + 2)] = properties.acceleration_.z;

            i++;
        }
        

        n += entityarr.second.size();

        ssbo_pos_.InsertSubData(0, (i * 3) * sizeof(float), position_arr_.data());
        ssbo_vel_.InsertSubData(0, (i * 3) * sizeof(float), velocity_arr_.data());
        ssbo_acc_.InsertSubData(0, (i * 3) * sizeof(float), acceleration_arr_.data());

        shader_.BindTexture2D(0, g_entity_list.entity_type_list_[entityarr.first]->texture_.get(), "EntityTexture");
        shader_.Use();

        vao_.Bind();
        ebo_.Bind();
        vbo_.Bind();
        ssbo_pos_.Bind();
        ssbo_pos_.BindBase(1);
        ssbo_vel_.Bind();
        ssbo_vel_.BindBase(2);
        ssbo_acc_.Bind();
        ssbo_acc_.BindBase(3);

        glDrawElementsInstanced(GL_TRIANGLES, static_cast<GLsizei>(entity_element_size_[entityarr.first]),
            GL_UNSIGNED_INT, (void*)(entity_element_index_[entityarr.first] * sizeof(unsigned int)), static_cast<GLsizei>(i));

        ssbo_acc_.UnbindBase(3);
        ssbo_acc_.Unbind();
        ssbo_vel_.UnbindBase(2);
        ssbo_vel_.Unbind();
        ssbo_pos_.UnbindBase(1);
        ssbo_pos_.Unbind();
        vbo_.Unbind();
        ebo_.Unbind();
        vao_.Unbind();
    }
    num_entity_rendered_ = n;
    profiler_->ProfileStop("root/render/entity");

}

void MultiEntityRenderer::SetRotation(glm::dvec2 rotation_) {
    player_.SetRotation(rotation_);
}

void MultiEntityRenderer::SetPosition(glm::dvec3 position) {
    player_.SetPosition(position);
}

void MultiEntityRenderer::SetWindow(GLFWwindow* win) {
    window_ = win;
}


void MultiEntityRenderer::Update() {
    profiler_->ProfileStart("root/update/entity");
    int width, height;

    glfwGetWindowSize(window_, &width, &height);
    glm::mat4 model = glm::mat4(1.f);

    camera_->screen_res_ = glm::vec2(width, height);

    glm::mat4 view = camera_->GetViewMatrix();

    int x = width;
    int y = height;
    glm::mat4 projection = glm::perspective(glm::radians(camera_->fov_), (float)x / (float)y, 0.1f, 1000000.0f);

    shader_.Use();
    shader_.SetMat4("view", view);
    shader_.SetMat4("model", model);
    shader_.SetMat4("projection", projection);
    shader_.SetFloat("RenderDistance", (float)(horizontal_render_distance_ * 16));
    shader_.SetFloat("VerticalRenderDistance", (float)(vertical_render_distance_ * 16));
    shader_.SetVec3("camPos", camera_->position_);
    shader_.SetFloat("TimeDelta", static_cast<float>(time_past_tick_));
    profiler_->ProfileStop("root/update/entity");
}

void MultiEntityRenderer::Reload() {

    //reset gpu data
    vbo_.Delete();
    ebo_.Delete();
    vao_.ResetArray();

    //reset entity models
    for (auto e : g_entity_list.entity_type_list_) {
        e->render_model_.Clear();
    }

    g_entity_list.Initialize();

    Initialize(profiler_);
}
"./RenderEngine\\EntityRenderer\\MultiEntityRender.h"
#pragma once
#include <vector>
#include "EntityRenderCache.h"
#include "../OpenGL/Buffers/Buffer.h"
#include "../OpenGL/Shader/Shader.h"
#include "../../Client/Render/PlayerPOV.h"
#include "../../Level/Entity/Type/EntityType.h"
#include "../../Level/Entity/Entities.h"
#include "../../Client/Profiler/PerformanceProfiler.h"

class MultiEntityRenderer {
private:

    std::vector<float> entity_vertices_;
    std::vector<unsigned int> entity_indices_;

    FastHashMap<EntityTypeID, EntityModel> entity_cached_models_;

    FastHashMap<EntityTypeID, size_t> entity_element_index_;
    FastHashMap<EntityTypeID, size_t> entity_element_size_;

    EntityRenderCache renderable_entities_;

    Shader shader_;

    PlayerPOV player_;
    Camera* camera_;
    GLFWwindow* window_;

    Buffer vbo_;
    Buffer ebo_;
    Buffer ssbo_pos_, ssbo_vel_, ssbo_acc_;
    VertexArray vao_;

    std::vector<float> position_arr_;
    std::vector<float> velocity_arr_;
    std::vector<float> acceleration_arr_;

    PerformanceProfiler* profiler_;

    size_t num_entity_rendered_ = 0;

    double time_past_tick_ = 0.0;
public:

    int vertical_render_distance_ = 16;
    int horizontal_render_distance_ = 16;

    void Clean();

    size_t GetNumEntityRendered();

    void AddEntity(EntityProperty& entity);

    void RemoveEntity(EntityUUID EntityUUID);

    void Initialize(PerformanceProfiler* pProfilerIn);

    void SetTimePastTick(double t);

    void SetupCall();

    void Render();

    void SetRotation(glm::dvec2 rotation_);

    void SetPosition(glm::dvec3 position);

    void SetWindow(GLFWwindow* win);

    void Update();

    void Reload();
};
"./RenderEngine\\Frustum\\frustum.cpp"
//***********************************************************************//
//                                                                         //
//        - "Talk to me like I'm a 3 year old!" Programming Lessons -         //
//                                                                       //
//        $Author:        DigiBen        digiben@gametutorials.com             //
//                                                                         //
//        $Program:        Frustum Culling                                     //
//                                                                         //
//        $Description:    Demonstrates checking if shapes are in view         //
//                                                                         //
//***********************************************************************//
#define _CRTDBG_MAP_ALLOC
#include "../Camera/camera.h"
#include "frustum.h"
#include <cmath>
#include <gl/glew.h>
#include <GLFW/glfw3.h>

#include <glm/mat4x4.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>



using namespace glm;

// We create an enum of the sides so we don't have to call each side 0 or 1.
// This way it makes it more understandable and readable when dealing with frustum sides.
enum FrustumSide
{
    RIGHT_ = 0,        // The RIGHT side of the frustum
    LEFT_ = 1,        // The LEFT     side of the frustum
    BOTTOM_ = 2,        // The BOTTOM side of the frustum
    TOP_ = 3,        // The TOP side of the frustum
    BACK_ = 4,        // The BACK    side of the frustum
    FRONT_ = 5            // The FRONT side of the frustum
};

// Like above, instead of saying a number for the ABC and D of the plane, we
// want to be more descriptive.
enum PlaneData
{
    A = 0,                // The X value of the plane's normal
    B = 1,                // The Y value of the plane's normal
    C = 2,                // The Z value of the plane's normal
    D = 3                // The distance the plane is from the origin
};

///////////////////////////////// NORMALIZE PLANE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////    This normalizes a plane (A side) from a given frustum.
/////
///////////////////////////////// NORMALIZE PLANE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void NormalizePlane(float frustum[6][4], int side)
{
    // Here we calculate the magnitude of the normal to the plane (point A B C)
    // Remember that (A, B, C) is that same thing as the normal's (X, Y, Z).
    // To calculate magnitude you use the equation:  magnitude = sqrt( x^2 + y^2 + z^2)
    float magnitude = (float)sqrt(frustum[side][A] * frustum[side][A] +
        frustum[side][B] * frustum[side][B] +
        frustum[side][C] * frustum[side][C]);

    // Then we divide the plane's values by it's magnitude.
    // This makes it easier to work with.
    frustum[side][A] /= magnitude;
    frustum[side][B] /= magnitude;
    frustum[side][C] /= magnitude;
    frustum[side][D] /= magnitude;
}


///////////////////////////////// CALCULATE FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////    This extracts our frustum from the projection and modelview matrix.
/////
///////////////////////////////// CALCULATE FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void CFrustum::CalculateFrustum(Camera* cam)
{



    float clip[16];

    glm::mat4 modl = cam->GetViewMatrix();
    glm::mat4 proj = perspective(glm::radians(cam->fov_), (float)cam->screen_res_.x / (float)cam->screen_res_.y, 0.001f, 32768.0f);



    // Now that we have our modelview and projection matrix, if we combine these 2 matrices,
    // it will give us our clipping planes.  To combine 2 matrices, we multiply them.

    clip[0] = modl[0].x * proj[0].x + modl[0].y * proj[1].x + modl[0].z * proj[2].x + modl[0].w * proj[3].x;
    clip[1] = modl[0].x * proj[0].y + modl[0].y * proj[1].y + modl[0].z * proj[2].y + modl[0].w * proj[3].y;
    clip[2] = modl[0].x * proj[0].z + modl[0].y * proj[1].z + modl[0].z * proj[2].z + modl[0].w * proj[3].z;
    clip[3] = modl[0].x * proj[0].w + modl[0].y * proj[1].w + modl[0].z * proj[2].w + modl[0].w * proj[3].w;

    clip[4] = modl[1].x * proj[0].x + modl[1].y * proj[1].x + modl[1].z * proj[2].x + modl[1].w * proj[3].x;
    clip[5] = modl[1].x * proj[0].y + modl[1].y * proj[1].y + modl[1].z * proj[2].y + modl[1].w * proj[3].y;
    clip[6] = modl[1].x * proj[0].z + modl[1].y * proj[1].z + modl[1].z * proj[2].z + modl[1].w * proj[3].z;
    clip[7] = modl[1].x * proj[0].w + modl[1].y * proj[1].w + modl[1].z * proj[2].w + modl[1].w * proj[3].w;

    clip[8] = modl[2].x * proj[0].x + modl[2].y * proj[1].x + modl[2].z * proj[2].x + modl[2].w * proj[3].x;
    clip[9] = modl[2].x * proj[0].y + modl[2].y * proj[1].y + modl[2].z * proj[2].y + modl[2].w * proj[3].y;
    clip[10] = modl[2].x * proj[0].z + modl[2].y * proj[1].z + modl[2].z * proj[2].z + modl[2].w * proj[3].z;
    clip[11] = modl[2].x * proj[0].w + modl[2].y * proj[1].w + modl[2].z * proj[2].w + modl[2].w * proj[3].w;

    clip[12] = modl[3].x * proj[0].x + modl[3].y * proj[1].x + modl[3].z * proj[2].x + modl[3].w * proj[3].x;
    clip[13] = modl[3].x * proj[0].y + modl[3].y * proj[1].y + modl[3].z * proj[2].y + modl[3].w * proj[3].y;
    clip[14] = modl[3].x * proj[0].z + modl[3].y * proj[1].z + modl[3].z * proj[2].z + modl[3].w * proj[3].z;
    clip[15] = modl[3].x * proj[0].w + modl[3].y * proj[1].w + modl[3].z * proj[2].w + modl[3].w * proj[3].w;

    // Now we actually want to get the sides of the frustum.  To do this we take
    // the clipping planes we received above and extract the sides from them.

    // This will extract the RIGHT side of the frustum
    frustum_[RIGHT_][A] = clip[3] - clip[0];
    frustum_[RIGHT_][B] = clip[7] - clip[4];
    frustum_[RIGHT_][C] = clip[11] - clip[8];
    frustum_[RIGHT_][D] = clip[15] - clip[12];

    // Now that we have a normal (A,B,C) and a distance (D) to the plane,
    // we want to normalize that normal and distance.

    // Normalize the RIGHT side
    NormalizePlane(frustum_, RIGHT_);

    // This will extract the LEFT side of the frustum
    frustum_[LEFT_][A] = clip[3] + clip[0];
    frustum_[LEFT_][B] = clip[7] + clip[4];
    frustum_[LEFT_][C] = clip[11] + clip[8];
    frustum_[LEFT_][D] = clip[15] + clip[12];

    // Normalize the LEFT side
    NormalizePlane(frustum_, LEFT_);

    // This will extract the BOTTOM side of the frustum
    frustum_[BOTTOM_][A] = clip[3] + clip[1];
    frustum_[BOTTOM_][B] = clip[7] + clip[5];
    frustum_[BOTTOM_][C] = clip[11] + clip[9];
    frustum_[BOTTOM_][D] = clip[15] + clip[13];

    // Normalize the BOTTOM side
    NormalizePlane(frustum_, BOTTOM_);

    // This will extract the TOP side of the frustum
    frustum_[TOP_][A] = clip[3] - clip[1];
    frustum_[TOP_][B] = clip[7] - clip[5];
    frustum_[TOP_][C] = clip[11] - clip[9];
    frustum_[TOP_][D] = clip[15] - clip[13];

    // Normalize the TOP side
    NormalizePlane(frustum_, TOP_);

    // This will extract the BACK side of the frustum
    frustum_[BACK_][A] = clip[3] - clip[2];
    frustum_[BACK_][B] = clip[7] - clip[6];
    frustum_[BACK_][C] = clip[11] - clip[10];
    frustum_[BACK_][D] = clip[15] - clip[14];

    // Normalize the BACK side
    NormalizePlane(frustum_, BACK_);

    // This will extract the FRONT side of the frustum
    frustum_[FRONT_][A] = clip[3] + clip[2];
    frustum_[FRONT_][B] = clip[7] + clip[6];
    frustum_[FRONT_][C] = clip[11] + clip[10];
    frustum_[FRONT_][D] = clip[15] + clip[14];

    // Normalize the FRONT side
    NormalizePlane(frustum_, FRONT_);
}

// The code below will allow us to make checks within the frustum.  For example,
// if we want to see if a point, a sphere, or a cube lies inside of the frustum.
// Because all of our planes point INWARDS (The normals are all pointing inside the frustum)
// we then can assume that if a point is in FRONT of all of the planes, it's inside.

///////////////////////////////// POINT IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////    This determines if a point is inside of the frustum
/////
///////////////////////////////// POINT IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool CFrustum::PointInFrustum(float x, float y, float z) const
{
    // If you remember the plane equation (A*x + B*y + C*z + D = 0), then the rest
    // of this code should be quite obvious and easy to figure out yourself.
    // In case don't know the plane equation, it might be a good idea to look
    // at our Plane Collision tutorial at www.GameTutorials.com in OpenGL Tutorials.
    // I will briefly go over it here.  (A,B,C) is the (X,Y,Z) of the normal to the plane.
    // They are the same thing... but just called ABC because you don't want to say:
    // (x*x + y*y + z*z + d = 0).  That would be wrong, so they substitute them.
    // the (x, y, z) in the equation is the point that you are testing.  The D is
    // The distance the plane is from the origin.  The equation ends with "= 0" because
    // that is true when the point (x, y, z) is ON the plane.  When the point is NOT on
    // the plane, it is either a negative number (the point is behind the plane) or a
    // positive number (the point is in front of the plane).  We want to check if the point
    // is in front of the plane, so all we have to do is go through each point and make
    // sure the plane equation goes out to a positive number on each side of the frustum.
    // The result (be it positive or negative) is the distance the point is front the plane.

    // Go through all the sides of the frustum
    for (int i = 0; i < 6; i++)
    {
        // Calculate the plane equation and check if the point is behind a side of the frustum
        if (frustum_[i][A] * x + frustum_[i][B] * y + frustum_[i][C] * z + frustum_[i][D] <= 0)
        {
            // The point was behind a side, so it ISN'T in the frustum
            return false;
        }
    }

    // The point was inside of the frustum (In front of ALL the sides of the frustum)
    return true;
}


///////////////////////////////// SPHERE IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////    This determines if a sphere is inside of our frustum by it's center and radius.
/////
///////////////////////////////// SPHERE IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool CFrustum::SphereInFrustum(float x, float y, float z, float radius) const
{
    // Now this function is almost identical to the PointInFrustum(), except we
    // now have to deal with a radius around the point.  The point is the center of
    // the radius.  So, the point might be outside of the frustum, but it doesn't
    // mean that the rest of the sphere is.  It could be half and half.  So instead of
    // checking if it's less than 0, we need to add on the radius to that.  Say the
    // equation produced -2, which means the center of the sphere is the distance of
    // 2 behind the plane.  Well, what if the radius was 5?  The sphere is still inside,
    // so we would say, if(-2 < -5) then we are outside.  In that case it's false,
    // so we are inside of the frustum, but a distance of 3.  This is reflected below.

    // Go through all the sides of the frustum
    for (int i = 0; i < 6; i++)
    {
        // If the center of the sphere is farther away from the plane than the radius
        if (frustum_[i][A] * x + frustum_[i][B] * y + frustum_[i][C] * z + frustum_[i][D] <= -radius)
        {
            // The distance was greater than the radius so the sphere is outside of the frustum
            return false;
        }
    }

    // The sphere was inside of the frustum!
    return true;
}


///////////////////////////////// CUBE IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////    This determines if a cube is in or around our frustum by it's center and 1/2 it's length
/////
///////////////////////////////// CUBE IN FRUSTUM \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool CFrustum::CubeInFrustum(float x, float y, float z, float size) const
{
    // This test is a bit more work, but not too much more complicated.
    // Basically, what is going on is, that we are given the center of the cube,
    // and half the length.  Think of it like a radius.  Then we checking each point
    // in the cube and seeing if it is inside the frustum.  If a point is found in front
    // of a side, then we skip to the next side.  If we get to a plane that does NOT have
    // a point in front of it, then it will return false.

    // *Note* - This will sometimes say that a cube is inside the frustum when it isn't.
    // This happens when all the corners of the bounding box are not behind any one plane.
    // This is rare and shouldn't effect the overall rendering speed.

    for (int i = 0; i < 6; i++)
    {
        if (frustum_[i][A] * (x - size) + frustum_[i][B] * (y - size) + frustum_[i][C] * (z - size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x + size) + frustum_[i][B] * (y - size) + frustum_[i][C] * (z - size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x - size) + frustum_[i][B] * (y + size) + frustum_[i][C] * (z - size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x + size) + frustum_[i][B] * (y + size) + frustum_[i][C] * (z - size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x - size) + frustum_[i][B] * (y - size) + frustum_[i][C] * (z + size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x + size) + frustum_[i][B] * (y - size) + frustum_[i][C] * (z + size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x - size) + frustum_[i][B] * (y + size) + frustum_[i][C] * (z + size) + frustum_[i][D] > 0)
            continue;
        if (frustum_[i][A] * (x + size) + frustum_[i][B] * (y + size) + frustum_[i][C] * (z + size) + frustum_[i][D] > 0)
            continue;

        // If we get here, it isn't in the frustum
        return false;
    }

    return true;
}


/////////////////////////////////////////////////////////////////////////////////
//
// * QUICK NOTES * 
//
// WOZZERS!  That seemed like an incredible amount to look at, but if you break it
// down, it's not.  Frustum culling is a VERY useful thing when it comes to 3D.
// If you want a large world, there is no way you are going to send it down the
// 3D pipeline every frame and let OpenGL take care of it for you.  That would
// give you a 0.001 frame rate.  If you hit '+' and bring the sphere count up to
// 1000, then take off culling, you will see the HUGE difference it makes.  
// Also, you wouldn't really be rendering 1000 spheres.  You would most likely
// use the sphere code for larger objects.  Let me explain.  Say you have a bunch
// of objects, well... all you need to do is give the objects a radius, and then
// test that radius against the frustum.  If that sphere is in the frustum, then you
// render that object.  Also, you won't be rendering a high poly sphere so it won't
// be so slow.  This goes for bounding box's too (Cubes).  If you don't want to
// do a cube, it is really easy to convert the code for rectangles.  Just pass in
// a width and height, instead of just a length.  Remember, it's HALF the length of
// the cube, not the full length.  So it would be half the width and height for a rect.
// 
// This is a perfect starter for an octree tutorial.  Wrap you head around the concepts
// here and then see if you can apply this to making an octree.  Hopefully we will have
// a tutorial up and running for this subject soon.  Once you have frustum culling,
// the next step is getting space partitioning.  Either it being a BSP tree of an Octree.
// 
// Let's go over a brief overview of the things we learned here:
//
// 1) First we need to abstract the frustum from OpenGL.  To do that we need the
//    projection and modelview matrix.  To get the projection matrix we use:
//
//            glGetFloatv( GL_PROJECTION_MATRIX, /* An Array of 16 floats */ );
//    Then, to get the modelview matrix we use:
//
//            glGetFloatv( GL_MODELVIEW_MATRIX, /* An Array of 16 floats */ );
//    
//      These 2 functions gives us an array of 16 floats (The matrix).
//
// 2) Next, we need to combine these 2 matrices.  We do that by matrix multiplication.
//
// 3) Now that we have the 2 matrixes combined, we can abstract the sides of the frustum.
//    This will give us the normal and the distance from the plane to the origin (ABC and D).
//
// 4) After abstracting a side, we want to normalize the plane data.  (A B C and D).
//
// 5) Now we have our frustum, and we can check points against it using the plane equation.
//    Once again, the plane equation (A*x + B*y + C*z + D = 0) says that if, point (X,Y,Z)
//    times the normal of the plane (A,B,C), plus the distance of the plane from origin,
//    will equal 0 if the point (X, Y, Z) lies on that plane.  If it is behind the plane
//    it will be a negative distance, if it's in front of the plane (the way the normal is facing)
//    it will be a positive number.
//
//
// If you need more help on the plane equation and why this works, download our
// Ray Plane Intersection Tutorial at www.GameTutorials.com.
//
// That's pretty much it with frustums.  There is a lot more we could talk about, but
// I don't want to complicate this tutorial more than I already have.
//
// I want to thank Mark Morley for his tutorial on frustum culling.  Most of everything I got
// here comes from his teaching.  If you want more in-depth, visit his tutorial at:
//
// http://www.markmorley.com/opengl/frustumculling.html
//
// Good luck!
//
//
// Ben Humphrey (DigiBen)
// Game Programmer
// DigiBen@GameTutorials.com
// 2000-2005 GameTutorials
//
//
"./RenderEngine\\Frustum\\frustum.h"
#pragma once
#include "../Camera/camera.h"

class CFrustum {

public:

    // Call this every time the camera moves to update the frustum
    void CalculateFrustum(Camera* cam);

    // This takes a 3D point and returns TRUE if it's inside of the frustum
    bool PointInFrustum(float x, float y, float z) const;

    // This takes a 3D point and a radius and returns TRUE if the sphere is inside of the frustum
    bool SphereInFrustum(float x, float y, float z, float radius) const;

    // This takes the center and half the length of the cube.
    bool CubeInFrustum(float x, float y, float z, float size) const;

private:

    // This holds the A B C and D values for each side of our frustum.
    float frustum_[6][4];
};
"./RenderEngine\\GUI\\Font.cpp"
#include "Font.h"

glm::vec4 RenderableFont::GetCharUV(char c) {
    int index = (int)c;

    float width = GetCharWidth(c);

    float x0 = (float)(index & 0b1111);
    float y0 = (float)(index >> 4);

    float x1 = x0 + width;
    float y1 = y0 + 1.f;

    x0 = x0 / 16.f;
    y0 = y0 / 16.f;
    x1 = x1 / 16.f;
    y1 = y1 / 16.f;

    return glm::vec4{ x0, 1.f - y0, x1, 1.f - y1 };
}

float RenderableFont::GetCharWidth(char c) {
    return CharWidth[(int)c];
}


std::vector<float> RenderableFont::GetCharactorVertex(char c, float xOffset, float yOffset, float xOrigin, float yOrigin) {
    

    glm::vec4 uv_ = GetCharUV(c);

    float x0 = uv_.x;
    float y0 = uv_.y;
    float x1 = uv_.z;
    float y1 = uv_.w;

    float Width = GetCharWidth(c);

    std::vector<float> out = {
        0                    , 0                ,xOffset, yOffset, xOrigin, yOrigin, x0, y1, color_.x, color_.y, color_.z,
        0 + font_size_ * Width, 0                ,xOffset, yOffset, xOrigin, yOrigin, x1, y1, color_.x, color_.y, color_.z,
        0 + font_size_ * Width, 0 + font_size_    ,xOffset, yOffset, xOrigin, yOrigin, x1, y0, color_.x, color_.y, color_.z,
        0 + font_size_ * Width, 0 + font_size_    ,xOffset, yOffset, xOrigin, yOrigin, x1, y0, color_.x, color_.y, color_.z,
        0                    , 0 + font_size_    ,xOffset, yOffset, xOrigin, yOrigin, x0, y0, color_.x, color_.y, color_.z,
        0                    , 0                ,xOffset, yOffset, xOrigin, yOrigin, x0, y1, color_.x, color_.y, color_.z
    };

    return out;
}

std::vector<float> RenderableFont::GetVertices() {
    std::vector<float> out;

    float shift = font_size_;

    glm::vec2 coords = position_;

    float offsetValue = 0.f;

    for (int i = 0; i < render_text_.size(); i++) {
        char c = render_text_[i];
        float Width = GetCharWidth(c);
        float ShiftMag = shift * Width + spacing_ * shift;

        std::vector<float> charVert = GetCharactorVertex(render_text_[i], offsetValue, 0.f, coords.x, coords.y);

        offsetValue = offsetValue + ShiftMag;

        out.insert(out.end(), charVert.begin(), charVert.end());
        charVert.clear();
    }

    text_length_ = offsetValue;

    return out;
}

std::vector<float> RenderableFont::GetBackgroundVertices() {
    float r = background_color_.x;
    float g = background_color_.y;
    float b = background_color_.z;
    float a = background_alpha_;

    float xOrigin = position_.x;
    float yOrigin = position_.y;

    float W = background_width_padding_;
    float H = background_height_padding_;

    std::vector<float> out = {
        0 - W                , 0    - H                , xOrigin, yOrigin, r, g, b, a,
        0 + text_length_ + W    , 0 - H                , xOrigin, yOrigin, r, g, b, a,
        0 + text_length_ + W    , 0 + font_size_ + H    , xOrigin, yOrigin, r, g, b, a,
        0 + text_length_ + W    , 0 + font_size_ + H    , xOrigin, yOrigin, r, g, b, a,
        0 - W                , 0 + font_size_ + H    , xOrigin, yOrigin, r, g, b, a,
        0 - W                , 0 - H                , xOrigin, yOrigin, r, g, b, a,
    };

    return out;
}
"./RenderEngine\\GUI\\Font.h"
#pragma once
#include <string>
#include <glm/vec4.hpp>
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>
#include <vector>

const float CharWidth[256]{
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        0.625f, 0.125f, 0.250f, 0.625f, 0.625f, 0.625f, 0.625f, 0.125f, 0.375f, 0.375f, 0.375f, 0.625f, 0.125f, 0.625f, 0.125f, 0.625f,
        0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.125f, 0.125f, 0.500f, 0.625f, 0.500f, 0.625f,
        0.750f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.375f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f,
        0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.375f, 0.625f, 0.375f, 0.625f, 0.625f,
        0.250f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.500f, 0.625f, 0.625f, 0.125f, 0.625f, 0.500f, 0.250f, 0.625f, 0.625f, 0.625f,
        0.625f, 0.625f, 0.625f, 0.625f, 0.375f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.625f, 0.375f, 0.125f, 0.375f, 0.625f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 0.625f, 1.000f, 1.000f, 0.625f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 0.500f, 0.500f, 1.000f, 1.000f, 0.625f, 1.000f, 1.000f, 1.000f, 0.750f, 0.750f,

        //Rows beyond this is just garbage data for now
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
        1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f, 1.000f,
};

class RenderableFont {
private:

    std::string render_text_ = "";
    float font_size_ = 0.0625f;
    float spacing_ = 0.125f;

    glm::vec4 GetCharUV(char c);
    glm::vec3 color_ = glm::vec3(1.f, 1.f, 1.f);
    glm::vec2 position_ = glm::vec2(-1.f,-1.f);
    glm::vec3 background_color_ = glm::vec3(1.f,1.f,1.f);
    float background_alpha_ = 1.f;
    float text_length_ = 0.f;
    float background_height_padding_ = 0.f;
    float background_width_padding_ = 0.f;

    std::vector<float> GetCharactorVertex(char c, float xOffset, float yOffset, float xOrigin, float yOrigin);
    float GetCharWidth(char c);
public:
    bool background_ = false;

    void setBackgroundPadding(float H, float W) {
        background_height_padding_ = H;
        background_width_padding_ = W;
    }

    void SetText(std::string str) {
        render_text_ = str;
    }

    void AddBackground(glm::vec3 color, float alpha) { //add background
        background_ = true;
        background_color_ = color;
        background_alpha_ = alpha;
    }

    void FontSize(float size) {
        font_size_ = size;
    }

    void SetColor(glm::vec3 clr) {
        color_ = clr;
    }

    void SetPosition(glm::vec2 pos) {
        position_ = pos;
    }

    std::vector<float> GetVertices(); //-1 - 1 coords
    std::vector<float> GetBackgroundVertices();
};
"./RenderEngine\\GUI\\GUI.cpp"
#include "GUI.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "../../Utils/LogUtils.h"
"./RenderEngine\\GUI\\GUI.h"
#pragma once

#include <unordered_map>
#include "../OpenGL/Shader/Shader.h"
#include "../OpenGL/Buffers/Buffer.h"
#include <vector>
#include "GUIObject.h"
#include "GUISet.h"

class GUI {
public:

    void Initialize(GLFWwindow* win) {
        window_ = win;
        shader_.Init("assets/shaders/GUI/GUIVert.glsl", "assets/shaders/GUI/GUIFrag.glsl");
    }

    size_t AddGUI(std::string Name, GUISet set) {
        guis_.emplace_back(set);
        return guis_.size() - 1;
    }

    GUISet& EditGUISet(size_t GUIIndex) {
        return guis_[GUIIndex];
    }

    void PrepareRenderer() {
        for (auto& gui : guis_) {
            gui.PrepareRenderer();
        }

        
    }

    void Render() {
        Update();
        SetupDrawCalls();

        shader_.Use();
        for (auto& gui : guis_) {
            shader_.BindTexture2D(0, gui.gui_texture_.get(), "GUITexture");
            for (int i = 0; i < gui.num_of_renderable_objects_; i++) {
            //    std::cout << gui.Textures[i]->get() << "\n";
                
                gui.vaos_[i].Bind();
                gui.ebos_[i].Bind();
                glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(gui.vbo_size_[i]), GL_UNSIGNED_INT, 0);
                gui.ebos_[i].Unbind();
                gui.vaos_[i].Unbind();
            }
            
        }
        
    }

private:

    void SetupDrawCalls() {
        glEnable(GL_BLEND);
        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_TRUE);
        glDisable(GL_CULL_FACE);
    }

    void Update() {

        int Height, Width;
        glfwGetWindowSize(window_, &Width, &Height);

        shader_.Use();
        shader_.SetFloat("AspectRatio", ((float)Height)/((float)Width));
    }

    std::vector<GUISet> guis_ = {};

    Shader shader_;
    GLFWwindow* window_ = nullptr;

    //bool isDirty = false;
};
"./RenderEngine\\GUI\\GUIObject.h"
#pragma once
#include <string>
#include <glm/vec2.hpp>
#include <vector>



struct GUIElement {
    struct GUIVertices {
        std::vector<float> vertices_ = {};
        std::vector<int> indices_ = {};
    };

    GUIElement() {

    }

    GUIElement(std::string text, glm::vec2 size, glm::vec2 location) : text_(text), size_(size), location_(location) {

    }

    GUIVertices GetVertices() {
        GUIVertices data;
        uv_p0_.y = 1.f - uv_p0_.y;
        uv_p1_.y = 1.f - uv_p1_.y;

        data.vertices_.insert(data.vertices_.end(),

            {
                location_.x - (size_.x / 2.f), location_.y - (size_.y / 2.f), uv_p0_.x, uv_p1_.y,
                location_.x + (size_.x / 2.f), location_.y - (size_.y / 2.f), uv_p1_.x, uv_p1_.y,
                location_.x + (size_.x / 2.f), location_.y + (size_.y / 2.f), uv_p1_.x, uv_p0_.y,
                location_.x - (size_.x / 2.f), location_.y + (size_.y / 2.f), uv_p0_.x, uv_p0_.y,
            });

        data.indices_.insert(data.indices_.end(),
            {
                0, 1, 2,
                2, 3, 0
            }
            );


        uv_p0_.y = 1.f - uv_p0_.y;
        uv_p1_.y = 1.f - uv_p1_.y;

        return data;
    }

    std::string text_ = "";
    glm::vec2 size_ = glm::vec2(0.f, 0.f);;
    glm::vec2 location_ = glm::vec2(0.f,0.f);
    glm::vec2 uv_p0_ = glm::vec2(0.f, 0.f);
    glm::vec2 uv_p1_ = glm::vec2(0.f, 0.f);

    int texture_ = 0;
    bool has_texture_ = false;
    bool is_button_ = 0;

    size_t buffer_index_ = 0;
};
"./RenderEngine\\GUI\\GUISet.h"
#pragma once
#include <unordered_map>
#include "../OpenGL/Shader/Shader.h"
#include "../OpenGL/Buffers/Buffer.h"
#include <vector>
#include "GUIObject.h"
#include "../OpenGL/Texture/Types/Texture2D.h"
#include "../../Level/Typenames.h"

class GUISet {
private:
    std::vector<GUIElement> elements_;

    size_t AddRenderingObj() {
        vaos_.emplace_back();
        ebos_.emplace_back();
        vbos_.emplace_back();
        vaos_.back().GenArray();
        vbos_.back().GenBuffer();
        ebos_.back().GenBuffer();

        vbos_.back().SetType(GL_ARRAY_BUFFER);
        ebos_.back().SetType(GL_ELEMENT_ARRAY_BUFFER);

        vbos_.back().SetUsage(GL_STATIC_DRAW);
        ebos_.back().SetUsage(GL_STATIC_DRAW);

        vaos_.back().Bind();
        vbos_.back().Bind();
        vaos_.back().EnableAttriPTR(0, 2, GL_FLOAT, GL_FALSE, 4, 0);
        vaos_.back().EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 4, 2);
        vbos_.back().Unbind();
        vaos_.back().Unbind();

        vbo_size_.emplace_back(0);
        return vaos_.size() - 1;
    }

public:

    GUISet() {}

    void Initialize() {
        
    }

    void Clean() {
        for (auto& vao : vaos_)
            vao.Delete();
        for (auto& vbo : vbos_)
            vbo.Delete();
        for (auto& ebo : ebos_)
            ebo.Delete();
    }

    void AddGUIElementNorm(std::string Name, std::string Text, glm::vec2 Size, glm::vec2 Position, glm::vec2 UV_P0, glm::vec2 UV_P1) {

        if (!is_initialized_) {
            Initialize();
            is_initialized_ = true;
        }

        if (gui_element_index_.find(Name) == gui_element_index_.end()) {
            elements_.emplace_back(Text, Size, Position);
            elements_.back().buffer_index_ = AddRenderingObj();
            elements_.back().uv_p0_ = UV_P0;
            elements_.back().uv_p1_ = UV_P1;
            gui_element_index_.emplace(Name, static_cast<int>(elements_.size() - 1));
            num_of_renderable_objects_++;
            is_dirty_ = true;
        }
        else {
            g_logger.LogError("GUISet::AddGUIElementNorm", "Element " + Name + " already exist!");
        }
    }

    void AddGUIElement(std::string name, std::string text, glm::vec2 size, glm::vec2 position, glm::vec2 UV_P0, glm::vec2 UV_P1) {

        if (!is_initialized_) {
            Initialize();
            is_initialized_ = true;
        }

        UV_P0.x = UV_P0.x / (float)gui_texture_.width_;
        UV_P1.x = UV_P1.x / (float)gui_texture_.width_;

        UV_P0.y = UV_P0.y / (float)gui_texture_.height_;
        UV_P1.y = UV_P1.y / (float)gui_texture_.height_;

        if (gui_element_index_.find(name) == gui_element_index_.end()) {
            elements_.emplace_back(text, size, position);
            elements_.back().buffer_index_ = AddRenderingObj();
            elements_.back().uv_p0_ = UV_P0;
            elements_.back().uv_p1_ = UV_P1;
            gui_element_index_.emplace(name, static_cast<int>(elements_.size() - 1));
            num_of_renderable_objects_++;
            is_dirty_ = true;
        }
        else {
            g_logger.LogError("GUISet::AddGUIElement", "Element " + name + " already exist!");
        }
    }

    void EditElementPosition(std::string Name, glm::vec2 Position) {
        if (gui_element_index_.find(Name) != gui_element_index_.end()) {
            int Index = gui_element_index_[Name];
            elements_[Index].location_ = Position;
            is_dirty_ = true;
        }
        else {
            g_logger.LogError("GUISet::EditElementPosition", "Element " + Name + " doesn't exist!");
        }
    }

    void EditElementUVNorm(std::string Name, glm::vec2 UV0, glm::vec2 UV1) {
        if (gui_element_index_.find(Name) != gui_element_index_.end()) {
            int Index = gui_element_index_[Name];
            elements_[Index].uv_p0_ = UV0;
            elements_[Index].uv_p1_ = UV1;
            is_dirty_ = true;
        }
        else {
            g_logger.LogError("GUISet::EditElementUVNorm", "Element " + Name + " doesn't exist!");
        }
    }

    void SetGUITexture(std::string file) {
        gui_texture_ = Texture2D(RawTextureData(file.c_str()));
    }

    void SetGUITexture(GLuint texture_id_, size_t x, size_t y) {
        gui_texture_.texture_id_ = texture_id_;
        gui_texture_.width_ = x;
        gui_texture_.height_ = y;
    }

    void PrepareRenderer() {
        if (!is_dirty_) {
            return;
        }
        is_dirty_ = false;

        for (auto& e : elements_) {
            
            GUIElement::GUIVertices GUIData = e.GetVertices();
            size_t BufferIndex = e.buffer_index_;
            vbos_[BufferIndex].InsertData(GUIData.vertices_.size() * sizeof(float), GUIData.vertices_.data(), GL_STATIC_DRAW);
            ebos_[BufferIndex].InsertData(GUIData.indices_.size() * sizeof(unsigned int), GUIData.indices_.data(), GL_STATIC_DRAW);
            vbo_size_[BufferIndex] = GUIData.indices_.size();
        }

        
    }

    std::vector<VertexArray> vaos_;
    std::vector<Buffer> vbos_;
    std::vector<Buffer> ebos_;
    std::vector<size_t> vbo_size_;

    int num_of_renderable_objects_ = 0;

    
    FastHashMap<std::string, int> gui_element_index_;
    bool is_dirty_ = true;

    Texture2D gui_texture_;

    bool is_initialized_ = false;
};
"./RenderEngine\\GUI\\TextRenderer.h"
#pragma once
#include "Font.h"
#include <unordered_map>
#include "../OpenGL/Shader/Shader.h"
#include "../OpenGL/Buffers/Buffer.h"
#include "../OpenGL/Texture/Types/Texture2D.h"
#include <exception>
#include "../../Utils/LogUtils.h"
// TODO: Rename
class TextRenderer {
private:
    FastHashMap<std::string, RenderableFont> font_map_;
    Shader font_shader_, background_shader_;
    Buffer vbo_, background_vbo_;
    VertexArray vao_, background_vao_;
    Texture2D font_texture_;
    GLFWwindow* window_ = nullptr;

    std::vector<float> vertices_ = {};
    std::vector<float> vertices_background_ = {};
    
    size_t vertices_count_ = 0;
    size_t background_vert_count_ = 0;

public:
    void InitializeTextRenderer(GLFWwindow* w) {
        //Initialize shaders
        font_shader_.Init("assets/shaders/Font/FontVert.glsl", "assets/shaders/Font/FontFrag.glsl");
        background_shader_.Init("assets/shaders/Font/FontBackgroundVert.glsl", "assets/shaders/Font/FontBackgroundFrag.glsl");

        //Setup buffer for text rendering
        vbo_.GenBuffer();
        vao_.GenArray();

        vbo_.SetType(GL_ARRAY_BUFFER);
        vbo_.SetUsage(GL_STATIC_DRAW);

        vao_.Bind();
        vbo_.Bind();
        vao_.EnableAttriPTR(0, 2, GL_FLOAT, GL_FALSE, 11, 0);
        vao_.EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 11, 2);
        vao_.EnableAttriPTR(2, 2, GL_FLOAT, GL_FALSE, 11, 4);
        vao_.EnableAttriPTR(3, 2, GL_FLOAT, GL_FALSE, 11, 6);
        vao_.EnableAttriPTR(4, 3, GL_FLOAT, GL_FALSE, 11, 8);
        vao_.Unbind();
        vbo_.Unbind();

        //Setup buffer for background rendering
        background_vbo_.GenBuffer();
        background_vao_.GenArray();

        background_vbo_.SetType(GL_ARRAY_BUFFER);
        background_vbo_.SetUsage(GL_STATIC_DRAW);

        background_vao_.Bind();
        background_vbo_.Bind();
        background_vao_.EnableAttriPTR(0, 2, GL_FLOAT, GL_FALSE, 8, 0);
        background_vao_.EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 8, 2);
        background_vao_.EnableAttriPTR(2, 4, GL_FLOAT, GL_FALSE, 8, 4);
        background_vao_.Unbind();
        background_vbo_.Unbind();

        //Load textures
        RawTextureData RawTexture;
        RawTexture.Load("assets/minecraft/textures/font/ascii.png");
        font_texture_.Load(RawTexture);
        font_shader_.BindTexture2D(0, font_texture_.get(), "FontTexture");
        window_ = w;
        g_logger.LogDebug("TextRenderer::InitializeTextRenderer", "Initialized font renderer");
    }

    void InsertFontObject(std::string name ,RenderableFont font) {
        if (font_map_.count(name)) {
            throw std::exception(std::string("Font with the name " + name + " already exist!").c_str());
        }

        font_map_[name] = font;
    }

    void RemoveFontObject(std::string name) {
        if (!font_map_.count(name)) {
            throw std::exception(std::string("Font with the name " + name + " doesn't exist! Cannot remove.").c_str());
        }

        font_map_.erase(name);
    }

    void EditFontText(std::string name, std::string text) {
        font_map_[name].SetText(text);
    }

    void ConstructBuffer() {
        //Fill text buffer
        vertices_.clear();

        for (auto& Font : font_map_) {
            std::vector<float> fontVertices = Font.second.GetVertices();

            vertices_.insert(vertices_.end(), fontVertices.begin(), fontVertices.end());
        }

        vbo_.InsertData(vertices_.size() * sizeof(vertices_[0]), vertices_.data(), GL_STATIC_DRAW);
        vertices_count_ = vertices_.size() / 11;

        //Fill background buffer
        vertices_background_.clear();

        for (auto& Font : font_map_) {
            if (!Font.second.background_) continue;

            std::vector<float> backgroundVertices = Font.second.GetBackgroundVertices();

            vertices_background_.insert(vertices_background_.end(), backgroundVertices.begin(), backgroundVertices.end());
        }

        background_vbo_.InsertData(vertices_background_.size() * sizeof(vertices_background_[0]), vertices_background_.data(), GL_STATIC_DRAW);
        background_vert_count_ = vertices_background_.size() / 8;
    }

    void Prepare() {
        font_shader_.Use();
        font_shader_.BindTexture2D(0, font_texture_.get(), "FontTexture");

        int Height, Width;
        glfwGetWindowSize(window_, &Width, &Height);

        font_shader_.SetFloat("AspectRatio", ((float)Height) / ((float)Width));

        background_shader_.Use();
        background_shader_.SetFloat("AspectRatio", ((float)Height) / ((float)Width));
    }

    void RenderFont() {
        Prepare();
        background_shader_.Use();
        background_vao_.Bind();
        glDrawArrays(GL_TRIANGLES, 0, static_cast<GLsizei>(background_vert_count_));

        font_shader_.Use();
        vao_.Bind();
        glDrawArrays(GL_TRIANGLES, 0, static_cast<GLsizei>(vertices_count_));
    }
};
"./RenderEngine\\ItemRender\\BlockItemRender.h"
#pragma once
#include "../Camera/camera.h"
#include "../OpenGL/Buffers/Buffer.h"
#include "../OpenGL/Shader/Shader.h"
#include "../OpenGL/Texture/Types/TextureAtlas.h"
#include "../BlockModel/BlockModels.h"
#include "../../Level/Chunk/Block/Block.h"
#include "../../Level/Chunk/Block/Blocks.h"
#include "../../Level/Item/Item.h"

class BlockItemRender {
private:
    VertexArray vao_;
    Buffer ebo_, vbo_;
    Shader shader_;

    Camera camera_;

    void SetCamera() {
        camera_.fov_ = 57;
        camera_.position_ = glm::vec3(1.1f,1.1f,1.1f);
        camera_.pitch_ = -35;
        camera_.yaw_ = -135;

        camera_.updateCameraVectors();
    }

    void setDrawCalls() {
        glEnable(GL_BLEND);
        glDepthMask(GL_TRUE);
        glDisable(GL_CULL_FACE);
    }

public:
    void Initialize() {
        shader_.Init("assets/shaders/ItemRender/BlockModelVert.glsl", "assets/shaders/ItemRender/BlockModelFrag.glsl");

        ebo_.SetType(GL_ELEMENT_ARRAY_BUFFER);
        ebo_.SetUsage(GL_STATIC_DRAW);
        vbo_.SetType(GL_ARRAY_BUFFER);
        vbo_.SetUsage(GL_STATIC_DRAW);

        vao_.GenArray();
        ebo_.GenBuffer();
        vbo_.GenBuffer();

        vao_.Bind();
        vbo_.Bind();
        vao_.EnableAttriPTR(0, 3, GL_FLOAT, GL_FALSE, 7, 0);
        vao_.EnableAttriPTR(1, 2, GL_FLOAT, GL_FALSE, 7, 3);
        vao_.EnableAttriPTR(2, 1, GL_FLOAT, GL_FALSE, 7, 5);
        vao_.EnableAttriPTR(3, 1, GL_FLOAT, GL_FALSE, 7, 6);
        vao_.Unbind();
        vbo_.Unbind();
        SetCamera();

        float dimensions = 0.85f;

        glm::mat4 view = camera_.GetViewMatrix();
        glm::mat4 modelMat = glm::mat4(1.f);
        glm::mat4 orthoProj = glm::ortho(-dimensions, dimensions, -dimensions, dimensions, 0.001f, 3.0f);
        shader_.Use();

        shader_.SetMat4("view", view);
        shader_.SetMat4("model", modelMat);
        shader_.SetMat4("projection", orthoProj);


        shader_.BindTexture2D(0, g_blocks.block_texture_atlas_->get(), "BlockTexture");
    }

    void RenderBlock(Item item) {
        if (g_blocks.GetBlockType(item.GetBlock())->block_model_data_ == NULL) {
            return;
        }

        std::vector<float> vertices{};
        std::vector<uint32_t> indices{};

        g_blocks.GetBlockType(item.GetBlock())->block_model_data_->GetVertices(vertices, indices);

        vbo_.InsertData(vertices.size() * sizeof(float), vertices.data(), GL_STATIC_DRAW);
        ebo_.InsertData(indices.size() * sizeof(uint32_t), indices.data(), GL_STATIC_DRAW);
        //std::cout << model.Vertices.size() << '\n';
        camera_.screen_res_ = glm::vec2(16.f, 16.f);

        shader_.Use();
        shader_.BindTexture2D(0, g_blocks.block_texture_atlas_->get(), "BlockTexture");
        setDrawCalls();
        vao_.Bind();
        ebo_.Bind();
        vbo_.Bind();
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, 0);
        vao_.Unbind();
        ebo_.Unbind();
        vbo_.Unbind();
    }

};
"./RenderEngine\\OpenGL\\Buffers\\Buffer.cpp"
#include "Buffer.h"
#include "../../../Utils/LogUtils.h"

unsigned int Buffer::GetID() {
    return buffer_id_;
}
void Buffer::InsertData(GLsizeiptr size, const void* data, GLenum usage) {
    Bind();
    glBufferData(type_, size, data, usage);
    Unbind();
}

void Buffer::InsertSubData(GLintptr offset, GLsizeiptr size, const void* data) {
    Bind();
    glBufferSubData(type_, offset, size, data);
    Unbind();
}

void Buffer::ResetBuffer() {
    glDeleteBuffers(1, &buffer_id_);
    glGenBuffers(1, &buffer_id_);
}

void Buffer::Bind() {
    glBindBuffer(type_, buffer_id_);
}

void Buffer::Unbind() {
    glBindBuffer(type_, 0);
}

void Buffer::Delete() {
    glDeleteBuffers(1, &buffer_id_);
    buffer_id_ = NULL;
    max_size_ = NULL;
    type_ = NULL;
}

void Buffer::SetMaxSize(size_t maxSize) {
    max_size_ = maxSize;
}

void Buffer::SetType(GLenum type) {
    type_ = type;
}

void Buffer::SetUsage(GLenum usage) {
    usage_ = usage;
}

void Buffer::InitializeData() {
    Bind();
    glBufferData(type_, max_size_, nullptr, usage_);
    Unbind();
}

void Buffer::BindBase(int index) {
    glBindBufferBase(type_, index, buffer_id_);
}

void Buffer::UnbindBase(int index) {
    glBindBufferBase(type_, index, 0);
}

void Buffer::GenBuffer() {
    glGenBuffers(1, &buffer_id_);
    g_logger.LogDebug("Buffer::GenBuffer", "Created buffer. ID: " + std::to_string(buffer_id_));
}

void Buffer::getData(uint32_t* ptr, size_t offset, size_t size) {
    Bind();
    glGetBufferSubData(type_, offset, size, static_cast<void*>(ptr));
    Unbind();
}

void Buffer::CopyFrom(Buffer buffer, size_t readOffset, size_t writeOffset, size_t size) {
    glBindBuffer(GL_COPY_READ_BUFFER, buffer.buffer_id_);
    glBindBuffer(GL_COPY_WRITE_BUFFER, buffer_id_);
    glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, readOffset, writeOffset, size);
    glBindBuffer(GL_COPY_READ_BUFFER, 0);
    glBindBuffer(GL_COPY_WRITE_BUFFER, 0);
}

void Buffer::CopyTo(Buffer& destination, size_t offset, size_t desOffset, size_t size) {
    Bind();
    destination.Bind();
//    glCopyNamedBufferSubData(BufferID, destination.BufferID, offset, desOffset, size);
    glCopyBufferSubData(type_, destination.type_, offset, desOffset, size);
    Unbind();
    destination.Unbind();
}

void VertexArray::Delete() {
    glDeleteVertexArrays(1, &array_id_);
    array_id_ = NULL;
}

void VertexArray::Bind() {
    glBindVertexArray(array_id_);
}

void VertexArray::Unbind() {
    glBindVertexArray(0);
}

void VertexArray::EnableAttriPTR(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, int subIndex) {
    glVertexAttribPointer(index, size, type, normalized, sizeof(GL_FLOAT) * stride, (void*)(subIndex * sizeof(unsigned int)));
    glEnableVertexAttribArray(index);
}

void VertexArray::ResetArray() {
    glDeleteVertexArrays(1, &array_id_);
    glGenVertexArrays(1, &array_id_);
}

void VertexArray::GenArray() {
    glGenVertexArrays(1, &array_id_);
    g_logger.LogDebug("VertexArray::GenArray", "Created array. ID: " + std::to_string(array_id_));
}

BufferStorage::BufferStorage() = default; // Add default constructor

BufferStorage::~BufferStorage() {
    if (buffer_storage_id_ != 0) {
        Delete();
    }
}

void BufferStorage::Delete() {
    if (buffer_storage_id_ != 0) {
        glDeleteBuffers(1, &buffer_storage_id_);
        buffer_storage_id_ = 0; // Use 0 to indicate deleted/uninitialized
        max_size_ = 0;
        target_ = 0;
        g_logger.LogDebug("BufferStorage::Delete", "Deleted buffer storage. ID was: " + std::to_string(buffer_storage_id_)); // Log before setting to 0
    }

}

void BufferStorage::Bind() {
    if (buffer_storage_id_ != 0) {
        glBindBuffer(target_, buffer_storage_id_);
    }
    else {
        g_logger.LogWarn("BufferStorage::Bind", "Attempted to bind an uninitialized/deleted buffer storage.");
    }
}

void BufferStorage::Unbind() {
    glBindBuffer(target_, 0);
}


void BufferStorage::Create(GLuint bufferTarget, uint64_t size, bool dynamic, const void* data) {
    if (buffer_storage_id_ != 0) {
        g_logger.LogWarn("BufferStorage::Create", "Create called on an already initialized buffer storage. Deleting old one. ID: " + std::to_string(buffer_storage_id_));
        Delete();
    }

    target_ = bufferTarget;
    max_size_ = size;

    glGenBuffers(1, &buffer_storage_id_);

    if (buffer_storage_id_ == 0) {
        g_logger.LogError("BufferStorage::Create", "glGenBuffers failed!");
        max_size_ = 0;
        target_ = 0;
        return;
    }

    g_logger.LogDebug("BufferStorage::Create", "Generated buffer storage. ID: " + std::to_string(buffer_storage_id_));
    Bind();

    // *** Use glBufferStorage ***
    GLbitfield flags = 0;
    if (dynamic) {
        flags |= GL_DYNAMIC_STORAGE_BIT; // Crucial for glBufferSubData/glCopyBufferSubData
    }
    // *** NO MAPPING FLAGS (GL_MAP_*) are included ***
    // This strongly hints the driver to keep the buffer in VRAM if possible.

    glBufferStorage(target_, static_cast<GLsizeiptr>(size), data, flags);

    // Check for OpenGL errors after buffer storage creation
    GLenum err;
    if ((err = glGetError()) != GL_NO_ERROR) {
        g_logger.LogError("BufferStorage::Create", "OpenGL error after glBufferStorage: " + std::to_string(err));
        Delete(); // Clean up failed buffer
        return;
    }


    g_logger.LogInfo("BufferStorage::Create", "Created buffer storage ID: " + std::to_string(buffer_storage_id_)
        + " Size: " + std::to_string(size) + " bytes, Target: " + std::to_string(target_)
        + ", Dynamic: " + (dynamic ? "Yes" : "No"));

    /*glGenBuffers(1, &buffer_storage_id_);
    Bind();
    GLbitfield flags = GL_MAP_PERSISTENT_BIT | GL_MAP_READ_BIT | GL_DYNAMIC_STORAGE_BIT;
    glBufferStorage(target_, size, nullptr, flags);*/
}

void BufferStorage::InsertData(uint64_t offset, uint64_t size, const void* data) {
    if (buffer_storage_id_ == 0) {
        g_logger.LogError("BufferStorage::InsertData", "Attempted InsertData on uninitialized buffer.");
        return;
    }

    if (offset + size > max_size_) {
        g_logger.LogError("BufferStorage::InsertData", "InsertData exceeds buffer bounds. Offset: " + std::to_string(offset)
            + ", Size: " + std::to_string(size) + ", MaxSize: " + std::to_string(max_size_));
        return;
    }

    Bind();
    glBufferSubData(target_, offset, size, data);
}

void BufferStorage::CopyFrom(BufferStorage& sourceBuffer, size_t readOffset, size_t writeOffset, size_t size) {
    if (buffer_storage_id_ == 0 || sourceBuffer.buffer_storage_id_ == 0) {
        g_logger.LogError("BufferStorage::CopyFrom", "Attempted CopyFrom with uninitialized buffer(s).");
        return;
    }
    if (writeOffset + size > max_size_ || readOffset + size > sourceBuffer.max_size_) {
        g_logger.LogError("BufferStorage::CopyFrom", "CopyFrom exceeds buffer bounds.");
        return;
    }
    glBindBuffer(GL_COPY_READ_BUFFER, sourceBuffer.buffer_storage_id_);
    glBindBuffer(GL_COPY_WRITE_BUFFER, buffer_storage_id_);
    glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, readOffset, writeOffset, size);
    glBindBuffer(GL_COPY_READ_BUFFER, 0);
    glBindBuffer(GL_COPY_WRITE_BUFFER, 0);
}

void BufferStorage::CopyTo(BufferStorage& destinationBuffer, size_t readOffset, size_t writeOffset, size_t size) {
    if (buffer_storage_id_ == 0 || destinationBuffer.buffer_storage_id_ == 0) {
        g_logger.LogError("BufferStorage::CopyTo", "Attempted CopyTo with uninitialized buffer(s).");
        return;
    }
    if (readOffset + size > max_size_ || writeOffset + size > destinationBuffer.max_size_) {
        g_logger.LogError("BufferStorage::CopyTo", "CopyTo exceeds buffer bounds.");
        return;
    }
    glBindBuffer(GL_COPY_READ_BUFFER, buffer_storage_id_);
    glBindBuffer(GL_COPY_WRITE_BUFFER, destinationBuffer.buffer_storage_id_);
    glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, readOffset, writeOffset, size);
    glBindBuffer(GL_COPY_READ_BUFFER, 0);
    glBindBuffer(GL_COPY_WRITE_BUFFER, 0);
}

bool BufferStorage::IsInitialized() const { return buffer_storage_id_ != 0; }

size_t BufferStorage::GetMaxSize() const { return max_size_; }
"./RenderEngine\\OpenGL\\Buffers\\Buffer.h"
#pragma once
#include <gl/glew.h>
#include <GLFW/glfw3.h>

class Buffer {
public:
    void GenBuffer();

    void SetType(GLenum type);
    void SetMaxSize(size_t maxSize);
    void SetUsage(GLenum drawType);

    void ResetBuffer();

    void InitializeData();

    void Delete();

    void BindBase(int index);

    void UnbindBase(int index);

    void Bind();

    void Unbind();

    void getData(uint32_t* ptr, size_t offset, size_t size);

    void CopyFrom(Buffer buffer, size_t readOffset, size_t writeOffset, size_t size);

    unsigned int GetID();

    void InsertData(GLsizeiptr size, const void* data, GLenum usage);
    void InsertSubData(GLintptr Offset, GLsizeiptr Size, const void* Data);

    void SetStorage(int size);

    void CopyTo(Buffer& destination, size_t offset, size_t desOffset, size_t size);

    size_t max_size_ = NULL;
    unsigned int buffer_id_ = NULL;
    unsigned int type_ = NULL, usage_ = NULL;
    
};

class BufferStorage {
public:

    BufferStorage();

    ~BufferStorage();

    void Delete();

    void Bind();
    void Unbind();


    void Create(GLuint bufferTarget, uint64_t size, bool dynamic = true, const void* data = nullptr);
    void InsertData(uint64_t offset, uint64_t size, const void* data);

    void CopyFrom(BufferStorage& sourceBuffer, size_t readOffset, size_t writeOffset, size_t size);

    void CopyTo(BufferStorage& destinationBuffer, size_t readOffset, size_t writeOffset, size_t size);

    bool IsInitialized() const;
    size_t GetMaxSize() const;
    
private:
    unsigned int buffer_storage_id_ = NULL;
    uint64_t max_size_ = NULL;
    GLenum target_ = NULL;
};

class VertexArray {
public:
    void Delete();

    void GenArray();

    void Bind();

    void Unbind();

    void ResetArray();

    void EnableAttriPTR(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, int subIndex);
private:
    unsigned int array_id_ = NULL;
};
"./RenderEngine\\OpenGL\\Framebuffer\\Framebuffer.h"
#pragma once
#include <vector>
#include <gl/glew.h>
#include <GLFW/glfw3.h>
#include <unordered_map>
#include "../Shader/Shader.h"
#include "../../../Utils/LogUtils.h"

class TexturedFrameBuffer {
public:

    GLuint fbo_ = 0, rbo_ = 0, texture_ = 0, shader_id_ = 0;
    GLint sx = 0;
    GLint sy = 0;

    GLint text_size_x_ = 0, text_size_y_ = 0;
    unsigned int quad_vao_ = 0, quad_vbo_ = 0;
    GLfloat res_multiplier_ = 1;

    Shader* screen_ = new Shader;

    void GenBuffer(GLint x, GLint y, float muti, GLuint format = GL_RGBA) {

        screen_->Init("assets/shaders/screen/vert.glsl", "assets/shaders/screen/frag.glsl");
        screen_->SetVec2("Resolution", glm::vec2((x), (y)));

        sy = y;
        sx = x;

        text_size_x_ = sx;
        text_size_y_ = sy;

        res_multiplier_ = muti;
        glGenFramebuffers(1, &fbo_);
        glBindFramebuffer(GL_FRAMEBUFFER, fbo_);
        // create a color attachment texture
        glGenTextures(1, &texture_);
        glBindTexture(GL_TEXTURE_2D, texture_);
        glTexImage2D(GL_TEXTURE_2D, 0, format, (int)(x * muti), (int)(y * muti), 0, format, GL_UNSIGNED_BYTE, NULL);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_, 0);
        // create a renderbuffer object for depth and stencil attachment (we won't be sampling these)
        glGenRenderbuffers(1, &rbo_);
        glBindRenderbuffer(GL_RENDERBUFFER, rbo_);
        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, (int)(x * muti), (int)(y * muti)); // use a single renderbuffer object for both a depth AND stencil buffer.
        
        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo_); // now actually attach it
        // now that we actually created the framebuffer and added all attachments we want to check if it is actually complete now
        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
            g_logger.LogError("TexturedFrameBuffer::GenBuffer", "Failed to create framebuffer!");
        glBindFramebuffer(GL_FRAMEBUFFER, 0);

        screen_->BindTexture2D(0, texture_, "screenTexture");
        shader_id_ = screen_->shader_id_;
        float quadVertices[] = { // vertex attributes for a quad that fills the entire screen in Normalized Device Coordinates. NOTE that this plane is now much smaller and at the top of the screen
          // positions   // texCoords
          -1.f,  1.0f,  0.0f, 1.0f,
          -1.f,  -1.f,  0.0f, 0.0f,
           1.f,  -1.f,  1.0f, 0.0f,

          -1.f,  1.0f,  0.0f, 1.0f,
           1.f,  -1.0f,  1.0f, 0.0f,
           1.f,  1.0f,  1.0f, 1.0f
        };


        glGenVertexArrays(1, &quad_vao_);
        glGenBuffers(1, &quad_vbo_);
        glBindVertexArray(quad_vao_);
        glBindBuffer(GL_ARRAY_BUFFER, quad_vbo_);
        glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));

        g_logger.LogDebug("TexturedFrameBuffer::GenBuffer", "Created new frame buffer: " + std::to_string(fbo_));
    }

    void UpdateResolution(GLint x, GLint y, float muti = 1.f) {
        sx = static_cast<GLint>(muti * x);
        sy = static_cast<GLint>(muti * y);
    }

    void BindRBO() const {
        glBindRenderbuffer(GL_RENDERBUFFER, rbo_);
    }

    void UnbindRBO() const {
        glBindRenderbuffer(GL_RENDERBUFFER, rbo_);
    }

    void BindFBO() {
        glBindFramebuffer(GL_FRAMEBUFFER, fbo_);
        glViewport(0, 0, (int)(sx * res_multiplier_), (int)(sy * res_multiplier_));
        if (sx != text_size_x_ || sy != text_size_y_) {
            glBindTexture(GL_TEXTURE_2D, texture_);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, (int)(sx * res_multiplier_), (int)(sy * res_multiplier_), 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
            glBindRenderbuffer(GL_RENDERBUFFER, rbo_);
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, (int)(sx * res_multiplier_), (int)(sy * res_multiplier_));
            text_size_y_ = sy;
            text_size_x_ = sx;
        }
    }

    void UnbindFBO() {
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glViewport(0, 0, sx, sy);
        if (sx != text_size_x_ || sy != text_size_y_) {
            glBindTexture(GL_TEXTURE_2D, texture_);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, (int)(sx * res_multiplier_), (int)(sy * res_multiplier_), 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
            glBindRenderbuffer(GL_RENDERBUFFER, rbo_);
            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, (int)(sx * res_multiplier_), (int)(sy * res_multiplier_));
            text_size_y_ = sy;
            text_size_x_ = sx;
        }
    }

    void Clear() const {
        glDeleteFramebuffers(1, &fbo_);
        glDeleteTextures(1, &texture_);
        glDeleteRenderbuffers(1, &rbo_);
    }

    void GetShaders() {
    
    }

    void UpdateTexture() {

    }


    void Render() {
        glDisable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
        glUseProgram(shader_id_);
        glBindVertexArray(quad_vao_);
        glBindTexture(GL_TEXTURE_2D, texture_);    // use the color attachment texture as the texture of the quad plane
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_CULL_FACE);
    }
};
"./RenderEngine\\OpenGL\\OpenGL.cpp"
"./RenderEngine\\OpenGL\\OpenGL.h"
#pragma once
"./RenderEngine\\OpenGL\\Shader\\Shader.cpp"
#include "Shader.h"

void Shader::Init(const char* vertexPath, const char* fragmentPath, const char* geometryPath)
{
    // 1. retrieve the vertex/fragment source code from filePath
    std::string vertexCode;
    std::string fragmentCode;
    std::string geometryCode;
    std::ifstream vShaderFile;
    std::ifstream fShaderFile;
    std::ifstream gShaderFile;
    // ensure ifstream objects can throw exceptions:
    vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    try
    {
        // open files
        vShaderFile.open(vertexPath);
        fShaderFile.open(fragmentPath);
        std::stringstream vShaderStream, fShaderStream;
        // read file's buffer contents into streams
        vShaderStream << vShaderFile.rdbuf();
        fShaderStream << fShaderFile.rdbuf();
        // close file handlers
        vShaderFile.close();
        fShaderFile.close();
        // convert stream into string
        vertexCode = vShaderStream.str();
        fragmentCode = fShaderStream.str();
        // if geometry shader path is present, also load a geometry shader
        if (geometryPath != nullptr)
        {
            gShaderFile.open(geometryPath);
            std::stringstream gShaderStream;
            gShaderStream << gShaderFile.rdbuf();
            gShaderFile.close();
            geometryCode = gShaderStream.str();
        }
    }
    catch (std::ifstream::failure& e)
    {
        g_logger.LogError("Shader::Initr", "Failed to read file(s): " + std::string(vertexPath) + ", " + std::string(fragmentPath));
        g_logger.LogError("Shader::Init", e.what());
    }
    g_logger.LogDebug("Shader::Init", "Compiling shader: " + std::string(vertexPath) + ", " + std::string(fragmentPath));
    const char* vShaderCode = vertexCode.c_str();
    const char* fShaderCode = fragmentCode.c_str();
    // 2. compile shaders
    unsigned int vertex, fragment;
    // vertex shader
    vertex = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex, 1, &vShaderCode, NULL);
    glCompileShader(vertex);
    CheckCompileErrors(vertex, "Vertex");
    // fragment Shader
    fragment = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment, 1, &fShaderCode, NULL);
    glCompileShader(fragment);
    CheckCompileErrors(fragment, "Fragment");
    // if geometry shader is given, compile geometry shader
    unsigned int geometry;
    if (geometryPath != nullptr)
    {
        const char* gShaderCode = geometryCode.c_str();
        geometry = glCreateShader(GL_GEOMETRY_SHADER);
        glShaderSource(geometry, 1, &gShaderCode, NULL);
        glCompileShader(geometry);
        CheckCompileErrors(geometry, "Geometry");
    }
    // shader Program
    shader_id_ = glCreateProgram();
    glAttachShader(shader_id_, vertex);
    glAttachShader(shader_id_, fragment);
    if (geometryPath != nullptr)
        glAttachShader(shader_id_, geometry);
    glLinkProgram(shader_id_);
    CheckCompileErrors(shader_id_, "PROGRAM");
    // delete the shaders as they're linked into our program now and no longer necessery
    glDeleteShader(vertex);
    glDeleteShader(fragment);
    if (geometryPath != nullptr)
        glDeleteShader(geometry);
}

void Shader::Use() {
    glUseProgram(shader_id_);
}
"./RenderEngine\\OpenGL\\Shader\\Shader.h"
#pragma once

#include <gl/glew.h>
#include <glm/vec2.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <GLFW/glfw3.h>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <string>
#include "../../../Utils/LogUtils.h"
#include "../../../Level/Typenames.h"

class Shader
{
public:
    unsigned int shader_id_ = NULL;
    // constructor generates the shader on the fly
    // ------------------------------------------------------------------------
    void Init(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr);
    // activate the shader
    // ------------------------------------------------------------------------
    void Use();
    // utility uniform functions
    // ------------------------------------------------------------------------
    void SetBool(const std::string& name, bool value)
    {
        Use();
        glUniform1i(GetUniformLocation(name), (int)value);
    }
    // ------------------------------------------------------------------------
    void SetInt(const std::string& name, int value)
    {
        Use();
        glUniform1i(GetUniformLocation(name), value);
    }
    // ------------------------------------------------------------------------
    void SetFloat(const std::string& name, float value)
    {
        Use();
        glUniform1f(GetUniformLocation(name), value);
    }
    // ------------------------------------------------------------------------
    void SetVec2(const std::string& name, const glm::vec2& value)
    {
        Use();
        glUniform2fv(GetUniformLocation(name), 1, &value[0]);
    }
    void SetVec2(const std::string& name, float x, float y)
    {
        Use();
        glUniform2f(GetUniformLocation(name), x, y);
    }
    // ------------------------------------------------------------------------
    void SetVec3(const std::string& name, const glm::vec3& value)
    {
        Use();
        glUniform3fv(GetUniformLocation(name), 1, &value[0]);
    }
    void SetVec3(const std::string& name, float x, float y, float z)
    {
        Use();
        glUniform3f(GetUniformLocation(name), x, y, z);
    }

    void SetIVec3(const std::string& name, const glm::ivec3& value)
    {
        Use();
        glUniform3iv(GetUniformLocation(name), 1, &value[0]);
    }
    void SetIVec3(const std::string& name, int x, int y, int z)
    {
        Use();
        glUniform3i(GetUniformLocation(name), x, y, z);
    }
    // ------------------------------------------------------------------------
    void SetVec4(const std::string& name, const glm::vec4& value)
    {
        Use();
        glUniform4fv(GetUniformLocation(name), 1, &value[0]);
    }
    void SetVec4(const std::string& name, float x, float y, float z, float w)
    {
        Use();
        glUniform4f(GetUniformLocation(name), x, y, z, w);
    }
    // ------------------------------------------------------------------------
    void SetMat2(const std::string& name, const glm::mat2& mat)
    {
        Use();
        glUniformMatrix2fv(GetUniformLocation(name), 1, GL_FALSE, &mat[0][0]);
    }
    // ------------------------------------------------------------------------
    void SetMat3(const std::string& name, const glm::mat3& mat)
    {
        Use();
        glUniformMatrix3fv(GetUniformLocation(name), 1, GL_FALSE, &mat[0][0]);
    }
    // ------------------------------------------------------------------------
    void SetMat4(const std::string& name, const glm::mat4& mat)
    {
        Use();
        glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &mat[0][0]);
    }

    void BindTexture2D(GLuint index, GLuint img, const std::string& name) {

        SetInt(name, index);

        glActiveTexture(GL_TEXTURE0 + index);
        glBindTexture(GL_TEXTURE_2D, img);

    }

    void BindTextureArray2D(GLuint index, GLuint img, const std::string& name) {
        SetInt(name, index);

        glActiveTexture(GL_TEXTURE0 + index);
        glBindTexture(GL_TEXTURE_2D_ARRAY, img);

    }

private:
    // utility function for checking shader compilation/linking errors.
    // ------------------------------------------------------------------------

    GLint GetUniformLocation(std::string name) {
        if (cache_.count(name)) {
            return cache_[name];
        }
        else {
            GLint location = glGetUniformLocation(shader_id_, name.c_str());
            cache_[name] = location;
            return location;
        }
    }

    FastHashMap<std::string, int> cache_;

    void CheckCompileErrors(GLuint shader, std::string type_)
    {
        GLint success;
        GLchar infoLog[1024];
        if (type_ != "PROGRAM")
        {
            glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
            if (!success)
            {
                glGetShaderInfoLog(shader, 1024, NULL, infoLog);
                g_logger.LogError("Shader::CheckCompileErrors", "Failed to compile" + type_ + " Shader: \n" + std::string(infoLog) + "\n");
            }
        }
        else
        {
            glGetProgramiv(shader, GL_LINK_STATUS, &success);
            if (!success)
            {
                glGetProgramInfoLog(shader, 1024, NULL, infoLog);
                g_logger.LogError("Shader::CheckCompileErrors", "Failed to link Shader Program: \n" + std::string(infoLog) + "\n");
            }
        }
    }
};
"./RenderEngine\\OpenGL\\Texture\\ImageLoader.h"
#pragma once
#include "Texture.h"

RawTextureData GetImageData(const char* path);
"./RenderEngine\\OpenGL\\Texture\\ImagerLoader.cpp"
#include "ImageLoader.h"
#include "../../../Utils/LogUtils.h"

RawTextureData GetImageData(const char* path) {
    RawTextureData data;
    data.data_ = stbi_load(path, &data.width_, &data.height_, &data.format_, 0);
    switch (data.format_) {
    case 1:
        data.format_ = GL_RED;
        g_logger.LogDebug("GetImageData", "Loaded image: " + std::string(path));
        break;
    case 2:
        data.format_ = GL_RG;
        g_logger.LogDebug("GetImageData", "Loaded image: " + std::string(path));
        break;
    case 3:
        data.format_ = GL_RGB;
        g_logger.LogDebug("GetImageData", "Loaded image: " + std::string(path));
        break;
    case 4:
        data.format_ = GL_RGBA;
        g_logger.LogDebug("GetImageData", "Loaded image: " + std::string(path));
        break;
    default:
        g_logger.LogWarn("GetImageData","Image invalid format");
    }
    
    return data;
}
"./RenderEngine\\OpenGL\\Texture\\Texture.h"
#pragma once

#include <gl/glew.h>
#include <GLFW/glfw3.h>
#include "../../../Utils/stb_image.h"
#include "../../../Utils/LogUtils.h"

class RawTextureData { //mem leak
public:

    RawTextureData() {

    }

    RawTextureData(const char* path) {
        Load(path);
    }

    void Erase() { stbi_image_free(data_); }
    void Load(const char* path) {
        image_path_ = path;
        data_ = stbi_load(path, &width_, &height_, &format_, 0);

        switch (format_) {
        case 1:
            format_ = GL_RED;
            break;
        case 2:
            format_ = GL_RG;
            break;
        case 3:
            format_ = GL_RGB;
            break;
        case 4:
            format_ = GL_RGBA;
            break;
        default:
            Erase();
            g_logger.LogWarn("RawTextureData::Load", "Image invalid format");
        }
    }
    unsigned char operator[](int index) {
        return data_[index];
    }

    void Reload() {
        Erase();
        Load(image_path_);
    }
    int width_ = NULL;
    int height_ = NULL;
    int format_ = NULL;
    unsigned char* data_ = nullptr;
private:
    const char* image_path_ = nullptr;
};

class Texture {
public:
    Texture() = default;

    void Gen() {
        glGenTextures(1, &texture_id_);
    }

    virtual bool Load(RawTextureData data) {
        (void)data;
        return false;
    }

    virtual bool Load(std::string file) {
        (void)file;
        return false;
    }

    GLuint get() {
        return texture_id_;
    }

    GLuint texture_id_ = NULL;
    size_t width_ = NULL;
    size_t height_ = NULL;
    int format_ = NULL;
};
"./RenderEngine\\OpenGL\\Texture\\Types\\Texture2D.h"
#pragma once
#include "../Texture.h"
#include "../../../../Utils/LogUtils.h"

class Texture2D : public Texture {
public:
    Texture2D(RawTextureData data) {
        Gen();
        Load(data);
    }

    Texture2D() {
    }

    bool Load(RawTextureData data) override {
        if (data.data_) {
            glBindTexture(GL_TEXTURE_2D, texture_id_);
            glTexImage2D(GL_TEXTURE_2D, 0, data.format_, data.width_, data.height_, 0, data.format_, GL_UNSIGNED_BYTE, data.data_);
            glGenerateMipmap(GL_TEXTURE_2D);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            g_logger.LogDebug("Texture2D::Load", "Loaded 2D Texture: " + std::to_string(texture_id_));
            width_ = data.width_;
            height_ = data.height_;
            return true;
        }
        else {
            g_logger.LogError("Texture2D::Load", "Image is not loaded");
            return false;
        }
        
    }
};
"./RenderEngine\\OpenGL\\Texture\\Types\\TextureArray.h"
#pragma once
#include "../Texture.h"
#include <vector>
#include "../ImageLoader.h"
#include <iostream>
#include <fstream>
#include <optional>
class TextureArray : public Texture {
public:
    void UploadToGPU() {
        GLsizei mipLevelCount = 4;

        glBindTexture(GL_TEXTURE_2D_ARRAY, texture_id_);
        glTexStorage3D(GL_TEXTURE_2D_ARRAY, mipLevelCount, GL_RGBA8, 16, 16, layers_);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0, 0, static_cast<GLsizei>(width_), static_cast<GLsizei>(height_), layers_, GL_RGBA, GL_UNSIGNED_BYTE, array_data_.data());
        glGenerateMipmap(GL_TEXTURE_2D_ARRAY);
        g_logger.LogDebug("TextureArray::UploadToGPU", "Loaded Texture Array: " + std::to_string(texture_id_));
    }
    void SetSize(int width, int height) {
        width_ = width;
        height_ = height;
    }

    void AddData(std::vector<uint8_t> data, size_t width, size_t height, int format) {
        if (format == GL_RGB) {
            for (size_t index = 0; index < width * height; index++) {
                array_data_.push_back(data[(index * 3)]);
                array_data_.push_back(data[(index * 3) + 1]);
                array_data_.push_back(data[(index * 3) + 2]);
                array_data_.push_back(255);
            }
            layers_++;
        } else  if (format == GL_RGBA) {
            for (size_t index = 0; index < width * height; index++) {
                array_data_.push_back(data[(index * 4)]);
                array_data_.push_back(data[(index * 4) + 1]);
                array_data_.push_back(data[(index * 4) + 2]);
                array_data_.push_back(data[(index * 4) + 3]);
            }
            layers_++;
        }
        else  if (format == GL_RG) {
            for (size_t index = 0; index < width * height; index++) {
                array_data_.push_back(data[(index * 2)]);
                array_data_.push_back(data[(index * 2)]);
                array_data_.push_back(data[(index * 2)]);
                array_data_.push_back(data[(index * 2) + 1]);
            }
            layers_++;
        }
        else if (format == GL_RED) {
            for (size_t index = 0; index < width * height; index++) {
                array_data_.push_back(data[index]);
                array_data_.push_back(data[index]);
                array_data_.push_back(data[index]);
                array_data_.push_back(255);
            }
            layers_++;
        }
        else {
            throw std::runtime_error("Invalid texture type not handled");
        }
    }

    bool AddTextureToArray(RawTextureData* data) {
        format_ = GL_RGBA;
        if (!data->data_) {
            g_logger.LogError("TextureArray::AddTextureToArray", "No texture");
            return false;
        }

        if (((data->width_ % width_) != 0) || ((data->height_ % height_) != 0)) {
            g_logger.LogError("TextureArray::AddTextureToArray", "Width or height doesn't match");
            return false;
        }

        size_t imgsX = data->width_ / width_;
        size_t imgsY = data->height_ / height_;

        int colorSize = 3;

        if (data->format_ == GL_RGBA) {
            colorSize = 4;
        }
        if (data->format_ == GL_RG) {
            colorSize = 2;
        }
        else if (data->format_ == GL_RED) {
            colorSize = 1;
        }

        size_t cWidth = width_ * colorSize;

        for (size_t x = 0; x < imgsX; x++) {
            for (size_t y = 0; y < imgsY; y++) {
                size_t gx = x * width_ * colorSize;
                size_t gy = y * height_ * data->width_ * colorSize;

                std::vector<uint8_t> buffer(width_ * height_ * colorSize);

                for (size_t h = 0; h < height_; h++) {
                    memcpy(buffer.data() + (h * cWidth), data->data_ + (h * data->width_ * colorSize + gx + gy), cWidth);
                }

                AddData(buffer, width_, height_, data->format_);
            }
        }

        return true;
    }
    std::optional<RawTextureData> AddTextureToArray(std::string file) {
        std::optional<RawTextureData> data;
        RawTextureData tex = GetImageData(file.c_str());
        if (AddTextureToArray(&tex)) {
            g_logger.LogInfo("TextureArray::AddTextureToArray", "Loaded: " + file + " | Size: " + std::to_string(tex.height_) + ", " + std::to_string(tex.width_));
            data = tex;
            return data;
        }
        g_logger.LogError("TextureArray::AddTextureToArray", "Unable to load: " + file);
        return data;
    }

    int GetLayers() {
        return layers_;
    }

    std::vector<unsigned char> array_data_;

    int layers_ = 0;

};
"./RenderEngine\\OpenGL\\Texture\\Types\\TextureAtlas.h"
#pragma once
#include "../Texture.h"
#include <vector>
#include "../ImageLoader.h"
#include <iostream>
#include <fstream>
#include <glm/vec4.hpp>
#include <optional>
#include <cctype>
class TextureAtlas : public Texture {
public:
    void UploadToGPU() {
        // GLsizei mipLevelcount_ = 4;

        glBindTexture(GL_TEXTURE_2D, texture_id_);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, static_cast<GLsizei>(width_), static_cast<GLsizei>(height_), 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_atlas_data_.data());
        glGenerateMipmap(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 4);

        g_logger.LogDebug("TextureAtlas::UploadToGPU", "Loaded 2D Texture: " + std::to_string(texture_id_));
    }
    void SetSize(int width, int height) {
        width_ = width;
        height_ = height;

        texture_atlas_data_.resize(width_ * height_ * color_space_, NULL);
    }

    inline void setPixel(uint8_t r, uint8_t  g, uint8_t b, uint8_t a, size_t w, size_t h) {
        texture_atlas_data_[w * color_space_ + h * color_space_ + 0] = r;
        texture_atlas_data_[w * color_space_ + h * color_space_ + 1] = g;
        texture_atlas_data_[w * color_space_ + h * color_space_ + 2] = b;
        texture_atlas_data_[w * color_space_ + h * color_space_ + 3] = a;
    }

    void AddData(std::vector<uint8_t> data, int format, bool& transparency, bool& isSeeThrough) { //assumes that all textures  are 16 x 16
        //Get offset to where to put the texture
        size_t widthTex = width_ / 16;
        //int heightTex = height / 16;

        size_t widthIndex = count_ % widthTex;
        size_t heightIndex = count_ / widthTex;

        size_t widthIndexPixel = widthIndex * 16; //Offset for the width
        size_t heightIndexPixel = width_ * heightIndex * 16; //Offset for the height

        switch (format) {
        case GL_RGB:
            for (int index = 0; index < 16 * 16; index++) {
                setPixel(data[(index * 3)], data[(index * 3) + 1], data[(index * 3) + 2], 255, widthIndexPixel + (index % 16), heightIndexPixel + width_ * (index / 16));
            }
            count_++;
            break;
        case GL_RG:
            for (int index = 0; index < 16 * 16; index++) {
                if ((data[(index * 2) + 1] != 255) && (data[(index * 2) + 1] != 0)) {
                    transparency = true;
                    isSeeThrough = true;
                }

                if (data[(index * 2) + 1] != 255) {
                    isSeeThrough = true;
                }

                setPixel(data[(index * 2)], data[(index * 2)], data[(index * 2)], data[(index * 2) + 1], widthIndexPixel + (index % 16), heightIndexPixel + width_ * (index / 16));
            }
            count_++;
            break;
        case GL_RGBA:
            for (int index = 0; index < 16 * 16; index++) {
                if ((data[(index * 4) + 3] != 255) && (data[(index * 4) + 3] != 0)) {
                    transparency = true;
                    isSeeThrough = true;
                }

                if (data[(index * 4) + 3] != 255) {
                    isSeeThrough = true;
                }
                setPixel(data[(index * 4)], data[(index * 4) + 1], data[(index * 4) + 2], data[(index * 4) + 3], widthIndexPixel + (index % 16), heightIndexPixel + width_ * (index / 16));
            }
            count_++;
            break;
        case GL_RED:
            for (int index = 0; index < 16 * 16; index++) {
                setPixel(data[index], data[index], data[index], 255, widthIndexPixel + (index % 16), heightIndexPixel + width_ * (index / 16));
            }
            count_++;
            break;
        default:
            g_logger.LogError("TextureAtlas::AddData", "Invalid image format!");
            break;
        }
    }

    bool _AddTextureToAtlas(RawTextureData* data, bool& transparency, bool& isSeeThrough) {

        format_ = GL_RGBA;
        if (!data->data_) {
            g_logger.LogError("TextureAtlas::_AddTextureToAtlas", "No texture");
            return false;
        }

        if (((data->width_ % 16) != 0) || ((data->height_ % 16) != 0)) {
            g_logger.LogError("TextureAtlas::_AddTextureToAtlas", "Width or height doesn't match");
            return false;
        }

        int imgsX = data->width_ / 16;
        int imgsY = data->height_ / 16;

        int colorSize = 3;

        if (data->format_ == GL_RGBA) {
            colorSize = 4;
        }
        if (data->format_ ==  GL_RG) {
            colorSize = 2;
        }
        else if (data->format_ == GL_RED) {
            colorSize = 1;
        }

        int cWidth = 16 * colorSize;

        for (int x = 0; x < imgsX; x++) {
            for (int y = 0; y < imgsY; y++) {
                int gx = x * 16 * colorSize;
                int gy = y * 16 * data->width_ * colorSize;

                std::vector<uint8_t> buffer(16 * 16 * colorSize);

                for (int h = 0; h < 16; h++) {
                    memcpy(buffer.data() + (h * cWidth), data->data_ + (h * data->width_ * colorSize + gx + gy), cWidth);
                }

                AddData(buffer, data->format_, transparency, isSeeThrough);
            }
        }

        return true;
    }

    std::optional<RawTextureData> AddTextureToAtlas(std::string file, bool& transparency, bool& isSeeThrough) {
        std::optional<RawTextureData> data;
        RawTextureData tex = GetImageData(file.c_str());
        if (_AddTextureToAtlas(&tex, transparency, isSeeThrough)) {
            g_logger.LogInfo("TextureAtlas::AddTextureToAtlas", "Loaded: " + file + " | Size: " + std::to_string(tex.height_) + ", " + std::to_string(tex.width_));
            data = tex;
            return data;
        }
        g_logger.LogError("TextureAtlas::AddTextureToAtlas", "Unable to load: " + file);
        return data;
    }

    size_t GetBlockCount() {
        return count_;
    }

    std::vector<uint8_t> texture_atlas_data_;
    const int color_space_ = 4;
    bool is_transparent_ = false;
    size_t count_ = 0;

};
"./RenderEngine\\Window.cpp"
#include "Window.h"

#include <iostream>
#include <sstream>
#include <string>

#include "../Client/IO/KEY_CODE.h"

void APIENTRY Window::glDebugOutput(GLenum source, GLenum type, unsigned int id, GLenum severity, GLsizei length, const char* message, const void* userParam) {
    (void)userParam;
    std::stringstream str;

    if (id == 131169 || id == 131185 || id == 131218 || id == 131204) return;

    str << " (OPENGL) Debug message (" << id << "): " << message << " | ";

    switch (source)
    {
    case GL_DEBUG_SOURCE_API:             str << "Source: API"; break;
    case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   str << "Source: Window System"; break;
    case GL_DEBUG_SOURCE_SHADER_COMPILER: str << "Source: Shader Compiler"; break;
    case GL_DEBUG_SOURCE_THIRD_PARTY:     str << "Source: Third Party"; break;
    case GL_DEBUG_SOURCE_APPLICATION:     str << "Source: Application"; break;
    case GL_DEBUG_SOURCE_OTHER:           str << "Source: Other"; break;
    } str << " | ";

    switch (type)
    {
    case GL_DEBUG_TYPE_ERROR:               str << "Type: Error"; break;
    case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: str << "Type: Deprecated Behaviour"; break;
    case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  str << "Type: Undefined Behaviour"; break;
    case GL_DEBUG_TYPE_PORTABILITY:         str << "Type: Portability"; break;
    case GL_DEBUG_TYPE_PERFORMANCE:         str << "Type: Performance"; break;
    case GL_DEBUG_TYPE_MARKER:              str << "Type: Marker"; break;
    case GL_DEBUG_TYPE_PUSH_GROUP:          str << "Type: Push Group"; break;
    case GL_DEBUG_TYPE_POP_GROUP:           str << "Type: Pop Group"; break;
    case GL_DEBUG_TYPE_OTHER:               str << "Type: Other"; break;
    } str << " | ";

    switch (severity)
    {
    case GL_DEBUG_SEVERITY_HIGH:         str << "Severity: high"; break;
    case GL_DEBUG_SEVERITY_MEDIUM:       str << "Severity: medium"; break;
    case GL_DEBUG_SEVERITY_LOW:          str << "Severity: low"; break;
    case GL_DEBUG_SEVERITY_NOTIFICATION: str << "Severity: notification"; break;
    }

    str.seekg(0, std::ios::end);

    if (str.str().size() != 0) {
        g_logger.LogWarn("Window::glDebugOutput", str.str());
    }

}

GLFWwindow* Window::GetWindow() {
    return window_;
}

bool Window::WindowCloseCheck() {
    return glfwWindowShouldClose(window_);
}

void Window::Start() {

    if (properties_.initialized_) {
        g_logger.LogError("Window::Start","Already initialized");
        return;
    }

    glfwInit();
    if (!glfwInit())
    {
        g_logger.LogError("Window::Start", "Initialization Failed: GLFW");
        return;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    window_ = glfwCreateWindow(properties_.window_size_x_, properties_.window_size_y_, "1.2.0A (DEV)", NULL, NULL);

    glfwMakeContextCurrent(window_);

    if (window_ == nullptr)
    {
        g_logger.LogError("Window::Start", "Failed to create GLFW Window");

        glfwTerminate();
        return;
    }
    else {
        g_logger.LogInfo("Window::Start","Created GLFW Window");
    }

    glfwSetWindowUserPointer(window_, this);
    glfwSetFramebufferSizeCallback(window_, [](GLFWwindow* win, int a, int b) { static_cast<Window*>(glfwGetWindowUserPointer(win))->ResizeWindowCallback(a, b); });
    glfwSetCursorPosCallback(window_, +[](GLFWwindow* win, double a, double b) { static_cast<Window*>(glfwGetWindowUserPointer(win))->MousePositionCallback(a, b); });
    glfwSetMouseButtonCallback(window_, +[](GLFWwindow* win, int a, int b, int c) { static_cast<Window*>(glfwGetWindowUserPointer(win))->MouseButtonCallback(a, b); });
    glfwSetKeyCallback(window_, +[](GLFWwindow* win, int key, int scancode, int action, int mods) { static_cast<Window*>(glfwGetWindowUserPointer(win))->KeyboardCallback(win, key, scancode, action, mods); });
    glfwSetScrollCallback(window_, +[](GLFWwindow* win, double a, double b) { static_cast<Window*>(glfwGetWindowUserPointer(win))->ScrollCallback(win, a, b); });
    glewExperimental = GL_TRUE;
    glewInit();

    if (glewInit() != GLEW_OK) {
        g_logger.LogError("Window::Start", "Initialization Failed: GLEW");
        return;
    }

    std::stringstream str;
    str << "OpenGL Version: " << glGetString(GL_VERSION);
    g_logger.LogInfo("Window::Start", str.str());

    glEnable(GL_DEBUG_OUTPUT);
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
    glDebugMessageCallback(glDebugOutput, nullptr);
    glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    glfwSwapInterval(0);
}

void Window::MousePositionCallback(double xpos, double ypos) {
    inputs_.mouse_.displacement_ = glm::dvec2(xpos, ypos) - inputs_.mouse_.position_;
    inputs_.mouse_.position_ = glm::dvec2(xpos, ypos);
}

void Window::UpdateWindowName(std::string name) {
    glfwSetWindowTitle(window_, name.c_str());
}

void Window::RenderLines() {
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}


void Window::RenderSolid() {
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
}

void Window::ResizeWindowCallback(int x, int y) {
    glViewport(0, 0, x, y);
    properties_.window_size_x_ = x;
    properties_.window_size_y_ = y;
    properties_.window_size_dirty_ = true;

    g_logger.LogInfo("Window::ResizeWindowCallback"," Resized Window: " + std::to_string(x) + ", " + std::to_string(y));
}

void Window::ScrollCallback(GLFWwindow* win, double xOffset, double yOffset) {
    if (yOffset == -1.0) {
        inputs_.mouse_.scroll_direction_ = inputs_.mouse_.SCROLL_DOWN;
        return;
    }

    if (yOffset == 1.0) {
        inputs_.mouse_.scroll_direction_ = inputs_.mouse_.SCROLL_UP;
        return;
    }
    (void)xOffset;
    (void)win;
}

void Window::Refresh() {
    glfwSwapBuffers(window_);
}

void Window::PollInputs() {
    glfwPollEvents();
}

void Window::DisableCursor() {
    glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
}

void Window::EnableCursor() {
    glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
}

void Window::KeyboardCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (action == GLFW_RELEASE) {
        inputs_.ReleaseIndividualKey(key);
        return;
    }

    if ((action == GLFW_REPEAT) || (action == GLFW_PRESS)) { //prob irrelevant
        inputs_.PressIndividualKey(key);
    }
}

void Window::MouseButtonCallback(int button, int action) {
    if (button == GLFW_MOUSE_BUTTON_RIGHT)
    {
        if (action == GLFW_PRESS) {
            if (inputs_.mouse_.right_ == inputs_.mouse_.PRESS) {
                inputs_.mouse_.right_ = inputs_.mouse_.HOLD;
            }
            else {
                inputs_.mouse_.right_ = inputs_.mouse_.PRESS;
            }
            
        }
        else {
            inputs_.mouse_.right_ = inputs_.mouse_.RELEASE;
        }
        
    }
    if (button == GLFW_MOUSE_BUTTON_LEFT)
    {
        if (action == GLFW_PRESS) {
            if (inputs_.mouse_.left_ == inputs_.mouse_.PRESS) {
                inputs_.mouse_.left_ = inputs_.mouse_.HOLD;
            }
            else {
                inputs_.mouse_.left_ = inputs_.mouse_.PRESS;
            }

        }
        else {
            inputs_.mouse_.left_ = inputs_.mouse_.RELEASE;
        }
    }
    if (button == GLFW_MOUSE_BUTTON_MIDDLE)
    {
        if (action == GLFW_PRESS) {
            if (inputs_.mouse_.middle_ == inputs_.mouse_.PRESS) {
                inputs_.mouse_.middle_ = inputs_.mouse_.HOLD;
            }
            else {
                inputs_.mouse_.middle_ = inputs_.mouse_.PRESS;
            }

        }
        else {
            inputs_.mouse_.middle_ = inputs_.mouse_.RELEASE;
        }
    }
}
"./RenderEngine\\Window.h"
#pragma once

#include <gl/glew.h>
#include <GLFW/glfw3.h>
#include <glm/vec2.hpp>
#include "../Utils/LogUtils.h"
#include "../Client/IO/IO.h"
#include <vector>

#include "../Client/IO/IO.h"

struct WindowProperties {
    int window_size_x_ = 1280;
    int window_size_y_ = 720;

    bool window_size_dirty_ = false;
    bool initialized_ = false;
    bool draw_solid_ = true;
};

class Window {
public:
    void Start();
    void Refresh();
    void PollInputs();
    GLFWwindow* GetWindow();

protected:

    bool WindowCloseCheck();
    void DisableCursor();
    void EnableCursor();
    
    void UpdateWindowName(std::string name);

    void RenderSolid();
    void RenderLines();

    void MousePositionCallback(double xpos, double ypos);
    void MouseButtonCallback(int button, int action);
    void KeyboardCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    void ResizeWindowCallback(int x, int y);
    void ScrollCallback(GLFWwindow* win, double xoffset, double yoffset);

    UserInputs inputs_;
    WindowProperties properties_;
private:
    static void APIENTRY glDebugOutput(GLenum source, GLenum type, unsigned int id, GLenum severity, GLsizei length, const char* message, const void* userParam);
    
    GLFWwindow* window_ = nullptr;
};
"./Utils\\Clock.cpp"
#include <chrono>
#include "Clock.h"
#include <windows.h>    /* WinAPI */
#include <iostream>
#include <thread>
#include <chrono>



void precisePause(double nanoseconds) {
    double nanot_ = 0;
    auto t0 = std::chrono::high_resolution_clock::now();

    while (nanot_ <= nanoseconds) {
        std::chrono::duration<double, std::nano> nano = std::chrono::high_resolution_clock::now() - t0;
        nanot_ = nano.count();
    }
}

void timerSleep(double seconds) {

    static double estimate = 2e-3;
    static double mean = 2e-3;
    static double m2 = 0;
    static int64_t count = 1;

    while (seconds > estimate) {
        auto start = std::chrono::high_resolution_clock::now();
        timeBeginPeriod(1);
        std::this_thread::sleep_for(std::chrono::microseconds(1));
        timeEndPeriod(1);
        auto end = std::chrono::high_resolution_clock::now();

        double observed = (end - start).count() / 1e9;
        seconds -= observed;

        ++count;
        double delta = observed - mean;
        mean += delta / count;
        m2 += delta * (observed - mean);
        double stddev = sqrt(m2 / (count - 1));
        estimate = mean + stddev;
    }

    // spin lock
    auto start = std::chrono::high_resolution_clock::now();
    while ((std::chrono::high_resolution_clock::now() - start).count() / 1e9 < seconds);
}

void timerSleepNotPrecise(int milliseconds) {
    timeBeginPeriod(1);
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
    timeEndPeriod(1);
}
"./Utils\\Clock.h"
#pragma once
void precisePause(double nanoseconds);
void timerSleep(double seconds);
void timerSleepNotPrecise(int milliseconds);
"./Utils\\Containers\\BitStorage.cpp"
#include "BitStorage.h"


void BitStorage3D::Initialize(int x, int y, int z) { //Set Sizes
    int nBits = x * y * z;

    int mapsize = nBits >> 6;

    if (nBits & 0b111111) {
        mapsize++;
    }

    map_.resize(mapsize);
}

void BitStorage3D::ClearBit(int x, int y, int z) {
    int index = sx_ * (sy_ * sz_) + sy_ * (sz_)+sz_;

    size_t NumIndex = index >> 6;
    size_t Index = index & 0b111111;

    map_[NumIndex] &= (~(0b1LL << Index));
}

void BitStorage3D::Clear() {
    for (int i = 0; i < map_.size(); i++) {
        map_[i] = 0;
    }
}

void BitStorage3D::SetBit(int x, int y, int z) {
    int index = sx_ * (sy_ * sz_) + sy_ * (sz_)+sz_;

    size_t NumIndex = index >> 6;
    size_t Index = index & 0b111111;

    map_[NumIndex] |= (0b1LL << Index);
}

void BitStorage3D::SetBit(int* pos) {
    SetBit(pos[0], pos[1], pos[2]);
}

bool BitStorage3D::GetBit(int x, int y, int z) {
    int index = sx_ * (sy_ * sz_) + sy_ * (sz_)+sz_;

    size_t numIndex = index >> 6;
    size_t bitIndex = index & 0b111111;
    return (map_[numIndex] >> bitIndex) & 0b1;
}

bool BitStorage3D::GetBit(int* pos) {
    return GetBit(pos[0], pos[1], pos[2]);
}
"./Utils\\Containers\\BitStorage.h"
#pragma once
#include <vector>

class BitStorage3D {
public:
    void Initialize(int x, int y, int z);

    void SetBit(int x, int y, int z);

    void SetBit(int* pos);

    bool GetBit(int x, int y, int z);

    bool GetBit(int* pos);

    void ClearBit(int x, int y, int z);

    void Clear();
private:
    std::vector<uint64_t> map_;
    int sx_ = 0, sy_ = 0, sz_ = 0;
};
"./Utils\\Containers\\ConcurrentQueue.h"
#pragma once
#include <mutex>
#include <queue>

template <class T>
class ConcurrentQueue {
private:
    std::mutex mutex_;
    std::queue<T> queue_;
public:

    bool Empty() {
        std::unique_lock<std::mutex> lock{ mutex_ };
        return queue_.empty();
    }

    void PopAll(std::vector<T>& out) {
        std::unique_lock<std::mutex> lock{ mutex_ };
        while (!queue_.empty()) {
            out.push_back(std::move(queue_.front()));
            queue_.pop();
        }
    }

    T Pop() {
        std::unique_lock<std::mutex> lock{ mutex_ };
        T out = std::move(queue_.front());
        queue_.pop();
        return out;
    }

    void Push(T item) {
        std::unique_lock<std::mutex> lock{ mutex_ };
        queue_.push(std::move(item));
    }
};
"./Utils\\Containers\\FIFOQueue.h"
#pragma once
template <class T>
class FixedFIFOQueue {
public:
    FixedFIFOQueue();
    FixedFIFOQueue(uint64_t size);
    ~FixedFIFOQueue();

    FixedFIFOQueue(FixedFIFOQueue&& q) = delete;
    FixedFIFOQueue(const FixedFIFOQueue& q) = delete;

    void setSize(uint64_t size);
    void push(const T& obj);

    T get();
    void resetData();
    void clear();
    bool IsEmpty() const;
    bool IsFull() const;
    bool IsInitialized() const;
private:
    T* buffer_ = nullptr;
    bool is_initialized_ = false;

    uint64_t start_ptr_ = 0;
    uint64_t end_ptr_ = 0;
    uint64_t queue_size_ = 0;
    uint64_t element_count_ = 0;
};

template <class T>
inline FixedFIFOQueue<T>::FixedFIFOQueue() {}

template <class T>
inline FixedFIFOQueue<T>::~FixedFIFOQueue() {
    if (buffer_ != nullptr) delete[] buffer_;
}

template <class T>
inline FixedFIFOQueue<T>::FixedFIFOQueue(uint64_t size) {
    setSize(size); 
}

template <class T>
inline void FixedFIFOQueue<T>::setSize(uint64_t size) {
    if (is_initialized_) delete[] buffer_;
    queue_size_ = size;
    buffer_ = new T[queue_size_];
    is_initialized_ = true;
}

template <class T>
inline void FixedFIFOQueue<T>::push(const T& obj) {
    buffer_[end_ptr_++] = obj;
    end_ptr_ = end_ptr_ % queue_size_;
    ++element_count_;
}

template <class T>
inline T FixedFIFOQueue<T>::get() {
    T out = buffer_[start_ptr_++];
    start_ptr_ = start_ptr_ % queue_size_;
    --element_count_;
    return out;
}

template <class T>
inline void FixedFIFOQueue<T>::resetData() {
    start_ptr_ = 0;
    end_ptr_ = 0;
    element_count_ = 0;
}

template <class T>
inline void FixedFIFOQueue<T>::clear() {
    if (is_initialized_) delete[] buffer_;
    start_ptr_ = 0;
    end_ptr_ = 0;
    queue_size_ = 0;
    element_count_ = 0;
    is_initialized_ = false;
}

template <class T>
inline bool FixedFIFOQueue<T>::IsEmpty() const {
    return element_count_ <= 0;
}

template <class T>
inline bool FixedFIFOQueue<T>::IsFull() const {
    return element_count_ >= queue_size_;
}

template <class T>
inline bool FixedFIFOQueue<T>::IsInitialized() const {
    return is_initialized_;
}
"./Utils\\Containers\\N2BitVector.h"
#pragma once
#include <vector>
#include <stdexcept>
#include <exception>
// For sizes of base 2
template <typename StorageBit = unsigned long long>
class N2BitVector {
private:
    std::vector<StorageBit> data_;
    int bit_width_ = 0;
    int num_elements_ = 0;

    static constexpr const size_t storage_bits_ = sizeof(StorageBit) * 8;
    static constexpr const StorageBit all_ones_ = ~(static_cast<StorageBit>(0));
    StorageBit all_ones_bit_width_;

    StorageBit GetMask(int idx) const;

public:

    N2BitVector(int numElements, int bitWidth);
    N2BitVector(int bitWidth);
    ~N2BitVector();

    StorageBit Get(size_t idx) const;
    StorageBit GetUnsafe(size_t idx) const;
    template <typename T>
    void Append(T val);

    template <typename T>
    void Set(size_t idx, T val);
};

template<typename StorageBit>
template <typename T>
void N2BitVector<StorageBit>::Set(size_t idx, T val) {
    if (val >= (1 << bit_width_)) throw std::runtime_error("Invalid number. Wrong size");
    if (idx >= num_elements_) throw std::out_of_range("Index out of range");

    StorageBit data = static_cast<StorageBit>(val);

    size_t vectorIndex = bit_width_ * idx / storage_bits_;
    size_t integerIndex = (bit_width_ * idx) & (storage_bits_ - 1);

    StorageBit mask = GetMask(integerIndex);

    // Clear data first
    data_[vectorIndex] &= ~mask;
    data_[vectorIndex] |= data << integerIndex;
}

template<typename StorageBit>
StorageBit N2BitVector<StorageBit>::Get(size_t idx) const {
    if (idx >= num_elements_) throw std::out_of_range("Index out of range");
    return GetUnsafe(idx);
}

template<typename StorageBit>
StorageBit N2BitVector<StorageBit>::GetUnsafe(size_t idx) const {
    size_t vectorIndex = bit_width_ * idx / storage_bits_;
    size_t integerIndex = (bit_width_ * idx) & (storage_bits_ - 1);

    StorageBit mask = GetMask(integerIndex);

    return (data_[vectorIndex] & mask) >> integerIndex;
}

template<typename StorageBit>
N2BitVector<StorageBit>::N2BitVector(int numElements, int bitWidth) : bit_width_{ bitWidth }, num_elements_{ numElements } {
    if (bitWidth > storage_bits_) throw std::runtime_error("Bit width is too wide.");
    if ((bitWidth & (bitWidth - 1)) != 0) throw std::runtime_error("Bit width is not base 2");
    data_.resize(numElements * bitWidth / storage_bits_ + 1);
    all_ones_bit_width_ = ~(all_ones_ << bit_width_);
}

template<typename StorageBit>
N2BitVector<StorageBit>::N2BitVector(int bitWidth) : bit_width_{ bitWidth } {
    all_ones_bit_width_ = ~(all_ones_ << bit_width_);
}

template<typename StorageBit>
N2BitVector<StorageBit>::~N2BitVector() {
    data_.clear();
}

template<typename StorageBit>
template <typename T>
void N2BitVector<StorageBit>::Append(T val) {
    if (val >= (1 << bit_width_)) throw std::runtime_error("Invalid number. Wrong size");
    num_elements_++;
    if (num_elements_ * bit_width_ / storage_bits_ >= data_.size()) {
        data_.push_back(static_cast<StorageBit>(0));
    }

    Set(num_elements_ - 1, val);
}

template<typename StorageBit>
StorageBit N2BitVector<StorageBit>::GetMask(int integerIndex) const {
    return  all_ones_bit_width_ << integerIndex;
}
"./Utils\\Containers\\NBitVector.h"
#pragma once
#include <vector>
#include <stdexcept>
#include <exception>
// TODO: Add precomputed mask for all instances
template <typename StorageBit = unsigned long long>
class NBitVector {
private:
    std::vector<StorageBit> data_;
    int bit_width_ = 0;
    int num_elements_ = 0;

    static constexpr const size_t storage_bits_ = sizeof(StorageBit) * 8;
    static constexpr const StorageBit all_ones_ = ~(static_cast<StorageBit>(0));
    StorageBit all_ones_bit_width_;

    std::pair<StorageBit, StorageBit> GetMask(size_t idx) const;

public:

    NBitVector(int numElements, int bitWidth);
    NBitVector(int bitWidth);
    ~NBitVector();

    StorageBit Get(size_t idx) const;
    StorageBit GetUnsafe(size_t idx) const;
    template <typename T>
    void Append(T val);

    template <typename T>
    void Set(size_t idx, T val);
};

template<typename StorageBit>
template <typename T>
void NBitVector<StorageBit>::Set(size_t idx, T val) {
    if (static_cast<size_t>(val) >= (1ULL << bit_width_)) throw std::runtime_error("Invalid number. Wrong size");
    if (idx >= num_elements_) throw std::out_of_range("Index out of range");

    StorageBit data = static_cast<StorageBit>(val);

    size_t vectorIndex = bit_width_ * idx / storage_bits_;
    size_t integerIndex = (bit_width_ * idx) % storage_bits_;

    const auto [mask, overflowMask] = GetMask(integerIndex);

    // Clear data first
    data_[vectorIndex] &= ~mask;
    data_[vectorIndex] |= data << integerIndex;

    // Insert the left over if it overlaps

    if (overflowMask != 0) {
        data_[vectorIndex + 1] &= ~overflowMask;
        data_[vectorIndex + 1] |= data >> (storage_bits_ - integerIndex);
    }
}

template<typename StorageBit>
StorageBit NBitVector<StorageBit>::Get(size_t idx) const {
    if (idx >= num_elements_) throw std::out_of_range("Index out of range");
    return GetUnsafe(idx);
}

template<typename StorageBit>
StorageBit NBitVector<StorageBit>::GetUnsafe(size_t idx) const {
    size_t vectorIndex = bit_width_ * idx / storage_bits_;
    size_t integerIndex = (bit_width_ * idx) % storage_bits_;

    const auto [mask, overflowMask] = GetMask(integerIndex);

    StorageBit data = (data_[vectorIndex] & mask) >> integerIndex;;

    // If it overlap with the next bit extract the next bit too
    if (overflowMask != 0) {
        StorageBit dataNext = data_[vectorIndex + 1] & overflowMask;
        dataNext <<= (storage_bits_ - integerIndex);
        data |= dataNext;
    }

    return data;
}

template<typename StorageBit>
NBitVector<StorageBit>::NBitVector(int numElements, int bitWidth) : bit_width_{ bitWidth }, num_elements_{ numElements } {
    if (bitWidth > storage_bits_) throw std::runtime_error("Bit width is too wide.");
    data_.resize(numElements * bitWidth / storage_bits_ + 1);
    all_ones_bit_width_ = ~(all_ones_ << bit_width_);
}

template<typename StorageBit>
NBitVector<StorageBit>::NBitVector(int bitWidth) : bit_width_{ bitWidth } {
    all_ones_bit_width_ = ~(all_ones_ << bit_width_);
}

template<typename StorageBit>
NBitVector<StorageBit>::~NBitVector() {
    data_.clear();
}

template<typename StorageBit>
template <typename T>
void NBitVector<StorageBit>::Append(T val) {
    if (val >= (1 << bit_width_)) throw std::runtime_error("Invalid number. Wrong size");
    num_elements_++;
    if (num_elements_ * bit_width_ / storage_bits_ >= data_.size()) {
        data_.push_back(static_cast<StorageBit>(0));
    }

    Set(num_elements_ - 1, val);
}

template<typename StorageBit>
std::pair<StorageBit, StorageBit> NBitVector<StorageBit>::GetMask(size_t integerIndex) const {
    StorageBit mask = all_ones_bit_width_ << integerIndex;
    StorageBit overflowMask = 0;

    overflowMask |= (storage_bits_ - integerIndex < bit_width_) * (all_ones_bit_width_ >> (storage_bits_ - integerIndex));

    return { mask, overflowMask };
}
"./Utils\\Containers\\robin_hood.h"
//                 ______  _____                 ______                _________
//  ______________ ___  /_ ___(_)_______         ___  /_ ______ ______ ______  /
//  __  ___/_  __ \__  __ \__  / __  __ \        __  __ \_  __ \_  __ \_  __  /
//  _  /    / /_/ /_  /_/ /_  /  _  / / /        _  / / // /_/ // /_/ // /_/ /
//  /_/     \____/ /_.___/ /_/   /_/ /_/ ________/_/ /_/ \____/ \____/ \__,_/
//                                      _/_____/
//
// Fast & memory efficient hashtable based on robin hood hashing for C++11/14/17/20
// https://github.com/martinus/robin-hood-hashing
//
// Licensed under the MIT License <http://opensource.org/licenses/MIT>.
// SPDX-License-Identifier: MIT
// Copyright (c) 2018-2021 Martin Ankerl <http://martin.ankerl.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef ROBIN_HOOD_H_INCLUDED
#define ROBIN_HOOD_H_INCLUDED

// see https://semver.org/
#define ROBIN_HOOD_VERSION_MAJOR 3  // for incompatible API changes
#define ROBIN_HOOD_VERSION_MINOR 11 // for adding functionality in a backwards-compatible manner
#define ROBIN_HOOD_VERSION_PATCH 5  // for backwards-compatible bug fixes

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <limits>
#include <memory> // only to support hash of smart pointers
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>
#if __cplusplus >= 201703L
#    include <string_view>
#endif

// #define ROBIN_HOOD_LOG_ENABLED
#ifdef ROBIN_HOOD_LOG_ENABLED
#    include <iostream>
#    define ROBIN_HOOD_LOG(...) \
        std::cout << __FUNCTION__ << "@" << __LINE__ << ": " << __VA_ARGS__ << std::endl;
#else
#    define ROBIN_HOOD_LOG(x)
#endif

// #define ROBIN_HOOD_TRACE_ENABLED
#ifdef ROBIN_HOOD_TRACE_ENABLED
#    include <iostream>
#    define ROBIN_HOOD_TRACE(...) \
        std::cout << __FUNCTION__ << "@" << __LINE__ << ": " << __VA_ARGS__ << std::endl;
#else
#    define ROBIN_HOOD_TRACE(x)
#endif

// #define ROBIN_HOOD_COUNT_ENABLED
#ifdef ROBIN_HOOD_COUNT_ENABLED
#    include <iostream>
#    define ROBIN_HOOD_COUNT(x) ++counts().x;
namespace robin_hood {
    struct Counts {
        uint64_t shiftUp{};
        uint64_t shiftDown{};
    };
    inline std::ostream& operator<<(std::ostream& os, Counts const& c) {
        return os << c.shiftUp << " shiftUp" << std::endl << c.shiftDown << " shiftDown" << std::endl;
    }

    static Counts& counts() {
        static Counts counts{};
        return counts;
    }
} // namespace robin_hood
#else
#    define ROBIN_HOOD_COUNT(x)
#endif

// all non-argument macros should use this facility. See
// https://www.fluentcpp.com/2019/05/28/better-macros-better-flags/
#define ROBIN_HOOD(x) ROBIN_HOOD_PRIVATE_DEFINITION_##x()

// mark unused members with this macro
#define ROBIN_HOOD_UNUSED(identifier)

// bitness
#if SIZE_MAX == UINT32_MAX
#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 32
#elif SIZE_MAX == UINT64_MAX
#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 64
#else
#    error Unsupported bitness
#endif

// endianess
#ifdef _MSC_VER
#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() 1
#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() 0
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() \
        (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#endif

// inline
#ifdef _MSC_VER
#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __declspec(noinline)
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __attribute__((noinline))
#endif

// exceptions
#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)
#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 0
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 1
#endif

// count leading/trailing bits
#if !defined(ROBIN_HOOD_DISABLE_INTRINSICS)
#    ifdef _MSC_VER
#        if ROBIN_HOOD(BITNESS) == 32
#            define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward
#        else
#            define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward64
#        endif
#        include <intrin.h>
#        pragma intrinsic(ROBIN_HOOD(BITSCANFORWARD))
#        define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x)                                       \
            [](size_t mask) noexcept -> int {                                             \
                unsigned long index;                                                      \
                return ROBIN_HOOD(BITSCANFORWARD)(&index, mask) ? static_cast<int>(index) \
                                                                : ROBIN_HOOD(BITNESS);    \
            }(x)
#    else
#        if ROBIN_HOOD(BITNESS) == 32
#            define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzl
#            define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzl
#        else
#            define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzll
#            define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzll
#        endif
#        define ROBIN_HOOD_COUNT_LEADING_ZEROES(x) ((x) ? ROBIN_HOOD(CLZ)(x) : ROBIN_HOOD(BITNESS))
#        define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x) ((x) ? ROBIN_HOOD(CTZ)(x) : ROBIN_HOOD(BITNESS))
#    endif
#endif

// fallthrough
#ifndef __has_cpp_attribute // For backwards compatibility
#    define __has_cpp_attribute(x) 0
#endif
#if __has_cpp_attribute(clang::fallthrough)
#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[clang::fallthrough]]
#elif __has_cpp_attribute(gnu::fallthrough)
#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[gnu::fallthrough]]
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH()
#endif

// likely/unlikely
#ifdef _MSC_VER
#    define ROBIN_HOOD_LIKELY(condition) condition
#    define ROBIN_HOOD_UNLIKELY(condition) condition
#else
#    define ROBIN_HOOD_LIKELY(condition) __builtin_expect(condition, 1)
#    define ROBIN_HOOD_UNLIKELY(condition) __builtin_expect(condition, 0)
#endif

// detect if native wchar_t type is availiable in MSVC
#ifdef _MSC_VER
#    ifdef _NATIVE_WCHAR_T_DEFINED
#        define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 1
#    else
#        define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 0
#    endif
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 1
#endif

// detect if MSVC supports the pair(std::piecewise_construct_t,...) consructor being constexpr
#ifdef _MSC_VER
#    if _MSC_VER <= 1900
#        define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 1
#    else
#        define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 0
#    endif
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 0
#endif

// workaround missing "is_trivially_copyable" in g++ < 5.0
// See https://stackoverflow.com/a/31798726/48181
#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)
#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)
#else
#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value
#endif

// helpers for C++ versions, see https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html
#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX() __cplusplus
#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX98() 199711L
#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX11() 201103L
#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX14() 201402L
#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX17() 201703L

#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX17)
#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD() [[nodiscard]]
#else
#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD()
#endif

namespace robin_hood {

#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)
#    define ROBIN_HOOD_STD std
#else

    // c++11 compatibility layer
    namespace ROBIN_HOOD_STD {
        template <class T>
        struct alignment_of
            : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {
        };

        template <class T, T... Ints>
        class integer_sequence {
        public:
            using value_type = T;
            static_assert(std::is_integral<value_type>::value, "not integral type");
            static constexpr std::size_t size() noexcept {
                return sizeof...(Ints);
            }
        };
        template <std::size_t... Inds>
        using index_sequence = integer_sequence<std::size_t, Inds...>;

        namespace detail_ {
            template <class T, T Begin, T End, bool>
            struct IntSeqImpl {
                using TValue = T;
                static_assert(std::is_integral<TValue>::value, "not integral type");
                static_assert(Begin >= 0 && Begin < End, "unexpected argument (Begin<0 || Begin<=End)");

                template <class, class>
                struct IntSeqCombiner;

                template <TValue... Inds0, TValue... Inds1>
                struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {
                    using TResult = integer_sequence<TValue, Inds0..., Inds1...>;
                };

                using TResult =
                    typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,
                    (End - Begin) / 2 == 1>::TResult,
                    typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,
                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;
            };

            template <class T, T Begin>
            struct IntSeqImpl<T, Begin, Begin, false> {
                using TValue = T;
                static_assert(std::is_integral<TValue>::value, "not integral type");
                static_assert(Begin >= 0, "unexpected argument (Begin<0)");
                using TResult = integer_sequence<TValue>;
            };

            template <class T, T Begin, T End>
            struct IntSeqImpl<T, Begin, End, true> {
                using TValue = T;
                static_assert(std::is_integral<TValue>::value, "not integral type");
                static_assert(Begin >= 0, "unexpected argument (Begin<0)");
                using TResult = integer_sequence<TValue, Begin>;
            };
        } // namespace detail_

        template <class T, T N>
        using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;

        template <std::size_t N>
        using make_index_sequence = make_integer_sequence<std::size_t, N>;

        template <class... T>
        using index_sequence_for = make_index_sequence<sizeof...(T)>;

    } // namespace ROBIN_HOOD_STD

#endif

    namespace detail {

        // make sure we static_cast to the correct type for hash_int
#if ROBIN_HOOD(BITNESS) == 64
        using SizeT = uint64_t;
#else
        using SizeT = uint32_t;
#endif

        template <typename T>
        T rotr(T x, unsigned k) {
            return (x >> k) | (x << (8U * sizeof(T) - k));
        }

        // This cast gets rid of warnings like "cast from 'uint8_t*' {aka 'unsigned char*'} to
        // 'uint64_t*' {aka 'long unsigned int*'} increases required alignment of target type". Use with
        // care!
        template <typename T>
        inline T reinterpret_cast_no_cast_align_warning(void* ptr) noexcept {
            return reinterpret_cast<T>(ptr);
        }

        template <typename T>
        inline T reinterpret_cast_no_cast_align_warning(void const* ptr) noexcept {
            return reinterpret_cast<T>(ptr);
        }

        // make sure this is not inlined as it is slow and dramatically enlarges code, thus making other
        // inlinings more difficult. Throws are also generally the slow path.
        template <typename E, typename... Args>
        [[noreturn]] ROBIN_HOOD(NOINLINE)
#if ROBIN_HOOD(HAS_EXCEPTIONS)
            void doThrow(Args&&... args) {
            // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
            throw E(std::forward<Args>(args)...);
        }
#else
            void doThrow(Args&&... ROBIN_HOOD_UNUSED(args) /*unused*/) {
            abort();
        }
#endif

        template <typename E, typename T, typename... Args>
        T* assertNotNull(T* t, Args&&... args) {
            if (ROBIN_HOOD_UNLIKELY(nullptr == t)) {
                doThrow<E>(std::forward<Args>(args)...);
            }
            return t;
        }

        template <typename T>
        inline T unaligned_load(void const* ptr) noexcept {
            // using memcpy so we don't get into unaligned load problems.
            // compiler should optimize this very well anyways.
            T t;
            std::memcpy(&t, ptr, sizeof(T));
            return t;
        }

        // Allocates bulks of memory for objects of type T. This deallocates the memory in the destructor,
        // and keeps a linked list of the allocated memory around. Overhead per allocation is the size of a
        // pointer.
        template <typename T, size_t MinNumAllocs = 4, size_t MaxNumAllocs = 256>
        class BulkPoolAllocator {
        public:
            BulkPoolAllocator() noexcept = default;

            // does not copy anything, just creates a new allocator.
            BulkPoolAllocator(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept
                : mHead(nullptr)
                , mListForFree(nullptr) {
            }

            BulkPoolAllocator(BulkPoolAllocator&& o) noexcept
                : mHead(o.mHead)
                , mListForFree(o.mListForFree) {
                o.mListForFree = nullptr;
                o.mHead = nullptr;
            }

            BulkPoolAllocator& operator=(BulkPoolAllocator&& o) noexcept {
                reset();
                mHead = o.mHead;
                mListForFree = o.mListForFree;
                o.mListForFree = nullptr;
                o.mHead = nullptr;
                return *this;
            }

            BulkPoolAllocator&
                // NOLINTNEXTLINE(bugprone-unhandled-self-assignment,cert-oop54-cpp)
                operator=(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept {
                // does not do anything
                return *this;
            }

            ~BulkPoolAllocator() noexcept {
                reset();
            }

            // Deallocates all allocated memory.
            void reset() noexcept {
                while (mListForFree) {
                    T* tmp = *mListForFree;
                    ROBIN_HOOD_LOG("std::free")
                        std::free(mListForFree);
                    mListForFree = reinterpret_cast_no_cast_align_warning<T**>(tmp);
                }
                mHead = nullptr;
            }

            // allocates, but does NOT initialize. Use in-place new constructor, e.g.
            //   T* obj = pool.allocate();
            //   ::new (static_cast<void*>(obj)) T();
            T* allocate() {
                T* tmp = mHead;
                if (!tmp) {
                    tmp = performAllocation();
                }

                mHead = *reinterpret_cast_no_cast_align_warning<T**>(tmp);
                return tmp;
            }

            // does not actually deallocate but puts it in store.
            // make sure you have already called the destructor! e.g. with
            //  obj->~T();
            //  pool.deallocate(obj);
            void deallocate(T* obj) noexcept {
                *reinterpret_cast_no_cast_align_warning<T**>(obj) = mHead;
                mHead = obj;
            }

            // Adds an already allocated block of memory to the allocator. This allocator is from now on
            // responsible for freeing the data (with free()). If the provided data is not large enough to
            // make use of, it is immediately freed. Otherwise it is reused and freed in the destructor.
            void addOrFree(void* ptr, const size_t numBytes) noexcept {
                // calculate number of available elements in ptr
                if (numBytes < ALIGNMENT + ALIGNED_SIZE) {
                    // not enough data for at least one element. Free and return.
                    ROBIN_HOOD_LOG("std::free")
                        std::free(ptr);
                }
                else {
                    ROBIN_HOOD_LOG("add to buffer")
                        add(ptr, numBytes);
                }
            }

            void swap(BulkPoolAllocator<T, MinNumAllocs, MaxNumAllocs>& other) noexcept {
                using std::swap;
                swap(mHead, other.mHead);
                swap(mListForFree, other.mListForFree);
            }

        private:
            // iterates the list of allocated memory to calculate how many to alloc next.
            // Recalculating this each time saves us a size_t member.
            // This ignores the fact that memory blocks might have been added manually with addOrFree. In
            // practice, this should not matter much.
            ROBIN_HOOD(NODISCARD) size_t calcNumElementsToAlloc() const noexcept {
                auto tmp = mListForFree;
                size_t numAllocs = MinNumAllocs;

                while (numAllocs * 2 <= MaxNumAllocs && tmp) {
                    auto x = reinterpret_cast<T***>(tmp);
                    tmp = *x;
                    numAllocs *= 2;
                }

                return numAllocs;
            }

            // WARNING: Underflow if numBytes < ALIGNMENT! This is guarded in addOrFree().
            void add(void* ptr, const size_t numBytes) noexcept {
                const size_t numElements = (numBytes - ALIGNMENT) / ALIGNED_SIZE;

                auto data = reinterpret_cast<T**>(ptr);

                // link free list
                auto x = reinterpret_cast<T***>(data);
                *x = mListForFree;
                mListForFree = data;

                // create linked list for newly allocated data
                auto* const headT =
                    reinterpret_cast_no_cast_align_warning<T*>(reinterpret_cast<char*>(ptr) + ALIGNMENT);

                auto* const head = reinterpret_cast<char*>(headT);

                // Visual Studio compiler automatically unrolls this loop, which is pretty cool
                for (size_t i = 0; i < numElements; ++i) {
                    *reinterpret_cast_no_cast_align_warning<char**>(head + i * ALIGNED_SIZE) =
                        head + (i + 1) * ALIGNED_SIZE;
                }

                // last one points to 0
                *reinterpret_cast_no_cast_align_warning<T**>(head + (numElements - 1) * ALIGNED_SIZE) =
                    mHead;
                mHead = headT;
            }

            // Called when no memory is available (mHead == 0).
            // Don't inline this slow path.
            ROBIN_HOOD(NOINLINE) T* performAllocation() {
                size_t const numElementsToAlloc = calcNumElementsToAlloc();

                // alloc new memory: [prev |T, T, ... T]
                size_t const bytes = ALIGNMENT + ALIGNED_SIZE * numElementsToAlloc;
                ROBIN_HOOD_LOG("std::malloc " << bytes << " = " << ALIGNMENT << " + " << ALIGNED_SIZE
                    << " * " << numElementsToAlloc)
                    add(assertNotNull<std::bad_alloc>(std::malloc(bytes)), bytes);
                return mHead;
            }

            // enforce byte alignment of the T's
#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)
            static constexpr size_t ALIGNMENT =
                (std::max)(std::alignment_of<T>::value, std::alignment_of<T*>::value);
#else
            static const size_t ALIGNMENT =
                (ROBIN_HOOD_STD::alignment_of<T>::value > ROBIN_HOOD_STD::alignment_of<T*>::value)
                ? ROBIN_HOOD_STD::alignment_of<T>::value
                : +ROBIN_HOOD_STD::alignment_of<T*>::value; // the + is for walkarround
#endif

            static constexpr size_t ALIGNED_SIZE = ((sizeof(T) - 1) / ALIGNMENT + 1) * ALIGNMENT;

            static_assert(MinNumAllocs >= 1, "MinNumAllocs");
            static_assert(MaxNumAllocs >= MinNumAllocs, "MaxNumAllocs");
            static_assert(ALIGNED_SIZE >= sizeof(T*), "ALIGNED_SIZE");
            static_assert(0 == (ALIGNED_SIZE % sizeof(T*)), "ALIGNED_SIZE mod");
            static_assert(ALIGNMENT >= sizeof(T*), "ALIGNMENT");

            T* mHead{ nullptr };
            T** mListForFree{ nullptr };
        };

        template <typename T, size_t MinSize, size_t MaxSize, bool IsFlat>
        struct NodeAllocator;

        // dummy allocator that does nothing
        template <typename T, size_t MinSize, size_t MaxSize>
        struct NodeAllocator<T, MinSize, MaxSize, true> {

            // we are not using the data, so just free it.
            void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {
                ROBIN_HOOD_LOG("std::free")
                    std::free(ptr);
            }
        };

        template <typename T, size_t MinSize, size_t MaxSize>
        struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};

        // c++14 doesn't have is_nothrow_swappable, and clang++ 6.0.1 doesn't like it either, so I'm making
        // my own here.
        namespace swappable {
#if ROBIN_HOOD(CXX) < ROBIN_HOOD(CXX17)
            using std::swap;
            template <typename T>
            struct nothrow {
                static const bool value = noexcept(swap(std::declval<T&>(), std::declval<T&>()));
            };
#else
            template <typename T>
            struct nothrow {
                static const bool value = std::is_nothrow_swappable<T>::value;
            };
#endif
        } // namespace swappable

    } // namespace detail

    struct is_transparent_tag {};

    // A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,
    // which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is
    // also tested.
    template <typename T1, typename T2>
    struct pair {
        using first_type = T1;
        using second_type = T2;

        template <typename U1 = T1, typename U2 = T2,
            typename = typename std::enable_if<std::is_default_constructible<U1>::value&&
            std::is_default_constructible<U2>::value>::type>
        constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))
            : first()
            , second() {
        }

        // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.
        explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(
            noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))
            : first(o.first)
            , second(o.second) {
        }

        // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.
        explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(noexcept(
            T1(std::move(std::declval<T1&&>()))) && noexcept(T2(std::move(std::declval<T2&&>()))))
            : first(std::move(o.first))
            , second(std::move(o.second)) {
        }

        constexpr pair(T1&& a, T2&& b) noexcept(noexcept(
            T1(std::move(std::declval<T1&&>()))) && noexcept(T2(std::move(std::declval<T2&&>()))))
            : first(std::move(a))
            , second(std::move(b)) {
        }

        template <typename U1, typename U2>
        constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(
            std::declval<U1&&>()))) && noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))
            : first(std::forward<U1>(a))
            , second(std::forward<U2>(b)) {
        }

        template <typename... U1, typename... U2>
        // MSVC 2015 produces error "C2476: constexpr constructor does not initialize all members"
        // if this constructor is constexpr
#if !ROBIN_HOOD(BROKEN_CONSTEXPR)
        constexpr
#endif
            pair(std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,
                std::tuple<U2...>
                b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),
                    std::declval<std::tuple<U2...>&>(),
                    ROBIN_HOOD_STD::index_sequence_for<U1...>(),
                    ROBIN_HOOD_STD::index_sequence_for<U2...>())))
            : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),
                ROBIN_HOOD_STD::index_sequence_for<U2...>()) {
        }

        // constructor called from the std::piecewise_construct_t ctor
        template <typename... U1, size_t... I1, typename... U2, size_t... I2>
        pair(std::tuple<U1...>& a, std::tuple<U2...>& b, ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/, ROBIN_HOOD_STD::index_sequence<I2...> /*unused*/) noexcept(
            noexcept(T1(std::forward<U1>(std::get<I1>(
                std::declval<std::tuple<
                U1...>&>()))...)) && noexcept(T2(std::
                    forward<U2>(std::get<I2>(
                        std::declval<std::tuple<U2...>&>()))...)))
            : first(std::forward<U1>(std::get<I1>(a))...)
            , second(std::forward<U2>(std::get<I2>(b))...) {
            // make visual studio compiler happy about warning about unused a & b.
            // Visual studio's pair implementation disables warning 4100.
            (void)a;
            (void)b;
        }

        void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&
            (detail::swappable::nothrow<T2>::value)) {
            using std::swap;
            swap(first, o.first);
            swap(second, o.second);
        }

        T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)
        T2 second; // NOLINT(misc-non-private-member-variables-in-classes)
    };

    template <typename A, typename B>
    inline void swap(pair<A, B>& a, pair<A, B>& b) noexcept(
        noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {
        a.swap(b);
    }

    template <typename A, typename B>
    inline constexpr bool operator==(pair<A, B> const& x, pair<A, B> const& y) {
        return (x.first == y.first) && (x.second == y.second);
    }
    template <typename A, typename B>
    inline constexpr bool operator!=(pair<A, B> const& x, pair<A, B> const& y) {
        return !(x == y);
    }
    template <typename A, typename B>
    inline constexpr bool operator<(pair<A, B> const& x, pair<A, B> const& y) noexcept(noexcept(
        std::declval<A const&>() < std::declval<A const&>()) && noexcept(std::declval<B const&>() <
            std::declval<B const&>())) {
        return x.first < y.first || (!(y.first < x.first) && x.second < y.second);
    }
    template <typename A, typename B>
    inline constexpr bool operator>(pair<A, B> const& x, pair<A, B> const& y) {
        return y < x;
    }
    template <typename A, typename B>
    inline constexpr bool operator<=(pair<A, B> const& x, pair<A, B> const& y) {
        return !(x > y);
    }
    template <typename A, typename B>
    inline constexpr bool operator>=(pair<A, B> const& x, pair<A, B> const& y) {
        return !(x < y);
    }

    inline size_t hash_bytes(void const* ptr, size_t len) noexcept {
        static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);
        static constexpr uint64_t seed = UINT64_C(0xe17a1465);
        static constexpr unsigned int r = 47;

        auto const* const data64 = static_cast<uint64_t const*>(ptr);
        uint64_t h = seed ^ (len * m);

        size_t const n_blocks = len / 8;
        for (size_t i = 0; i < n_blocks; ++i) {
            auto k = detail::unaligned_load<uint64_t>(data64 + i);

            k *= m;
            k ^= k >> r;
            k *= m;

            h ^= k;
            h *= m;
        }

        auto const* const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);
        switch (len & 7U) {
        case 7:
            h ^= static_cast<uint64_t>(data8[6]) << 48U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 6:
            h ^= static_cast<uint64_t>(data8[5]) << 40U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 5:
            h ^= static_cast<uint64_t>(data8[4]) << 32U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 4:
            h ^= static_cast<uint64_t>(data8[3]) << 24U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 3:
            h ^= static_cast<uint64_t>(data8[2]) << 16U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 2:
            h ^= static_cast<uint64_t>(data8[1]) << 8U;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        case 1:
            h ^= static_cast<uint64_t>(data8[0]);
            h *= m;
            ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH
        default:
            break;
        }

        h ^= h >> r;

        // not doing the final step here, because this will be done by keyToIdx anyways
        // h *= m;
        // h ^= h >> r;
        return static_cast<size_t>(h);
    }

    inline size_t hash_int(uint64_t x) noexcept {
        // tried lots of different hashes, let's stick with murmurhash3. It's simple, fast, well tested,
        // and doesn't need any special 128bit operations.
        x ^= x >> 33U;
        x *= UINT64_C(0xff51afd7ed558ccd);
        x ^= x >> 33U;

        // not doing the final step here, because this will be done by keyToIdx anyways
        // x *= UINT64_C(0xc4ceb9fe1a85ec53);
        // x ^= x >> 33U;
        return static_cast<size_t>(x);
    }

    // A thin wrapper around std::hash, performing an additional simple mixing step of the result.
    template <typename T, typename Enable = void>
    struct hash : public std::hash<T> {
        size_t operator()(T const& obj) const
            noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {
            // call base hash
            auto result = std::hash<T>::operator()(obj);
            // return mixed of that, to be save against identity has
            return hash_int(static_cast<detail::SizeT>(result));
        }
    };

    template <typename CharT>
    struct hash<std::basic_string<CharT>> {
        size_t operator()(std::basic_string<CharT> const& str) const noexcept {
            return hash_bytes(str.data(), sizeof(CharT) * str.size());
        }
    };

#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX17)
    template <typename CharT>
    struct hash<std::basic_string_view<CharT>> {
        size_t operator()(std::basic_string_view<CharT> const& sv) const noexcept {
            return hash_bytes(sv.data(), sizeof(CharT) * sv.size());
        }
    };
#endif

    template <class T>
    struct hash<T*> {
        size_t operator()(T* ptr) const noexcept {
            return hash_int(reinterpret_cast<detail::SizeT>(ptr));
        }
    };

    template <class T>
    struct hash<std::unique_ptr<T>> {
        size_t operator()(std::unique_ptr<T> const& ptr) const noexcept {
            return hash_int(reinterpret_cast<detail::SizeT>(ptr.get()));
        }
    };

    template <class T>
    struct hash<std::shared_ptr<T>> {
        size_t operator()(std::shared_ptr<T> const& ptr) const noexcept {
            return hash_int(reinterpret_cast<detail::SizeT>(ptr.get()));
        }
    };

    template <typename Enum>
    struct hash<Enum, typename std::enable_if<std::is_enum<Enum>::value>::type> {
        size_t operator()(Enum e) const noexcept {
            using Underlying = typename std::underlying_type<Enum>::type;
            return hash<Underlying>{}(static_cast<Underlying>(e));
        }
    };

#define ROBIN_HOOD_HASH_INT(T)                           \
    template <>                                          \
    struct hash<T> {                                     \
        size_t operator()(T const& obj) const noexcept { \
            return hash_int(static_cast<uint64_t>(obj)); \
        }                                                \
    }

#if defined(__GNUC__) && !defined(__clang__)
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wuseless-cast"
#endif
    // see https://en.cppreference.com/w/cpp/utility/hash
    ROBIN_HOOD_HASH_INT(bool);
    ROBIN_HOOD_HASH_INT(char);
    ROBIN_HOOD_HASH_INT(signed char);
    ROBIN_HOOD_HASH_INT(unsigned char);
    ROBIN_HOOD_HASH_INT(char16_t);
    ROBIN_HOOD_HASH_INT(char32_t);
#if ROBIN_HOOD(HAS_NATIVE_WCHART)
    ROBIN_HOOD_HASH_INT(wchar_t);
#endif
    ROBIN_HOOD_HASH_INT(short);
    ROBIN_HOOD_HASH_INT(unsigned short);
    ROBIN_HOOD_HASH_INT(int);
    ROBIN_HOOD_HASH_INT(unsigned int);
    ROBIN_HOOD_HASH_INT(long);
    ROBIN_HOOD_HASH_INT(long long);
    ROBIN_HOOD_HASH_INT(unsigned long);
    ROBIN_HOOD_HASH_INT(unsigned long long);
#if defined(__GNUC__) && !defined(__clang__)
#    pragma GCC diagnostic pop
#endif
    namespace detail {

        template <typename T>
        struct void_type {
            using type = void;
        };

        template <typename T, typename = void>
        struct has_is_transparent : public std::false_type {};

        template <typename T>
        struct has_is_transparent<T, typename void_type<typename T::is_transparent>::type>
            : public std::true_type {
        };

        // using wrapper classes for hash and key_equal prevents the diamond problem when the same type
        // is used. see https://stackoverflow.com/a/28771920/48181
        template <typename T>
        struct WrapHash : public T {
            WrapHash() = default;
            explicit WrapHash(T const& o) noexcept(noexcept(T(std::declval<T const&>())))
                : T(o) {
            }
        };

        template <typename T>
        struct WrapKeyEqual : public T {
            WrapKeyEqual() = default;
            explicit WrapKeyEqual(T const& o) noexcept(noexcept(T(std::declval<T const&>())))
                : T(o) {
            }
        };

        // A highly optimized hashmap implementation, using the Robin Hood algorithm.
        //
        // In most cases, this map should be usable as a drop-in replacement for std::unordered_map, but
        // be about 2x faster in most cases and require much less allocations.
        //
        // This implementation uses the following memory layout:
        //
        // [Node, Node, ... Node | info, info, ... infoSentinel ]
        //
        // * Node: either a DataNode that directly has the std::pair<key, val> as member,
        //   or a DataNode with a pointer to std::pair<key,val>. Which DataNode representation to use
        //   depends on how fast the swap() operation is. Heuristically, this is automatically choosen
        //   based on sizeof(). there are always 2^n Nodes.
        //
        // * info: Each Node in the map has a corresponding info byte, so there are 2^n info bytes.
        //   Each byte is initialized to 0, meaning the corresponding Node is empty. Set to 1 means the
        //   corresponding node contains data. Set to 2 means the corresponding Node is filled, but it
        //   actually belongs to the previous position and was pushed out because that place is already
        //   taken.
        //
        // * infoSentinel: Sentinel byte set to 1, so that iterator's ++ can stop at end() without the
        //   need for a idx variable.
        //
        // According to STL, order of templates has effect on throughput. That's why I've moved the
        // boolean to the front.
        // https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/
        template <bool IsFlat, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,
            typename KeyEqual>
        class Table
            : public WrapHash<Hash>,
            public WrapKeyEqual<KeyEqual>,
            detail::NodeAllocator<
            typename std::conditional<
            std::is_void<T>::value, Key,
            robin_hood::pair<typename std::conditional<IsFlat, Key, Key const>::type, T>>::type,
            4, 16384, IsFlat> {
        public:
            static constexpr bool is_flat = IsFlat;
            static constexpr bool is_map = !std::is_void<T>::value;
            static constexpr bool is_set = !is_map;
            static constexpr bool is_transparent =
                has_is_transparent<Hash>::value && has_is_transparent<KeyEqual>::value;

            using key_type = Key;
            using mapped_type = T;
            using value_type = typename std::conditional<
                is_set, Key,
                robin_hood::pair<typename std::conditional<is_flat, Key, Key const>::type, T>>::type;
            using size_type = size_t;
            using hasher = Hash;
            using key_equal = KeyEqual;
            using Self = Table<IsFlat, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;

        private:
            static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,
                "MaxLoadFactor100 needs to be >10 && < 100");

            using WHash = WrapHash<Hash>;
            using WKeyEqual = WrapKeyEqual<KeyEqual>;

            // configuration defaults

            // make sure we have 8 elements, needed to quickly rehash mInfo
            static constexpr size_t InitialNumElements = sizeof(uint64_t);
            static constexpr uint32_t InitialInfoNumBits = 5;
            static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;
            static constexpr size_t InfoMask = InitialInfoInc - 1U;
            static constexpr uint8_t InitialInfoHashShift = 0;
            using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlat>;

            // type needs to be wider than uint8_t.
            using InfoType = uint32_t;

            // DataNode ////////////////////////////////////////////////////////

            // Primary template for the data node. We have special implementations for small and big
            // objects. For large objects it is assumed that swap() is fairly slow, so we allocate these
            // on the heap so swap merely swaps a pointer.
            template <typename M, bool>
            class DataNode {};

            // Small: just allocate on the stack.
            template <typename M>
            class DataNode<M, true> final {
            public:
                template <typename... Args>
                explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(
                    noexcept(value_type(std::forward<Args>(args)...)))
                    : mData(std::forward<Args>(args)...) {
                }

                DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(
                    std::is_nothrow_move_constructible<value_type>::value)
                    : mData(std::move(n.mData)) {
                }

                // doesn't do anything
                void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}
                void destroyDoNotDeallocate() noexcept {}

                value_type const* operator->() const noexcept {
                    return &mData;
                }
                value_type* operator->() noexcept {
                    return &mData;
                }

                const value_type& operator*() const noexcept {
                    return mData;
                }

                value_type& operator*() noexcept {
                    return mData;
                }

                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, typename VT::first_type&>::type getFirst() noexcept {
                    return mData.first;
                }
                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_set, VT&>::type getFirst() noexcept {
                    return mData;
                }

                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, typename VT::first_type const&>::type
                    getFirst() const noexcept {
                    return mData.first;
                }
                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_set, VT const&>::type getFirst() const noexcept {
                    return mData;
                }

                template <typename MT = mapped_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, MT&>::type getSecond() noexcept {
                    return mData.second;
                }

                template <typename MT = mapped_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_set, MT const&>::type getSecond() const noexcept {
                    return mData.second;
                }

                void swap(DataNode<M, true>& o) noexcept(
                    noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {
                    mData.swap(o.mData);
                }

            private:
                value_type mData;
            };

            // big object: allocate on heap.
            template <typename M>
            class DataNode<M, false> {
            public:
                template <typename... Args>
                explicit DataNode(M& map, Args&&... args)
                    : mData(map.allocate()) {
                    ::new (static_cast<void*>(mData)) value_type(std::forward<Args>(args)...);
                }

                DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, false>&& n) noexcept
                    : mData(std::move(n.mData)) {
                }

                void destroy(M& map) noexcept {
                    // don't deallocate, just put it into list of datapool.
                    mData->~value_type();
                    map.deallocate(mData);
                }

                void destroyDoNotDeallocate() noexcept {
                    mData->~value_type();
                }

                value_type const* operator->() const noexcept {
                    return mData;
                }

                value_type* operator->() noexcept {
                    return mData;
                }

                const value_type& operator*() const {
                    return *mData;
                }

                value_type& operator*() {
                    return *mData;
                }

                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, typename VT::first_type&>::type getFirst() noexcept {
                    return mData->first;
                }
                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_set, VT&>::type getFirst() noexcept {
                    return *mData;
                }

                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, typename VT::first_type const&>::type
                    getFirst() const noexcept {
                    return mData->first;
                }
                template <typename VT = value_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_set, VT const&>::type getFirst() const noexcept {
                    return *mData;
                }

                template <typename MT = mapped_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, MT&>::type getSecond() noexcept {
                    return mData->second;
                }

                template <typename MT = mapped_type>
                ROBIN_HOOD(NODISCARD)
                    typename std::enable_if<is_map, MT const&>::type getSecond() const noexcept {
                    return mData->second;
                }

                void swap(DataNode<M, false>& o) noexcept {
                    using std::swap;
                    swap(mData, o.mData);
                }

            private:
                value_type* mData;
            };

            using Node = DataNode<Self, IsFlat>;

            // helpers for insertKeyPrepareEmptySpot: extract first entry (only const required)
            ROBIN_HOOD(NODISCARD) key_type const& getFirstConst(Node const& n) const noexcept {
                return n.getFirst();
            }

            // in case we have void mapped_type, we are not using a pair, thus we just route k through.
            // No need to disable this because it's just not used if not applicable.
            ROBIN_HOOD(NODISCARD) key_type const& getFirstConst(key_type const& k) const noexcept {
                return k;
            }

            // in case we have non-void mapped_type, we have a standard robin_hood::pair
            template <typename Q = mapped_type>
            ROBIN_HOOD(NODISCARD)
                typename std::enable_if<!std::is_void<Q>::value, key_type const&>::type
                getFirstConst(value_type const& vt) const noexcept {
                return vt.first;
            }

            // Cloner //////////////////////////////////////////////////////////

            template <typename M, bool UseMemcpy>
            struct Cloner;

            // fast path: Just copy data, without allocating anything.
            template <typename M>
            struct Cloner<M, true> {
                void operator()(M const& source, M& target) const {
                    auto const* const src = reinterpret_cast<char const*>(source.mKeyVals);
                    auto* tgt = reinterpret_cast<char*>(target.mKeyVals);
                    auto const numElementsWithBuffer = target.calcNumElementsWithBuffer(target.mMask + 1);
                    std::copy(src, src + target.calcNumBytesTotal(numElementsWithBuffer), tgt);
                }
            };

            template <typename M>
            struct Cloner<M, false> {
                void operator()(M const& s, M& t) const {
                    auto const numElementsWithBuffer = t.calcNumElementsWithBuffer(t.mMask + 1);
                    std::copy(s.mInfo, s.mInfo + t.calcNumBytesInfo(numElementsWithBuffer), t.mInfo);

                    for (size_t i = 0; i < numElementsWithBuffer; ++i) {
                        if (t.mInfo[i]) {
                            ::new (static_cast<void*>(t.mKeyVals + i)) Node(t, *s.mKeyVals[i]);
                        }
                    }
                }
            };

            // Destroyer ///////////////////////////////////////////////////////

            template <typename M, bool IsFlatAndTrivial>
            struct Destroyer {};

            template <typename M>
            struct Destroyer<M, true> {
                void nodes(M& m) const noexcept {
                    m.mNumElements = 0;
                }

                void nodesDoNotDeallocate(M& m) const noexcept {
                    m.mNumElements = 0;
                }
            };

            template <typename M>
            struct Destroyer<M, false> {
                void nodes(M& m) const noexcept {
                    m.mNumElements = 0;
                    // clear also resets mInfo to 0, that's sometimes not necessary.
                    auto const numElementsWithBuffer = m.calcNumElementsWithBuffer(m.mMask + 1);

                    for (size_t idx = 0; idx < numElementsWithBuffer; ++idx) {
                        if (0 != m.mInfo[idx]) {
                            Node& n = m.mKeyVals[idx];
                            n.destroy(m);
                            n.~Node();
                        }
                    }
                }

                void nodesDoNotDeallocate(M& m) const noexcept {
                    m.mNumElements = 0;
                    // clear also resets mInfo to 0, that's sometimes not necessary.
                    auto const numElementsWithBuffer = m.calcNumElementsWithBuffer(m.mMask + 1);
                    for (size_t idx = 0; idx < numElementsWithBuffer; ++idx) {
                        if (0 != m.mInfo[idx]) {
                            Node& n = m.mKeyVals[idx];
                            n.destroyDoNotDeallocate();
                            n.~Node();
                        }
                    }
                }
            };

            // Iter ////////////////////////////////////////////////////////////

            struct fast_forward_tag {};

            // generic iterator for both const_iterator and iterator.
            template <bool IsConst>
            // NOLINTNEXTLINE(hicpp-special-member-functions,cppcoreguidelines-special-member-functions)
            class Iter {
            private:
                using NodePtr = typename std::conditional<IsConst, Node const*, Node*>::type;

            public:
                using difference_type = std::ptrdiff_t;
                using value_type = typename Self::value_type;
                using reference = typename std::conditional<IsConst, value_type const&, value_type&>::type;
                using pointer = typename std::conditional<IsConst, value_type const*, value_type*>::type;
                using iterator_category = std::forward_iterator_tag;

                // default constructed iterator can be compared to itself, but WON'T return true when
                // compared to end().
                Iter() = default;

                // Rule of zero: nothing specified. The conversion constructor is only enabled for
                // iterator to const_iterator, so it doesn't accidentally work as a copy ctor.

                // Conversion constructor from iterator to const_iterator.
                template <bool OtherIsConst,
                    typename = typename std::enable_if<IsConst && !OtherIsConst>::type>
                // NOLINTNEXTLINE(hicpp-explicit-conversions)
                Iter(Iter<OtherIsConst> const& other) noexcept
                    : mKeyVals(other.mKeyVals)
                    , mInfo(other.mInfo) {
                }

                Iter(NodePtr valPtr, uint8_t const* infoPtr) noexcept
                    : mKeyVals(valPtr)
                    , mInfo(infoPtr) {
                }

                Iter(NodePtr valPtr, uint8_t const* infoPtr,
                    fast_forward_tag ROBIN_HOOD_UNUSED(tag) /*unused*/) noexcept
                    : mKeyVals(valPtr)
                    , mInfo(infoPtr) {
                    fastForward();
                }

                template <bool OtherIsConst,
                    typename = typename std::enable_if<IsConst && !OtherIsConst>::type>
                Iter& operator=(Iter<OtherIsConst> const& other) noexcept {
                    mKeyVals = other.mKeyVals;
                    mInfo = other.mInfo;
                    return *this;
                }

                // prefix increment. Undefined behavior if we are at end()!
                Iter& operator++() noexcept {
                    mInfo++;
                    mKeyVals++;
                    fastForward();
                    return *this;
                }

                Iter operator++(int) noexcept {
                    Iter tmp = *this;
                    ++(*this);
                    return tmp;
                }

                reference operator*() const {
                    return **mKeyVals;
                }

                pointer operator->() const {
                    return &**mKeyVals;
                }

                template <bool O>
                bool operator==(Iter<O> const& o) const noexcept {
                    return mKeyVals == o.mKeyVals;
                }

                template <bool O>
                bool operator!=(Iter<O> const& o) const noexcept {
                    return mKeyVals != o.mKeyVals;
                }

            private:
                // fast forward to the next non-free info byte
                // I've tried a few variants that don't depend on intrinsics, but unfortunately they are
                // quite a bit slower than this one. So I've reverted that change again. See map_benchmark.
                void fastForward() noexcept {
                    size_t n = 0;
                    while (0U == (n = detail::unaligned_load<size_t>(mInfo))) {
                        mInfo += sizeof(size_t);
                        mKeyVals += sizeof(size_t);
                    }
#if defined(ROBIN_HOOD_DISABLE_INTRINSICS)
                    // we know for certain that within the next 8 bytes we'll find a non-zero one.
                    if (ROBIN_HOOD_UNLIKELY(0U == detail::unaligned_load<uint32_t>(mInfo))) {
                        mInfo += 4;
                        mKeyVals += 4;
                    }
                    if (ROBIN_HOOD_UNLIKELY(0U == detail::unaligned_load<uint16_t>(mInfo))) {
                        mInfo += 2;
                        mKeyVals += 2;
                    }
                    if (ROBIN_HOOD_UNLIKELY(0U == *mInfo)) {
                        mInfo += 1;
                        mKeyVals += 1;
                    }
#else
#    if ROBIN_HOOD(LITTLE_ENDIAN)
                    auto inc = ROBIN_HOOD_COUNT_TRAILING_ZEROES(n) / 8;
#    else
                    auto inc = ROBIN_HOOD_COUNT_LEADING_ZEROES(n) / 8;
#    endif
                    mInfo += inc;
                    mKeyVals += inc;
#endif
                }

                friend class Table<IsFlat, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;
                NodePtr mKeyVals{ nullptr };
                uint8_t const* mInfo{ nullptr };
            };

            ////////////////////////////////////////////////////////////////////

            // highly performance relevant code.
            // Lower bits are used for indexing into the array (2^n size)
            // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.
            template <typename HashKey>
            void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {
                // In addition to whatever hash is used, add another mul & shift so we get better hashing.
                // This serves as a bad hash prevention, if the given data is
                // badly mixed.
                auto h = static_cast<uint64_t>(WHash::operator()(key));

                h *= mHashMultiplier;
                h ^= h >> 33U;

                // the lower InitialInfoNumBits are reserved for info.
                *info = mInfoInc + static_cast<InfoType>((h & InfoMask) >> mInfoHashShift);
                *idx = (static_cast<size_t>(h) >> InitialInfoNumBits) & mMask;
            }

            // forwards the index by one, wrapping around at the end
            void next(InfoType* info, size_t* idx) const noexcept {
                *idx = *idx + 1;
                *info += mInfoInc;
            }

            void nextWhileLess(InfoType* info, size_t* idx) const noexcept {
                // unrolling this by hand did not bring any speedups.
                while (*info < mInfo[*idx]) {
                    next(info, idx);
                }
            }

            // Shift everything up by one element. Tries to move stuff around.
            void
                shiftUp(size_t startIdx,
                    size_t const insertion_idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {
                auto idx = startIdx;
                ::new (static_cast<void*>(mKeyVals + idx)) Node(std::move(mKeyVals[idx - 1]));
                while (--idx != insertion_idx) {
                    mKeyVals[idx] = std::move(mKeyVals[idx - 1]);
                }

                idx = startIdx;
                while (idx != insertion_idx) {
                    ROBIN_HOOD_COUNT(shiftUp)
                        mInfo[idx] = static_cast<uint8_t>(mInfo[idx - 1] + mInfoInc);
                    if (ROBIN_HOOD_UNLIKELY(mInfo[idx] + mInfoInc > 0xFF)) {
                        mMaxNumElementsAllowed = 0;
                    }
                    --idx;
                }
            }

            void shiftDown(size_t idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {
                // until we find one that is either empty or has zero offset.
                // TODO(martinus) we don't need to move everything, just the last one for the same
                // bucket.
                mKeyVals[idx].destroy(*this);

                // until we find one that is either empty or has zero offset.
                while (mInfo[idx + 1] >= 2 * mInfoInc) {
                    ROBIN_HOOD_COUNT(shiftDown)
                        mInfo[idx] = static_cast<uint8_t>(mInfo[idx + 1] - mInfoInc);
                    mKeyVals[idx] = std::move(mKeyVals[idx + 1]);
                    ++idx;
                }

                mInfo[idx] = 0;
                // don't destroy, we've moved it
                // mKeyVals[idx].destroy(*this);
                mKeyVals[idx].~Node();
            }

            // copy of find(), except that it returns iterator instead of const_iterator.
            template <typename Other>
            ROBIN_HOOD(NODISCARD)
                size_t findIdx(Other const& key) const {
                size_t idx{};
                InfoType info{};
                keyToIdx(key, &idx, &info);

                do {
                    // unrolling this twice gives a bit of a speedup. More unrolling did not help.
                    if (info == mInfo[idx] &&
                        ROBIN_HOOD_LIKELY(WKeyEqual::operator()(key, mKeyVals[idx].getFirst()))) {
                        return idx;
                    }
                    next(&info, &idx);
                    if (info == mInfo[idx] &&
                        ROBIN_HOOD_LIKELY(WKeyEqual::operator()(key, mKeyVals[idx].getFirst()))) {
                        return idx;
                    }
                    next(&info, &idx);
                } while (info <= mInfo[idx]);

                // nothing found!
                return mMask == 0 ? 0
                    : static_cast<size_t>(std::distance(
                        mKeyVals, reinterpret_cast_no_cast_align_warning<Node*>(mInfo)));
            }

            void cloneData(const Table& o) {
                Cloner<Table, IsFlat&& ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);
            }

            // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.
            // @return True on success, false if something went wrong
            void insert_move(Node&& keyval) {
                // we don't retry, fail if overflowing
                // don't need to check max num elements
                if (0 == mMaxNumElementsAllowed && !try_increase_info()) {
                    throwOverflowError();
                }

                size_t idx{};
                InfoType info{};
                keyToIdx(keyval.getFirst(), &idx, &info);

                // skip forward. Use <= because we are certain that the element is not there.
                while (info <= mInfo[idx]) {
                    idx = idx + 1;
                    info += mInfoInc;
                }

                // key not found, so we are now exactly where we want to insert it.
                auto const insertion_idx = idx;
                auto const insertion_info = static_cast<uint8_t>(info);
                if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {
                    mMaxNumElementsAllowed = 0;
                }

                // find an empty spot
                while (0 != mInfo[idx]) {
                    next(&info, &idx);
                }

                auto& l = mKeyVals[insertion_idx];
                if (idx == insertion_idx) {
                    ::new (static_cast<void*>(&l)) Node(std::move(keyval));
                }
                else {
                    shiftUp(idx, insertion_idx);
                    l = std::move(keyval);
                }

                // put at empty spot
                mInfo[insertion_idx] = insertion_info;

                ++mNumElements;
            }

        public:
            using iterator = Iter<false>;
            using const_iterator = Iter<true>;

            Table() noexcept(noexcept(Hash()) && noexcept(KeyEqual()))
                : WHash()
                , WKeyEqual() {
                ROBIN_HOOD_TRACE(this)
            }

            // Creates an empty hash map. Nothing is allocated yet, this happens at the first insert.
            // This tremendously speeds up ctor & dtor of a map that never receives an element. The
            // penalty is payed at the first insert, and not before. Lookup of this empty map works
            // because everybody points to DummyInfoByte::b. parameter bucket_count is dictated by the
            // standard, but we can ignore it.
            explicit Table(
                size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/, const Hash& h = Hash{},
                const KeyEqual& equal = KeyEqual{}) noexcept(noexcept(Hash(h)) && noexcept(KeyEqual(equal)))
                : WHash(h)
                , WKeyEqual(equal) {
                ROBIN_HOOD_TRACE(this)
            }

            template <typename Iter>
            Table(Iter first, Iter last, size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,
                const Hash& h = Hash{}, const KeyEqual& equal = KeyEqual{})
                : WHash(h)
                , WKeyEqual(equal) {
                ROBIN_HOOD_TRACE(this)
                    insert(first, last);
            }

            Table(std::initializer_list<value_type> initlist,
                size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0, const Hash& h = Hash{},
                const KeyEqual& equal = KeyEqual{})
                : WHash(h)
                , WKeyEqual(equal) {
                ROBIN_HOOD_TRACE(this)
                    insert(initlist.begin(), initlist.end());
            }

            Table(Table&& o) noexcept
                : WHash(std::move(static_cast<WHash&>(o)))
                , WKeyEqual(std::move(static_cast<WKeyEqual&>(o)))
                , DataPool(std::move(static_cast<DataPool&>(o))) {
                ROBIN_HOOD_TRACE(this)
                    if (o.mMask) {
                        mHashMultiplier = std::move(o.mHashMultiplier);
                        mKeyVals = std::move(o.mKeyVals);
                        mInfo = std::move(o.mInfo);
                        mNumElements = std::move(o.mNumElements);
                        mMask = std::move(o.mMask);
                        mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);
                        mInfoInc = std::move(o.mInfoInc);
                        mInfoHashShift = std::move(o.mInfoHashShift);
                        // set other's mask to 0 so its destructor won't do anything
                        o.init();
                    }
            }

            Table& operator=(Table&& o) noexcept {
                ROBIN_HOOD_TRACE(this)
                    if (&o != this) {
                        if (o.mMask) {
                            // only move stuff if the other map actually has some data
                            destroy();
                            mHashMultiplier = std::move(o.mHashMultiplier);
                            mKeyVals = std::move(o.mKeyVals);
                            mInfo = std::move(o.mInfo);
                            mNumElements = std::move(o.mNumElements);
                            mMask = std::move(o.mMask);
                            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);
                            mInfoInc = std::move(o.mInfoInc);
                            mInfoHashShift = std::move(o.mInfoHashShift);
                            WHash::operator=(std::move(static_cast<WHash&>(o)));
                            WKeyEqual::operator=(std::move(static_cast<WKeyEqual&>(o)));
                            DataPool::operator=(std::move(static_cast<DataPool&>(o)));

                            o.init();

                        }
                        else {
                            // nothing in the other map => just clear us.
                            clear();
                        }
                    }
                return *this;
            }

            Table(const Table& o)
                : WHash(static_cast<const WHash&>(o))
                , WKeyEqual(static_cast<const WKeyEqual&>(o))
                , DataPool(static_cast<const DataPool&>(o)) {
                ROBIN_HOOD_TRACE(this)
                    if (!o.empty()) {
                        // not empty: create an exact copy. it is also possible to just iterate through all
                        // elements and insert them, but copying is probably faster.

                        auto const numElementsWithBuffer = calcNumElementsWithBuffer(o.mMask + 1);
                        auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);

                        ROBIN_HOOD_LOG("std::malloc " << numBytesTotal << " = calcNumBytesTotal("
                            << numElementsWithBuffer << ")")
                            mHashMultiplier = o.mHashMultiplier;
                        mKeyVals = static_cast<Node*>(
                            detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));
                        // no need for calloc because clonData does memcpy
                        mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
                        mNumElements = o.mNumElements;
                        mMask = o.mMask;
                        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;
                        mInfoInc = o.mInfoInc;
                        mInfoHashShift = o.mInfoHashShift;
                        cloneData(o);
                    }
            }

            // Creates a copy of the given map. Copy constructor of each entry is used.
            // Not sure why clang-tidy thinks this doesn't handle self assignment, it does
            // NOLINTNEXTLINE(bugprone-unhandled-self-assignment,cert-oop54-cpp)
            Table& operator=(Table const& o) {
                ROBIN_HOOD_TRACE(this)
                    if (&o == this) {
                        // prevent assigning of itself
                        return *this;
                    }

                // we keep using the old allocator and not assign the new one, because we want to keep
                // the memory available. when it is the same size.
                if (o.empty()) {
                    if (0 == mMask) {
                        // nothing to do, we are empty too
                        return *this;
                    }

                    // not empty: destroy what we have there
                    // clear also resets mInfo to 0, that's sometimes not necessary.
                    destroy();
                    init();
                    WHash::operator=(static_cast<const WHash&>(o));
                    WKeyEqual::operator=(static_cast<const WKeyEqual&>(o));
                    DataPool::operator=(static_cast<DataPool const&>(o));

                    return *this;
                }

                // clean up old stuff
                Destroyer<Self, IsFlat&& std::is_trivially_destructible<Node>::value>{}.nodes(*this);

                if (mMask != o.mMask) {
                    // no luck: we don't have the same array size allocated, so we need to realloc.
                    if (0 != mMask) {
                        // only deallocate if we actually have data!
                        ROBIN_HOOD_LOG("std::free")
                            std::free(mKeyVals);
                    }

                    auto const numElementsWithBuffer = calcNumElementsWithBuffer(o.mMask + 1);
                    auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);
                    ROBIN_HOOD_LOG("std::malloc " << numBytesTotal << " = calcNumBytesTotal("
                        << numElementsWithBuffer << ")")
                        mKeyVals = static_cast<Node*>(
                            detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));

                    // no need for calloc here because cloneData performs a memcpy.
                    mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
                    // sentinel is set in cloneData
                }
                WHash::operator=(static_cast<const WHash&>(o));
                WKeyEqual::operator=(static_cast<const WKeyEqual&>(o));
                DataPool::operator=(static_cast<DataPool const&>(o));
                mHashMultiplier = o.mHashMultiplier;
                mNumElements = o.mNumElements;
                mMask = o.mMask;
                mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;
                mInfoInc = o.mInfoInc;
                mInfoHashShift = o.mInfoHashShift;
                cloneData(o);

                return *this;
            }

            // Swaps everything between the two maps.
            void swap(Table& o) {
                ROBIN_HOOD_TRACE(this)
                    using std::swap;
                swap(o, *this);
            }

            // Clears all data, without resizing.
            void clear() {
                ROBIN_HOOD_TRACE(this)
                    if (empty()) {
                        // don't do anything! also important because we don't want to write to
                        // DummyInfoByte::b, even though we would just write 0 to it.
                        return;
                    }

                Destroyer<Self, IsFlat&& std::is_trivially_destructible<Node>::value>{}.nodes(*this);

                auto const numElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);
                // clear everything, then set the sentinel again
                uint8_t const z = 0;
                std::fill(mInfo, mInfo + calcNumBytesInfo(numElementsWithBuffer), z);
                mInfo[numElementsWithBuffer] = 1;

                mInfoInc = InitialInfoInc;
                mInfoHashShift = InitialInfoHashShift;
            }

            // Destroys the map and all it's contents.
            ~Table() {
                ROBIN_HOOD_TRACE(this)
                    destroy();
            }

            // Checks if both tables contain the same entries. Order is irrelevant.
            bool operator==(const Table& other) const {
                ROBIN_HOOD_TRACE(this)
                    if (other.size() != size()) {
                        return false;
                    }
                for (auto const& otherEntry : other) {
                    if (!has(otherEntry)) {
                        return false;
                    }
                }

                return true;
            }

            bool operator!=(const Table& other) const {
                ROBIN_HOOD_TRACE(this)
                    return !operator==(other);
            }

            template <typename Q = mapped_type>
            typename std::enable_if<!std::is_void<Q>::value, Q&>::type operator[](const key_type& key) {
                ROBIN_HOOD_TRACE(this)
                    auto idxAndState = insertKeyPrepareEmptySpot(key);
                switch (idxAndState.second) {
                case InsertionState::key_found:
                    break;

                case InsertionState::new_node:
                    ::new (static_cast<void*>(&mKeyVals[idxAndState.first]))
                        Node(*this, std::piecewise_construct, std::forward_as_tuple(key),
                            std::forward_as_tuple());
                    break;

                case InsertionState::overwrite_node:
                    mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,
                        std::forward_as_tuple(key), std::forward_as_tuple());
                    break;

                case InsertionState::overflow_error:
                    throwOverflowError();
                }

                return mKeyVals[idxAndState.first].getSecond();
            }

            template <typename Q = mapped_type>
            typename std::enable_if<!std::is_void<Q>::value, Q&>::type operator[](key_type&& key) {
                ROBIN_HOOD_TRACE(this)
                    auto idxAndState = insertKeyPrepareEmptySpot(key);
                switch (idxAndState.second) {
                case InsertionState::key_found:
                    break;

                case InsertionState::new_node:
                    ::new (static_cast<void*>(&mKeyVals[idxAndState.first]))
                        Node(*this, std::piecewise_construct, std::forward_as_tuple(std::move(key)),
                            std::forward_as_tuple());
                    break;

                case InsertionState::overwrite_node:
                    mKeyVals[idxAndState.first] =
                        Node(*this, std::piecewise_construct, std::forward_as_tuple(std::move(key)),
                            std::forward_as_tuple());
                    break;

                case InsertionState::overflow_error:
                    throwOverflowError();
                }

                return mKeyVals[idxAndState.first].getSecond();
            }

            template <typename Iter>
            void insert(Iter first, Iter last) {
                for (; first != last; ++first) {
                    // value_type ctor needed because this might be called with std::pair's
                    insert(value_type(*first));
                }
            }

            void insert(std::initializer_list<value_type> ilist) {
                for (auto&& vt : ilist) {
                    insert(std::move(vt));
                }
            }

            template <typename... Args>
            std::pair<iterator, bool> emplace(Args&&... args) {
                ROBIN_HOOD_TRACE(this)
                    Node n{ *this, std::forward<Args>(args)... };
                auto idxAndState = insertKeyPrepareEmptySpot(getFirstConst(n));
                switch (idxAndState.second) {
                case InsertionState::key_found:
                    n.destroy(*this);
                    break;

                case InsertionState::new_node:
                    ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(*this, std::move(n));
                    break;

                case InsertionState::overwrite_node:
                    mKeyVals[idxAndState.first] = std::move(n);
                    break;

                case InsertionState::overflow_error:
                    n.destroy(*this);
                    throwOverflowError();
                    break;
                }

                return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),
                    InsertionState::key_found != idxAndState.second);
            }

            template <typename... Args>
            iterator emplace_hint(const_iterator position, Args&&... args) {
                (void)position;
                return emplace(std::forward<Args>(args)...).first;
            }

            template <typename... Args>
            std::pair<iterator, bool> try_emplace(const key_type& key, Args&&... args) {
                return try_emplace_impl(key, std::forward<Args>(args)...);
            }

            template <typename... Args>
            std::pair<iterator, bool> try_emplace(key_type&& key, Args&&... args) {
                return try_emplace_impl(std::move(key), std::forward<Args>(args)...);
            }

            template <typename... Args>
            iterator try_emplace(const_iterator hint, const key_type& key, Args&&... args) {
                (void)hint;
                return try_emplace_impl(key, std::forward<Args>(args)...).first;
            }

            template <typename... Args>
            iterator try_emplace(const_iterator hint, key_type&& key, Args&&... args) {
                (void)hint;
                return try_emplace_impl(std::move(key), std::forward<Args>(args)...).first;
            }

            template <typename Mapped>
            std::pair<iterator, bool> insert_or_assign(const key_type& key, Mapped&& obj) {
                return insertOrAssignImpl(key, std::forward<Mapped>(obj));
            }

            template <typename Mapped>
            std::pair<iterator, bool> insert_or_assign(key_type&& key, Mapped&& obj) {
                return insertOrAssignImpl(std::move(key), std::forward<Mapped>(obj));
            }

            template <typename Mapped>
            iterator insert_or_assign(const_iterator hint, const key_type& key, Mapped&& obj) {
                (void)hint;
                return insertOrAssignImpl(key, std::forward<Mapped>(obj)).first;
            }

            template <typename Mapped>
            iterator insert_or_assign(const_iterator hint, key_type&& key, Mapped&& obj) {
                (void)hint;
                return insertOrAssignImpl(std::move(key), std::forward<Mapped>(obj)).first;
            }

            std::pair<iterator, bool> insert(const value_type& keyval) {
                ROBIN_HOOD_TRACE(this)
                    return emplace(keyval);
            }

            iterator insert(const_iterator hint, const value_type& keyval) {
                (void)hint;
                return emplace(keyval).first;
            }

            std::pair<iterator, bool> insert(value_type&& keyval) {
                return emplace(std::move(keyval));
            }

            iterator insert(const_iterator hint, value_type&& keyval) {
                (void)hint;
                return emplace(std::move(keyval)).first;
            }

            // Returns 1 if key is found, 0 otherwise.
            size_t count(const key_type& key) const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    auto kv = mKeyVals + findIdx(key);
                if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {
                    return 1;
                }
                return 0;
            }

            template <typename OtherKey, typename Self_ = Self>
            // NOLINTNEXTLINE(modernize-use-nodiscard)
            typename std::enable_if<Self_::is_transparent, size_t>::type count(const OtherKey& key) const {
                ROBIN_HOOD_TRACE(this)
                    auto kv = mKeyVals + findIdx(key);
                if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {
                    return 1;
                }
                return 0;
            }

            bool contains(const key_type& key) const { // NOLINT(modernize-use-nodiscard)
                return 1U == count(key);
            }

            template <typename OtherKey, typename Self_ = Self>
            // NOLINTNEXTLINE(modernize-use-nodiscard)
            typename std::enable_if<Self_::is_transparent, bool>::type contains(const OtherKey& key) const {
                return 1U == count(key);
            }

            // Returns a reference to the value found for key.
            // Throws std::out_of_range if element cannot be found
            template <typename Q = mapped_type>
            // NOLINTNEXTLINE(modernize-use-nodiscard)
            typename std::enable_if<!std::is_void<Q>::value, Q&>::type at(key_type const& key) {
                ROBIN_HOOD_TRACE(this)
                    auto kv = mKeyVals + findIdx(key);
                if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {
                    doThrow<std::out_of_range>("key not found");
                }
                return kv->getSecond();
            }

            // Returns a reference to the value found for key.
            // Throws std::out_of_range if element cannot be found
            template <typename Q = mapped_type>
            // NOLINTNEXTLINE(modernize-use-nodiscard)
            typename std::enable_if<!std::is_void<Q>::value, Q const&>::type at(key_type const& key) const {
                ROBIN_HOOD_TRACE(this)
                    auto kv = mKeyVals + findIdx(key);
                if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {
                    doThrow<std::out_of_range>("key not found");
                }
                return kv->getSecond();
            }

            const_iterator find(const key_type& key) const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return const_iterator{ mKeyVals + idx, mInfo + idx };
            }

            template <typename OtherKey>
            const_iterator find(const OtherKey& key, is_transparent_tag /*unused*/) const {
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return const_iterator{ mKeyVals + idx, mInfo + idx };
            }

            template <typename OtherKey, typename Self_ = Self>
            typename std::enable_if<Self_::is_transparent, // NOLINT(modernize-use-nodiscard)
                const_iterator>::type  // NOLINT(modernize-use-nodiscard)
                find(const OtherKey& key) const {              // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return const_iterator{ mKeyVals + idx, mInfo + idx };
            }

            iterator find(const key_type& key) {
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return iterator{ mKeyVals + idx, mInfo + idx };
            }

            template <typename OtherKey>
            iterator find(const OtherKey& key, is_transparent_tag /*unused*/) {
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return iterator{ mKeyVals + idx, mInfo + idx };
            }

            template <typename OtherKey, typename Self_ = Self>
            typename std::enable_if<Self_::is_transparent, iterator>::type find(const OtherKey& key) {
                ROBIN_HOOD_TRACE(this)
                    const size_t idx = findIdx(key);
                return iterator{ mKeyVals + idx, mInfo + idx };
            }

            iterator begin() {
                ROBIN_HOOD_TRACE(this)
                    if (empty()) {
                        return end();
                    }
                return iterator(mKeyVals, mInfo, fast_forward_tag{});
            }
            const_iterator begin() const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return cbegin();
            }
            const_iterator cbegin() const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    if (empty()) {
                        return cend();
                    }
                return const_iterator(mKeyVals, mInfo, fast_forward_tag{});
            }

            iterator end() {
                ROBIN_HOOD_TRACE(this)
                    // no need to supply valid info pointer: end() must not be dereferenced, and only node
                    // pointer is compared.
                    return iterator{ reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr };
            }
            const_iterator end() const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return cend();
            }
            const_iterator cend() const { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return const_iterator{ reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr };
            }

            iterator erase(const_iterator pos) {
                ROBIN_HOOD_TRACE(this)
                    // its safe to perform const cast here
                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-const-cast)
                    return erase(iterator{ const_cast<Node*>(pos.mKeyVals), const_cast<uint8_t*>(pos.mInfo) });
            }

            // Erases element at pos, returns iterator to the next element.
            iterator erase(iterator pos) {
                ROBIN_HOOD_TRACE(this)
                    // we assume that pos always points to a valid entry, and not end().
                    auto const idx = static_cast<size_t>(pos.mKeyVals - mKeyVals);

                shiftDown(idx);
                --mNumElements;

                if (*pos.mInfo) {
                    // we've backward shifted, return this again
                    return pos;
                }

                // no backward shift, return next element
                return ++pos;
            }

            size_t erase(const key_type& key) {
                ROBIN_HOOD_TRACE(this)
                    size_t idx{};
                InfoType info{};
                keyToIdx(key, &idx, &info);

                // check while info matches with the source idx
                do {
                    if (info == mInfo[idx] && WKeyEqual::operator()(key, mKeyVals[idx].getFirst())) {
                        shiftDown(idx);
                        --mNumElements;
                        return 1;
                    }
                    next(&info, &idx);
                } while (info <= mInfo[idx]);

                // nothing found to delete
                return 0;
            }

            // reserves space for the specified number of elements. Makes sure the old data fits.
            // exactly the same as reserve(c).
            void rehash(size_t c) {
                // forces a reserve
                reserve(c, true);
            }

            // reserves space for the specified number of elements. Makes sure the old data fits.
            // Exactly the same as rehash(c). Use rehash(0) to shrink to fit.
            void reserve(size_t c) {
                // reserve, but don't force rehash
                reserve(c, false);
            }

            // If possible reallocates the map to a smaller one. This frees the underlying table.
            // Does not do anything if load_factor is too large for decreasing the table's size.
            void compact() {
                ROBIN_HOOD_TRACE(this)
                    auto newSize = InitialNumElements;
                while (calcMaxNumElementsAllowed(newSize) < mNumElements && newSize != 0) {
                    newSize *= 2;
                }
                if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {
                    throwOverflowError();
                }

                ROBIN_HOOD_LOG("newSize > mMask + 1: " << newSize << " > " << mMask << " + 1")

                    // only actually do anything when the new size is bigger than the old one. This prevents to
                    // continuously allocate for each reserve() call.
                    if (newSize < mMask + 1) {
                        rehashPowerOfTwo(newSize, true);
                    }
            }

            size_type size() const noexcept { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return mNumElements;
            }

            size_type max_size() const noexcept { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return static_cast<size_type>(-1);
            }

            ROBIN_HOOD(NODISCARD) bool empty() const noexcept {
                ROBIN_HOOD_TRACE(this)
                    return 0 == mNumElements;
            }

            float max_load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return MaxLoadFactor100 / 100.0F;
            }

            // Average number of elements per bucket. Since we allow only 1 per bucket
            float load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)
                ROBIN_HOOD_TRACE(this)
                    return static_cast<float>(size()) / static_cast<float>(mMask + 1);
            }

            ROBIN_HOOD(NODISCARD) size_t mask() const noexcept {
                ROBIN_HOOD_TRACE(this)
                    return mMask;
            }

            ROBIN_HOOD(NODISCARD) size_t calcMaxNumElementsAllowed(size_t maxElements) const noexcept {
                if (ROBIN_HOOD_LIKELY(maxElements <= (std::numeric_limits<size_t>::max)() / 100)) {
                    return maxElements * MaxLoadFactor100 / 100;
                }

                // we might be a bit inprecise, but since maxElements is quite large that doesn't matter
                return (maxElements / 100) * MaxLoadFactor100;
            }

            ROBIN_HOOD(NODISCARD) size_t calcNumBytesInfo(size_t numElements) const noexcept {
                // we add a uint64_t, which houses the sentinel (first byte) and padding so we can load
                // 64bit types.
                return numElements + sizeof(uint64_t);
            }

            ROBIN_HOOD(NODISCARD)
                size_t calcNumElementsWithBuffer(size_t numElements) const noexcept {
                auto maxNumElementsAllowed = calcMaxNumElementsAllowed(numElements);
                return numElements + (std::min)(maxNumElementsAllowed, (static_cast<size_t>(0xFF)));
            }

            // calculation only allowed for 2^n values
            ROBIN_HOOD(NODISCARD) size_t calcNumBytesTotal(size_t numElements) const {
#if ROBIN_HOOD(BITNESS) == 64
                return numElements * sizeof(Node) + calcNumBytesInfo(numElements);
#else
                // make sure we're doing 64bit operations, so we are at least safe against 32bit overflows.
                auto const ne = static_cast<uint64_t>(numElements);
                auto const s = static_cast<uint64_t>(sizeof(Node));
                auto const infos = static_cast<uint64_t>(calcNumBytesInfo(numElements));

                auto const total64 = ne * s + infos;
                auto const total = static_cast<size_t>(total64);

                if (ROBIN_HOOD_UNLIKELY(static_cast<uint64_t>(total) != total64)) {
                    throwOverflowError();
                }
                return total;
#endif
            }

        private:
            template <typename Q = mapped_type>
            ROBIN_HOOD(NODISCARD)
                typename std::enable_if<!std::is_void<Q>::value, bool>::type has(const value_type& e) const {
                ROBIN_HOOD_TRACE(this)
                    auto it = find(e.first);
                return it != end() && it->second == e.second;
            }

            template <typename Q = mapped_type>
            ROBIN_HOOD(NODISCARD)
                typename std::enable_if<std::is_void<Q>::value, bool>::type has(const value_type& e) const {
                ROBIN_HOOD_TRACE(this)
                    return find(e) != end();
            }

            void reserve(size_t c, bool forceRehash) {
                ROBIN_HOOD_TRACE(this)
                    auto const minElementsAllowed = (std::max)(c, mNumElements);
                auto newSize = InitialNumElements;
                while (calcMaxNumElementsAllowed(newSize) < minElementsAllowed && newSize != 0) {
                    newSize *= 2;
                }
                if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {
                    throwOverflowError();
                }

                ROBIN_HOOD_LOG("newSize > mMask + 1: " << newSize << " > " << mMask << " + 1")

                    // only actually do anything when the new size is bigger than the old one. This prevents to
                    // continuously allocate for each reserve() call.
                    if (forceRehash || newSize > mMask + 1) {
                        rehashPowerOfTwo(newSize, false);
                    }
            }

            // reserves space for at least the specified number of elements.
            // only works if numBuckets if power of two
            // True on success, false otherwise
            void rehashPowerOfTwo(size_t numBuckets, bool forceFree) {
                ROBIN_HOOD_TRACE(this)

                    Node* const oldKeyVals = mKeyVals;
                uint8_t const* const oldInfo = mInfo;

                const size_t oldMaxElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);

                // resize operation: move stuff
                initData(numBuckets);
                if (oldMaxElementsWithBuffer > 1) {
                    for (size_t i = 0; i < oldMaxElementsWithBuffer; ++i) {
                        if (oldInfo[i] != 0) {
                            // might throw an exception, which is really bad since we are in the middle of
                            // moving stuff.
                            insert_move(std::move(oldKeyVals[i]));
                            // destroy the node but DON'T destroy the data.
                            oldKeyVals[i].~Node();
                        }
                    }

                    // this check is not necessary as it's guarded by the previous if, but it helps
                    // silence g++'s overeager "attempt to free a non-heap object 'map'
                    // [-Werror=free-nonheap-object]" warning.
                    if (oldKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {
                        // don't destroy old data: put it into the pool instead
                        if (forceFree) {
                            std::free(oldKeyVals);
                        }
                        else {
                            DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElementsWithBuffer));
                        }
                    }
                }
            }

            ROBIN_HOOD(NOINLINE) void throwOverflowError() const {
#if ROBIN_HOOD(HAS_EXCEPTIONS)
                throw std::overflow_error("robin_hood::map overflow");
#else
                abort();
#endif
            }

            template <typename OtherKey, typename... Args>
            std::pair<iterator, bool> try_emplace_impl(OtherKey&& key, Args&&... args) {
                ROBIN_HOOD_TRACE(this)
                    auto idxAndState = insertKeyPrepareEmptySpot(key);
                switch (idxAndState.second) {
                case InsertionState::key_found:
                    break;

                case InsertionState::new_node:
                    ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(
                        *this, std::piecewise_construct, std::forward_as_tuple(std::forward<OtherKey>(key)),
                        std::forward_as_tuple(std::forward<Args>(args)...));
                    break;

                case InsertionState::overwrite_node:
                    mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,
                        std::forward_as_tuple(std::forward<OtherKey>(key)),
                        std::forward_as_tuple(std::forward<Args>(args)...));
                    break;

                case InsertionState::overflow_error:
                    throwOverflowError();
                    break;
                }

                return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),
                    InsertionState::key_found != idxAndState.second);
            }

            template <typename OtherKey, typename Mapped>
            std::pair<iterator, bool> insertOrAssignImpl(OtherKey&& key, Mapped&& obj) {
                ROBIN_HOOD_TRACE(this)
                    auto idxAndState = insertKeyPrepareEmptySpot(key);
                switch (idxAndState.second) {
                case InsertionState::key_found:
                    mKeyVals[idxAndState.first].getSecond() = std::forward<Mapped>(obj);
                    break;

                case InsertionState::new_node:
                    ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(
                        *this, std::piecewise_construct, std::forward_as_tuple(std::forward<OtherKey>(key)),
                        std::forward_as_tuple(std::forward<Mapped>(obj)));
                    break;

                case InsertionState::overwrite_node:
                    mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,
                        std::forward_as_tuple(std::forward<OtherKey>(key)),
                        std::forward_as_tuple(std::forward<Mapped>(obj)));
                    break;

                case InsertionState::overflow_error:
                    throwOverflowError();
                    break;
                }

                return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),
                    InsertionState::key_found != idxAndState.second);
            }

            void initData(size_t max_elements) {
                mNumElements = 0;
                mMask = max_elements - 1;
                mMaxNumElementsAllowed = calcMaxNumElementsAllowed(max_elements);

                auto const numElementsWithBuffer = calcNumElementsWithBuffer(max_elements);

                // malloc & zero mInfo. Faster than calloc everything.
                auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);
                ROBIN_HOOD_LOG("std::calloc " << numBytesTotal << " = calcNumBytesTotal("
                    << numElementsWithBuffer << ")")
                    mKeyVals = reinterpret_cast<Node*>(
                        detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));
                mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
                std::memset(mInfo, 0, numBytesTotal - numElementsWithBuffer * sizeof(Node));

                // set sentinel
                mInfo[numElementsWithBuffer] = 1;

                mInfoInc = InitialInfoInc;
                mInfoHashShift = InitialInfoHashShift;
            }

            enum class InsertionState { overflow_error, key_found, new_node, overwrite_node };

            // Finds key, and if not already present prepares a spot where to pot the key & value.
            // This potentially shifts nodes out of the way, updates mInfo and number of inserted
            // elements, so the only operation left to do is create/assign a new node at that spot.
            template <typename OtherKey>
            std::pair<size_t, InsertionState> insertKeyPrepareEmptySpot(OtherKey&& key) {
                for (int i = 0; i < 256; ++i) {
                    size_t idx{};
                    InfoType info{};
                    keyToIdx(key, &idx, &info);
                    nextWhileLess(&info, &idx);

                    // while we potentially have a match
                    while (info == mInfo[idx]) {
                        if (WKeyEqual::operator()(key, mKeyVals[idx].getFirst())) {
                            // key already exists, do NOT insert.
                            // see http://en.cppreference.com/w/cpp/container/unordered_map/insert
                            return std::make_pair(idx, InsertionState::key_found);
                        }
                        next(&info, &idx);
                    }

                    // unlikely that this evaluates to true
                    if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {
                        if (!increase_size()) {
                            return std::make_pair(size_t(0), InsertionState::overflow_error);
                        }
                        continue;
                    }

                    // key not found, so we are now exactly where we want to insert it.
                    auto const insertion_idx = idx;
                    auto const insertion_info = info;
                    if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {
                        mMaxNumElementsAllowed = 0;
                    }

                    // find an empty spot
                    while (0 != mInfo[idx]) {
                        next(&info, &idx);
                    }

                    if (idx != insertion_idx) {
                        shiftUp(idx, insertion_idx);
                    }
                    // put at empty spot
                    mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);
                    ++mNumElements;
                    return std::make_pair(insertion_idx, idx == insertion_idx
                        ? InsertionState::new_node
                        : InsertionState::overwrite_node);
                }

                // enough attempts failed, so finally give up.
                return std::make_pair(size_t(0), InsertionState::overflow_error);
            }

            bool try_increase_info() {
                ROBIN_HOOD_LOG("mInfoInc=" << mInfoInc << ", numElements=" << mNumElements
                    << ", maxNumElementsAllowed="
                    << calcMaxNumElementsAllowed(mMask + 1))
                    if (mInfoInc <= 2) {
                        // need to be > 2 so that shift works (otherwise undefined behavior!)
                        return false;
                    }
                // we got space left, try to make info smaller
                mInfoInc = static_cast<uint8_t>(mInfoInc >> 1U);

                // remove one bit of the hash, leaving more space for the distance info.
                // This is extremely fast because we can operate on 8 bytes at once.
                ++mInfoHashShift;
                auto const numElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);

                for (size_t i = 0; i < numElementsWithBuffer; i += 8) {
                    auto val = unaligned_load<uint64_t>(mInfo + i);
                    val = (val >> 1U) & UINT64_C(0x7f7f7f7f7f7f7f7f);
                    std::memcpy(mInfo + i, &val, sizeof(val));
                }
                // update sentinel, which might have been cleared out!
                mInfo[numElementsWithBuffer] = 1;

                mMaxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);
                return true;
            }

            // True if resize was possible, false otherwise
            bool increase_size() {
                // nothing allocated yet? just allocate InitialNumElements
                if (0 == mMask) {
                    initData(InitialNumElements);
                    return true;
                }

                auto const maxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);
                if (mNumElements < maxNumElementsAllowed && try_increase_info()) {
                    return true;
                }

                ROBIN_HOOD_LOG("mNumElements=" << mNumElements << ", maxNumElementsAllowed="
                    << maxNumElementsAllowed << ", load="
                    << (static_cast<double>(mNumElements) * 100.0 /
                        (static_cast<double>(mMask) + 1)))

                    if (mNumElements * 2 < calcMaxNumElementsAllowed(mMask + 1)) {
                        // we have to resize, even though there would still be plenty of space left!
                        // Try to rehash instead. Delete freed memory so we don't steadyily increase mem in case
                        // we have to rehash a few times
                        nextHashMultiplier();
                        rehashPowerOfTwo(mMask + 1, true);
                    }
                    else {
                        // we've reached the capacity of the map, so the hash seems to work nice. Keep using it.
                        rehashPowerOfTwo((mMask + 1) * 2, false);
                    }
                return true;
            }

            void nextHashMultiplier() {
                // adding an *even* number, so that the multiplier will always stay odd. This is necessary
                // so that the hash stays a mixing function (and thus doesn't have any information loss).
                mHashMultiplier += UINT64_C(0xc4ceb9fe1a85ec54);
            }

            void destroy() {
                if (0 == mMask) {
                    // don't deallocate!
                    return;
                }

                Destroyer<Self, IsFlat&& std::is_trivially_destructible<Node>::value>{}
                .nodesDoNotDeallocate(*this);

                // This protection against not deleting mMask shouldn't be needed as it's sufficiently
                // protected with the 0==mMask check, but I have this anyways because g++ 7 otherwise
                // reports a compile error: attempt to free a non-heap object 'fm'
                // [-Werror=free-nonheap-object]
                if (mKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {
                    ROBIN_HOOD_LOG("std::free")
                        std::free(mKeyVals);
                }
            }

            void init() noexcept {
                mKeyVals = reinterpret_cast_no_cast_align_warning<Node*>(&mMask);
                mInfo = reinterpret_cast<uint8_t*>(&mMask);
                mNumElements = 0;
                mMask = 0;
                mMaxNumElementsAllowed = 0;
                mInfoInc = InitialInfoInc;
                mInfoHashShift = InitialInfoHashShift;
            }

            // members are sorted so no padding occurs
            uint64_t mHashMultiplier = UINT64_C(0xc4ceb9fe1a85ec53);                // 8 byte  8
            Node* mKeyVals = reinterpret_cast_no_cast_align_warning<Node*>(&mMask); // 8 byte 16
            uint8_t* mInfo = reinterpret_cast<uint8_t*>(&mMask);                    // 8 byte 24
            size_t mNumElements = 0;                                                // 8 byte 32
            size_t mMask = 0;                                                       // 8 byte 40
            size_t mMaxNumElementsAllowed = 0;                                      // 8 byte 48
            InfoType mInfoInc = InitialInfoInc;                                     // 4 byte 52
            InfoType mInfoHashShift = InitialInfoHashShift;                         // 4 byte 56
            // 16 byte 56 if NodeAllocator
        };

    } // namespace detail

    // map

    template <typename Key, typename T, typename Hash = hash<Key>,
        typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>
    using unordered_flat_map = detail::Table<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;

    template <typename Key, typename T, typename Hash = hash<Key>,
        typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>
    using unordered_node_map = detail::Table<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;

    template <typename Key, typename T, typename Hash = hash<Key>,
        typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>
    using unordered_map =
        detail::Table<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&
        std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value&&
        std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,
        MaxLoadFactor100, Key, T, Hash, KeyEqual>;

    // set

    template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,
        size_t MaxLoadFactor100 = 80>
    using unordered_flat_set = detail::Table<true, MaxLoadFactor100, Key, void, Hash, KeyEqual>;

    template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,
        size_t MaxLoadFactor100 = 80>
    using unordered_node_set = detail::Table<false, MaxLoadFactor100, Key, void, Hash, KeyEqual>;

    template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,
        size_t MaxLoadFactor100 = 80>
    using unordered_set = detail::Table<sizeof(Key) <= sizeof(size_t) * 6 &&
        std::is_nothrow_move_constructible<Key>::value&&
        std::is_nothrow_move_assignable<Key>::value,
        MaxLoadFactor100, Key, void, Hash, KeyEqual>;

} // namespace robin_hood

#endif
"./Utils\\FastNoiseLite.h"
// MIT License
//
// Copyright(c) 2020 Jordan Peck (jordan.me2@gmail.com)
// Copyright(c) 2020 Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// .'',;:cldxkO00KKXXNNWWWNNXKOkxdollcc::::::;:::ccllloooolllllllllooollc:,'...        ...........',;cldxkO000Okxdlc::;;;,,;;;::cclllllll
// ..',;:ldxO0KXXNNNNNNNNXXK0kxdolcc::::::;;;,,,,,,;;;;;;;;;;:::cclllllc:;'....       ...........',;:ldxO0KXXXK0Okxdolc::;;;;::cllodddddo
// ...',:loxO0KXNNNNNXXKK0Okxdolc::;::::::::;;;,,'''''.....''',;:clllllc:;,'............''''''''',;:loxO0KXNNNNNXK0Okxdollccccllodxxxxxxd
// ....';:ldkO0KXXXKK00Okxdolcc:;;;;;::cclllcc:;;,''..... ....',;clooddolcc:;;;;,,;;;;;::::;;;;;;:cloxk0KXNWWWWWWNXKK0Okxddoooddxxkkkkkxx
// .....';:ldxkOOOOOkxxdolcc:;;;,,,;;:cllooooolcc:;'...      ..,:codxkkkxddooollloooooooollcc:::::clodkO0KXNWWWWWWNNXK00Okxxxxxxxxkkkkxxx
// . ....';:cloddddo___________,,,,;;:clooddddoolc:,...      ..,:ldx__00OOOkkk___kkkkkkxxdollc::::cclodkO0KXXNNNNNNXXK0OOkxxxxxxxxxxxxddd
// .......',;:cccc:|           |,,,;;:cclooddddoll:;'..     ..';cox|  \KKK000|   |KK00OOkxdocc___;::clldxxkO0KKKKK00Okkxdddddddddddddddoo
// .......'',,,,,''|   ________|',,;;::cclloooooolc:;'......___:ldk|   \KK000|   |XKKK0Okxolc|   |;;::cclodxxkkkkxxdoolllcclllooodddooooo
// ''......''''....|   |  ....'',,,,;;;::cclloooollc:;,''.'|   |oxk|    \OOO0|   |KKK00Oxdoll|___|;;;;;::ccllllllcc::;;,,;;;:cclloooooooo
// ;;,''.......... |   |_____',,;;;____:___cllo________.___|   |___|     \xkk|   |KK_______ool___:::;________;;;_______...'',;;:ccclllloo
// c:;,''......... |         |:::/     '   |lo/        |           |      \dx|   |0/       \d|   |cc/        |'/       \......',,;;:ccllo
// ol:;,'..........|    _____|ll/    __    |o/   ______|____    ___|   |   \o|   |/   ___   \|   |o/   ______|/   ___   \ .......'',;:clo
// dlc;,...........|   |::clooo|    /  |   |x\___   \KXKKK0|   |dol|   |\   \|   |   |   |   |   |d\___   \..|   |  /   /       ....',:cl
// xoc;'...  .....'|   |llodddd|    \__|   |_____\   \KKK0O|   |lc:|   |'\       |   |___|   |   |_____\   \.|   |_/___/...      ...',;:c
// dlc;'... ....',;|   |oddddddo\          |          |Okkx|   |::;|   |..\      |\         /|   |          | \         |...    ....',;:c
// ol:,'.......',:c|___|xxxddollc\_____,___|_________/ddoll|___|,,,|___|...\_____|:\ ______/l|___|_________/...\________|'........',;::cc
// c:;'.......';:codxxkkkkxxolc::;::clodxkOO0OOkkxdollc::;;,,''''',,,,''''''''''',,'''''',;:loxkkOOkxol:;,'''',,;:ccllcc:;,'''''',;::ccll
// ;,'.......',:codxkOO0OOkxdlc:;,,;;:cldxxkkxxdolc:;;,,''.....'',;;:::;;,,,'''''........,;cldkO0KK0Okdoc::;;::cloodddoolc:;;;;;::ccllooo
// .........',;:lodxOO0000Okdoc:,,',,;:clloddoolc:;,''.......'',;:clooollc:;;,,''.......',:ldkOKXNNXX0Oxdolllloddxxxxxxdolccccccllooodddd
// .    .....';:cldxkO0000Okxol:;,''',,;::cccc:;,,'.......'',;:cldxxkkxxdolc:;;,'.......';coxOKXNWWWNXKOkxddddxxkkkkkkxdoollllooddxxxxkkk
//       ....',;:codxkO000OOxdoc:;,''',,,;;;;,''.......',,;:clodkO00000Okxolc::;,,''..',;:ldxOKXNWWWNNK0OkkkkkkkkkkkxxddooooodxxkOOOOO000
//       ....',;;clodxkkOOOkkdolc:;,,,,,,,,'..........,;:clodxkO0KKXKK0Okxdolcc::;;,,,;;:codkO0XXNNNNXKK0OOOOOkkkkxxdoollloodxkO0KKKXXXXX
//
// VERSION: 1.0.1
// https://github.com/Auburn/FastNoise

#ifndef FASTNOISELITE_H
#define FASTNOISELITE_H

#include <cmath>

class FastNoiseLite
{
public:
    enum NoiseType
    {
        NoiseType_OpenSimplex2,
        NoiseType_OpenSimplex2S,
        NoiseType_Cellular,
        NoiseType_Perlin,
        NoiseType_ValueCubic,
        NoiseType_Value
    };

    enum RotationType3D
    {
        RotationType3D_None,
        RotationType3D_ImproveXYPlanes,
        RotationType3D_ImproveXZPlanes
    };

    enum FractalType
    {
        FractalType_None,
        FractalType_FBm,
        FractalType_Ridged,
        FractalType_PingPong,
        FractalType_DomainWarpProgressive,
        FractalType_DomainWarpIndependent
    };

    enum CellularDistanceFunction
    {
        CellularDistanceFunction_Euclidean,
        CellularDistanceFunction_EuclideanSq,
        CellularDistanceFunction_Manhattan,
        CellularDistanceFunction_Hybrid
    };

    enum CellularReturnType
    {
        CellularReturnType_CellValue,
        CellularReturnType_Distance,
        CellularReturnType_Distance2,
        CellularReturnType_Distance2Add,
        CellularReturnType_Distance2Sub,
        CellularReturnType_Distance2Mul,
        CellularReturnType_Distance2Div
    };

    enum DomainWarpType
    {
        DomainWarpType_OpenSimplex2,
        DomainWarpType_OpenSimplex2Reduced,
        DomainWarpType_BasicGrid
    };

    /// <summary>
    /// Create new FastNoise object with optional seed
    /// </summary>
    FastNoiseLite(int seed = 1337)
    {
        mSeed = seed;
        mFrequency = 0.01f;
        mNoiseType = NoiseType_OpenSimplex2;
        mRotationType3D = RotationType3D_None;
        mTransformType3D = TransformType3D_DefaultOpenSimplex2;

        mFractalType = FractalType_None;
        mOctaves = 3;
        mLacunarity = 2.0f;
        mGain = 0.5f;
        mWeightedStrength = 0.0f;
        mPingPongStength = 2.0f;

        mFractalBounding = 1 / 1.75f;

        mCellularDistanceFunction = CellularDistanceFunction_EuclideanSq;
        mCellularReturnType = CellularReturnType_Distance;
        mCellularJitterModifier = 1.0f;

        mDomainWarpType = DomainWarpType_OpenSimplex2;
        mWarpTransformType3D = TransformType3D_DefaultOpenSimplex2;
        mDomainWarpAmp = 1.0f;
    }

    /// <summary>
    /// Sets seed used for all noise types
    /// </summary>
    /// <remarks>
    /// Default: 1337
    /// </remarks>
    void SetSeed(int seed) { mSeed = seed; }

    /// <summary>
    /// Sets frequency for all noise types
    /// </summary>
    /// <remarks>
    /// Default: 0.01
    /// </remarks>
    void SetFrequency(float frequency) { mFrequency = frequency; }

    /// <summary>
    /// Sets noise algorithm used for GetNoise(...)
    /// </summary>
    /// <remarks>
    /// Default: OpenSimplex2
    /// </remarks>
    void SetNoiseType(NoiseType noiseType)
    {
        mNoiseType = noiseType;
        UpdateTransformType3D();
    }

    /// <summary>
    /// Sets domain rotation type for 3D Noise and 3D DomainWarp.
    /// Can aid in reducing directional artifacts when sampling a 2D plane in 3D
    /// </summary>
    /// <remarks>
    /// Default: None
    /// </remarks>
    void SetRotationType3D(RotationType3D rotationType3D)
    {
        mRotationType3D = rotationType3D;
        UpdateTransformType3D();
        UpdateWarpTransformType3D();
    }

    /// <summary>
    /// Sets method for combining octaves in all fractal noise types
    /// </summary>
    /// <remarks>
    /// Default: None
    /// Note: FractalType_DomainWarp... only affects DomainWarp(...)
    /// </remarks>
    void SetFractalType(FractalType fractalType) { mFractalType = fractalType; }

    /// <summary>
    /// Sets octave count for all fractal noise types 
    /// </summary>
    /// <remarks>
    /// Default: 3
    /// </remarks>
    void SetFractalOctaves(int octaves)
    {
        mOctaves = octaves;
        CalculateFractalBounding();
    }

    /// <summary>
    /// Sets octave lacunarity for all fractal noise types
    /// </summary>
    /// <remarks>
    /// Default: 2.0
    /// </remarks>
    void SetFractalLacunarity(float lacunarity) { mLacunarity = lacunarity; }

    /// <summary>
    /// Sets octave gain for all fractal noise types
    /// </summary>
    /// <remarks>
    /// Default: 0.5
    /// </remarks>
    void SetFractalGain(float gain)
    {
        mGain = gain;
        CalculateFractalBounding();
    }

    /// <summary>
    /// Sets octave weighting for all none DomainWarp fratal types
    /// </summary>
    /// <remarks>
    /// Default: 0.0
    /// Note: Keep between 0...1 to maintain -1...1 output bounding
    /// </remarks>
    void SetFractalWeightedStrength(float weightedStrength) { mWeightedStrength = weightedStrength; }

    /// <summary>
    /// Sets strength of the fractal ping pong effect
    /// </summary>
    /// <remarks>
    /// Default: 2.0
    /// </remarks>
    void SetFractalPingPongStrength(float pingPongStrength) { mPingPongStength = pingPongStrength; }


    /// <summary>
    /// Sets distance function used in cellular noise calculations
    /// </summary>
    /// <remarks>
    /// Default: Distance
    /// </remarks>
    void SetCellularDistanceFunction(CellularDistanceFunction cellularDistanceFunction) { mCellularDistanceFunction = cellularDistanceFunction; }

    /// <summary>
    /// Sets return type from cellular noise calculations
    /// </summary>
    /// <remarks>
    /// Default: EuclideanSq
    /// </remarks>
    void SetCellularReturnType(CellularReturnType cellularReturnType) { mCellularReturnType = cellularReturnType; }

    /// <summary>
    /// Sets the maximum distance a cellular point can move from it's grid position
    /// </summary>
    /// <remarks>
    /// Default: 1.0
    /// Note: Setting this higher than 1 will cause artifacts
    /// </remarks> 
    void SetCellularJitter(float cellularJitter) { mCellularJitterModifier = cellularJitter; }


    /// <summary>
    /// Sets the warp algorithm when using DomainWarp(...)
    /// </summary>
    /// <remarks>
    /// Default: OpenSimplex2
    /// </remarks>
    void SetDomainWarpType(DomainWarpType domainWarpType)
    {
        mDomainWarpType = domainWarpType;
        UpdateWarpTransformType3D();
    }


    /// <summary>
    /// Sets the maximum warp distance from original position when using DomainWarp(...)
    /// </summary>
    /// <remarks>
    /// Default: 1.0
    /// </remarks>
    void SetDomainWarpAmp(float domainWarpAmp) { mDomainWarpAmp = domainWarpAmp; }


    /// <summary>
    /// 2D noise at given position using current settings
    /// </summary>
    /// <returns>
    /// Noise output bounded between -1...1
    /// </returns>
    template <typename FNfloat>
    float GetNoise(FNfloat x, FNfloat y)
    {
        Arguments_must_be_floating_point_values<FNfloat>();

        TransformNoiseCoordinate(x, y);

        switch (mFractalType)
        {
        default:
            return GenNoiseSingle(mSeed, x, y);
        case FractalType_FBm:
            return GenFractalFBm(x, y);
        case FractalType_Ridged:
            return GenFractalRidged(x, y);
        case FractalType_PingPong:
            return GenFractalPingPong(x, y);
        }
    }

    /// <summary>
    /// 3D noise at given position using current settings
    /// </summary>
    /// <returns>
    /// Noise output bounded between -1...1
    /// </returns>
    template <typename FNfloat>
    float GetNoise(FNfloat x, FNfloat y, FNfloat z)
    {
        Arguments_must_be_floating_point_values<FNfloat>();

        TransformNoiseCoordinate(x, y, z);

        switch (mFractalType)
        {
        default:
            return GenNoiseSingle(mSeed, x, y, z);
        case FractalType_FBm:
            return GenFractalFBm(x, y, z);
        case FractalType_Ridged:
            return GenFractalRidged(x, y, z);
        case FractalType_PingPong:
            return GenFractalPingPong(x, y, z);
        }
    }


    /// <summary>
    /// 2D warps the input position using current domain warp settings
    /// </summary>
    /// <example>
    /// Example usage with GetNoise
    /// <code>DomainWarp(x, y)
    /// noise = GetNoise(x, y)</code>
    /// </example>
    template <typename FNfloat>
    void DomainWarp(FNfloat& x, FNfloat& y)
    {
        Arguments_must_be_floating_point_values<FNfloat>();

        switch (mFractalType)
        {
        default:
            DomainWarpSingle(x, y);
            break;
        case FractalType_DomainWarpProgressive:
            DomainWarpFractalProgressive(x, y);
            break;
        case FractalType_DomainWarpIndependent:
            DomainWarpFractalIndependent(x, y);
            break;
        }
    }

    /// <summary>
    /// 3D warps the input position using current domain warp settings
    /// </summary>
    /// <example>
    /// Example usage with GetNoise
    /// <code>DomainWarp(x, y, z)
    /// noise = GetNoise(x, y, z)</code>
    /// </example>
    template <typename FNfloat>
    void DomainWarp(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        Arguments_must_be_floating_point_values<FNfloat>();

        switch (mFractalType)
        {
        default:
            DomainWarpSingle(x, y, z);
            break;
        case FractalType_DomainWarpProgressive:
            DomainWarpFractalProgressive(x, y, z);
            break;
        case FractalType_DomainWarpIndependent:
            DomainWarpFractalIndependent(x, y, z);
            break;
        }
    }

private:
    template <typename T>
    struct Arguments_must_be_floating_point_values;

    enum TransformType3D
    {
        TransformType3D_None,
        TransformType3D_ImproveXYPlanes,
        TransformType3D_ImproveXZPlanes,
        TransformType3D_DefaultOpenSimplex2
    };

    int mSeed;
    float mFrequency;
    NoiseType mNoiseType;
    RotationType3D mRotationType3D;
    TransformType3D mTransformType3D;

    FractalType mFractalType;
    int mOctaves;
    float mLacunarity;
    float mGain;
    float mWeightedStrength;
    float mPingPongStength;

    float mFractalBounding;

    CellularDistanceFunction mCellularDistanceFunction;
    CellularReturnType mCellularReturnType;
    float mCellularJitterModifier;

    DomainWarpType mDomainWarpType;
    TransformType3D mWarpTransformType3D;
    float mDomainWarpAmp;


    template <typename T>
    struct Lookup
    {
        static const T Gradients2D[];
        static const T Gradients3D[];
        static const T RandVecs2D[];
        static const T RandVecs3D[];
    };

    static float FastMin(float a, float b) { return a < b ? a : b; }

    static float FastMax(float a, float b) { return a > b ? a : b; }

    static float FastAbs(float f) { return f < 0 ? -f : f; }

    static float FastSqrt(float f) { return sqrtf(f); }

    template <typename FNfloat>
    static int FastFloor(FNfloat f) { return f >= 0 ? (int)f : (int)f - 1; }

    template <typename FNfloat>
    static int FastRound(FNfloat f) { return f >= 0 ? (int)(f + 0.5f) : (int)(f - 0.5f); }

    static float Lerp(float a, float b, float t) { return a + t * (b - a); }

    static float InterpHermite(float t) { return t * t * (3 - 2 * t); }

    static float InterpQuintic(float t) { return t * t * t * (t * (t * 6 - 15) + 10); }

    static float CubicLerp(float a, float b, float c, float d, float t)
    {
        float p = (d - c) - (a - b);
        return t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b;
    }

    static float PingPong(float t)
    {
        t -= (int)(t * 0.5f) * 2;
        return t < 1 ? t : 2 - t;
    }

    void CalculateFractalBounding()
    {
        float gain = FastAbs(mGain);
        float amp = gain;
        float ampFractal = 1.0f;
        for (int i = 1; i < mOctaves; i++)
        {
            ampFractal += amp;
            amp *= gain;
        }
        mFractalBounding = 1 / ampFractal;
    }

    // Hashing
    static const int PrimeX = 501125321;
    static const int PrimeY = 1136930381;
    static const int PrimeZ = 1720413743;

    static int Hash(int seed, int xPrimed, int yPrimed)
    {
        int hash = seed ^ xPrimed ^ yPrimed;

        hash *= 0x27d4eb2d;
        return hash;
    }


    static int Hash(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
        int hash = seed ^ xPrimed ^ yPrimed ^ zPrimed;

        hash *= 0x27d4eb2d;
        return hash;
    }


    static float ValCoord(int seed, int xPrimed, int yPrimed)
    {
        int hash = Hash(seed, xPrimed, yPrimed);

        hash *= hash;
        hash ^= hash << 19;
        return hash * (1 / 2147483648.0f);
    }


    static float ValCoord(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);

        hash *= hash;
        hash ^= hash << 19;
        return hash * (1 / 2147483648.0f);
    }


    float GradCoord(int seed, int xPrimed, int yPrimed, float xd, float yd)
    {
        int hash = Hash(seed, xPrimed, yPrimed);
        hash ^= hash >> 15;
        hash &= 127 << 1;

        float xg = Lookup<float>::Gradients2D[hash];
        float yg = Lookup<float>::Gradients2D[hash | 1];

        return xd * xg + yd * yg;
    }


    float GradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd)
    {
        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
        hash ^= hash >> 15;
        hash &= 63 << 2;

        float xg = Lookup<float>::Gradients3D[hash];
        float yg = Lookup<float>::Gradients3D[hash | 1];
        float zg = Lookup<float>::Gradients3D[hash | 2];

        return xd * xg + yd * yg + zd * zg;
    }


    void GradCoordOut(int seed, int xPrimed, int yPrimed, float& xo, float& yo)
    {
        int hash = Hash(seed, xPrimed, yPrimed) & (255 << 1);

        xo = Lookup<float>::RandVecs2D[hash];
        yo = Lookup<float>::RandVecs2D[hash | 1];
    }


    void GradCoordOut(int seed, int xPrimed, int yPrimed, int zPrimed, float& xo, float& yo, float& zo)
    {
        int hash = Hash(seed, xPrimed, yPrimed, zPrimed) & (255 << 2);

        xo = Lookup<float>::RandVecs3D[hash];
        yo = Lookup<float>::RandVecs3D[hash | 1];
        zo = Lookup<float>::RandVecs3D[hash | 2];
    }


    void GradCoordDual(int seed, int xPrimed, int yPrimed, float xd, float yd, float& xo, float& yo)
    {
        int hash = Hash(seed, xPrimed, yPrimed);
        int index1 = hash & (127 << 1);
        int index2 = (hash >> 7) & (255 << 1);

        float xg = Lookup<float>::Gradients2D[index1];
        float yg = Lookup<float>::Gradients2D[index1 | 1];
        float value = xd * xg + yd * yg;

        float xgo = Lookup<float>::RandVecs2D[index2];
        float ygo = Lookup<float>::RandVecs2D[index2 | 1];

        xo = value * xgo;
        yo = value * ygo;
    }


    void GradCoordDual(int seed, int xPrimed, int yPrimed, int zPrimed, float xd, float yd, float zd, float& xo, float& yo, float& zo)
    {
        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
        int index1 = hash & (63 << 2);
        int index2 = (hash >> 6) & (255 << 2);

        float xg = Lookup<float>::Gradients3D[index1];
        float yg = Lookup<float>::Gradients3D[index1 | 1];
        float zg = Lookup<float>::Gradients3D[index1 | 2];
        float value = xd * xg + yd * yg + zd * zg;

        float xgo = Lookup<float>::RandVecs3D[index2];
        float ygo = Lookup<float>::RandVecs3D[index2 | 1];
        float zgo = Lookup<float>::RandVecs3D[index2 | 2];

        xo = value * xgo;
        yo = value * ygo;
        zo = value * zgo;
    }


    // Generic noise gen

    template <typename FNfloat>
    float GenNoiseSingle(int seed, FNfloat x, FNfloat y)
    {
        switch (mNoiseType)
        {
        case NoiseType_OpenSimplex2:
            return SingleSimplex(seed, x, y);
        case NoiseType_OpenSimplex2S:
            return SingleOpenSimplex2S(seed, x, y);
        case NoiseType_Cellular:
            return SingleCellular(seed, x, y);
        case NoiseType_Perlin:
            return SinglePerlin(seed, x, y);
        case NoiseType_ValueCubic:
            return SingleValueCubic(seed, x, y);
        case NoiseType_Value:
            return SingleValue(seed, x, y);
        default:
            return 0;
        }
    }

    template <typename FNfloat>
    float GenNoiseSingle(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        switch (mNoiseType)
        {
        case NoiseType_OpenSimplex2:
            return SingleOpenSimplex2(seed, x, y, z);
        case NoiseType_OpenSimplex2S:
            return SingleOpenSimplex2S(seed, x, y, z);
        case NoiseType_Cellular:
            return SingleCellular(seed, x, y, z);
        case NoiseType_Perlin:
            return SinglePerlin(seed, x, y, z);
        case NoiseType_ValueCubic:
            return SingleValueCubic(seed, x, y, z);
        case NoiseType_Value:
            return SingleValue(seed, x, y, z);
        default:
            return 0;
        }
    }


    // Noise Coordinate Transforms (frequency, and possible skew or rotation)

    template <typename FNfloat>
    void TransformNoiseCoordinate(FNfloat& x, FNfloat& y)
    {
        x *= mFrequency;
        y *= mFrequency;

        switch (mNoiseType)
        {
        case NoiseType_OpenSimplex2:
        case NoiseType_OpenSimplex2S:
        {
            const FNfloat SQRT3 = (FNfloat)1.7320508075688772935274463415059;
            const FNfloat F2 = 0.5f * (SQRT3 - 1);
            FNfloat t = (x + y) * F2;
            x += t;
            y += t;
        }
        break;
        default:
            break;
        }
    }

    template <typename FNfloat>
    void TransformNoiseCoordinate(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        x *= mFrequency;
        y *= mFrequency;
        z *= mFrequency;

        switch (mTransformType3D)
        {
        case TransformType3D_ImproveXYPlanes:
        {
            FNfloat xy = x + y;
            FNfloat s2 = xy * -(FNfloat)0.211324865405187;
            z *= (FNfloat)0.577350269189626;
            x += s2 - z;
            y = y + s2 - z;
            z += xy * (FNfloat)0.577350269189626;
        }
        break;
        case TransformType3D_ImproveXZPlanes:
        {
            FNfloat xz = x + z;
            FNfloat s2 = xz * -(FNfloat)0.211324865405187;
            y *= (FNfloat)0.577350269189626;
            x += s2 - y;
            z += s2 - y;
            y += xz * (FNfloat)0.577350269189626;
        }
        break;
        case TransformType3D_DefaultOpenSimplex2:
        {
            const FNfloat R3 = (FNfloat)(2.0 / 3.0);
            FNfloat r = (x + y + z) * R3; // Rotation, not skew
            x = r - x;
            y = r - y;
            z = r - z;
        }
        break;
        default:
            break;
        }
    }

    void UpdateTransformType3D()
    {
        switch (mRotationType3D)
        {
        case RotationType3D_ImproveXYPlanes:
            mTransformType3D = TransformType3D_ImproveXYPlanes;
            break;
        case RotationType3D_ImproveXZPlanes:
            mTransformType3D = TransformType3D_ImproveXZPlanes;
            break;
        default:
            switch (mNoiseType)
            {
            case NoiseType_OpenSimplex2:
            case NoiseType_OpenSimplex2S:
                mTransformType3D = TransformType3D_DefaultOpenSimplex2;
                break;
            default:
                mTransformType3D = TransformType3D_None;
                break;
            }
            break;
        }
    }


    // Domain Warp Coordinate Transforms

    template <typename FNfloat>
    void TransformDomainWarpCoordinate(FNfloat& x, FNfloat& y)
    {
        switch (mDomainWarpType)
        {
        case DomainWarpType_OpenSimplex2:
        case DomainWarpType_OpenSimplex2Reduced:
        {
            const FNfloat SQRT3 = (FNfloat)1.7320508075688772935274463415059;
            const FNfloat F2 = 0.5f * (SQRT3 - 1);
            FNfloat t = (x + y) * F2;
            x += t;
            y += t;
        }
        break;
        default:
            break;
        }
    }

    template <typename FNfloat>
    void TransformDomainWarpCoordinate(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        switch (mWarpTransformType3D)
        {
        case TransformType3D_ImproveXYPlanes:
        {
            FNfloat xy = x + y;
            FNfloat s2 = xy * -(FNfloat)0.211324865405187;
            z *= (FNfloat)0.577350269189626;
            x += s2 - z;
            y = y + s2 - z;
            z += xy * (FNfloat)0.577350269189626;
        }
        break;
        case TransformType3D_ImproveXZPlanes:
        {
            FNfloat xz = x + z;
            FNfloat s2 = xz * -(FNfloat)0.211324865405187;
            y *= (FNfloat)0.577350269189626;
            x += s2 - y;
            z += s2 - y;
            y += xz * (FNfloat)0.577350269189626;
        }
        break;
        case TransformType3D_DefaultOpenSimplex2:
        {
            const FNfloat R3 = (FNfloat)(2.0 / 3.0);
            FNfloat r = (x + y + z) * R3; // Rotation, not skew
            x = r - x;
            y = r - y;
            z = r - z;
        }
        break;
        default:
            break;
        }
    }

    void UpdateWarpTransformType3D()
    {
        switch (mRotationType3D)
        {
        case RotationType3D_ImproveXYPlanes:
            mWarpTransformType3D = TransformType3D_ImproveXYPlanes;
            break;
        case RotationType3D_ImproveXZPlanes:
            mWarpTransformType3D = TransformType3D_ImproveXZPlanes;
            break;
        default:
            switch (mDomainWarpType)
            {
            case DomainWarpType_OpenSimplex2:
            case DomainWarpType_OpenSimplex2Reduced:
                mWarpTransformType3D = TransformType3D_DefaultOpenSimplex2;
                break;
            default:
                mWarpTransformType3D = TransformType3D_None;
                break;
            }
            break;
        }
    }


    // Fractal FBm

    template <typename FNfloat>
    float GenFractalFBm(FNfloat x, FNfloat y)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = GenNoiseSingle(seed++, x, y);
            sum += noise * amp;
            amp *= Lerp(1.0f, FastMin(noise + 1, 2) * 0.5f, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }

    template <typename FNfloat>
    float GenFractalFBm(FNfloat x, FNfloat y, FNfloat z)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = GenNoiseSingle(seed++, x, y, z);
            sum += noise * amp;
            amp *= Lerp(1.0f, (noise + 1) * 0.5f, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            z *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }


    // Fractal Ridged

    template <typename FNfloat>
    float GenFractalRidged(FNfloat x, FNfloat y)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = FastAbs(GenNoiseSingle(seed++, x, y));
            sum += (noise * -2 + 1) * amp;
            amp *= Lerp(1.0f, 1 - noise, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }

    template <typename FNfloat>
    float GenFractalRidged(FNfloat x, FNfloat y, FNfloat z)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = FastAbs(GenNoiseSingle(seed++, x, y, z));
            sum += (noise * -2 + 1) * amp;
            amp *= Lerp(1.0f, 1 - noise, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            z *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }


    // Fractal PingPong 

    template <typename FNfloat>
    float GenFractalPingPong(FNfloat x, FNfloat y)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = PingPong((GenNoiseSingle(seed++, x, y) + 1) * mPingPongStength);
            sum += (noise - 0.5f) * 2 * amp;
            amp *= Lerp(1.0f, noise, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }

    template <typename FNfloat>
    float GenFractalPingPong(FNfloat x, FNfloat y, FNfloat z)
    {
        int seed = mSeed;
        float sum = 0;
        float amp = mFractalBounding;

        for (int i = 0; i < mOctaves; i++)
        {
            float noise = PingPong((GenNoiseSingle(seed++, x, y, z) + 1) * mPingPongStength);
            sum += (noise - 0.5f) * 2 * amp;
            amp *= Lerp(1.0f, noise, mWeightedStrength);

            x *= mLacunarity;
            y *= mLacunarity;
            z *= mLacunarity;
            amp *= mGain;
        }

        return sum;
    }


    // Simplex/OpenSimplex2 Noise

    template <typename FNfloat>
    float SingleSimplex(int seed, FNfloat x, FNfloat y)
    {
        // 2D OpenSimplex2 case uses the same algorithm as ordinary Simplex.

        const float SQRT3 = 1.7320508075688772935274463415059f;
        const float G2 = (3 - SQRT3) / 6;

        /*
         * --- Skew moved to TransformNoiseCoordinate method ---
         * const FNfloat F2 = 0.5f * (SQRT3 - 1);
         * FNfloat s = (x + y) * F2;
         * x += s; y += s;
        */

        int i = FastFloor(x);
        int j = FastFloor(y);
        float xi = (float)(x - i);
        float yi = (float)(y - j);

        float t = (xi + yi) * G2;
        float x0 = (float)(xi - t);
        float y0 = (float)(yi - t);

        i *= PrimeX;
        j *= PrimeY;

        float n0, n1, n2;

        float a = 0.5f - x0 * x0 - y0 * y0;
        if (a <= 0) n0 = 0;
        else
        {
            n0 = (a * a) * (a * a) * GradCoord(seed, i, j, x0, y0);
        }

        float c = (float)(2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((float)(-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        if (c <= 0) n2 = 0;
        else
        {
            float x2 = x0 + (2 * (float)G2 - 1);
            float y2 = y0 + (2 * (float)G2 - 1);
            n2 = (c * c) * (c * c) * GradCoord(seed, i + PrimeX, j + PrimeY, x2, y2);
        }

        if (y0 > x0)
        {
            float x1 = x0 + (float)G2;
            float y1 = y0 + ((float)G2 - 1);
            float b = 0.5f - x1 * x1 - y1 * y1;
            if (b <= 0) n1 = 0;
            else
            {
                n1 = (b * b) * (b * b) * GradCoord(seed, i, j + PrimeY, x1, y1);
            }
        }
        else
        {
            float x1 = x0 + ((float)G2 - 1);
            float y1 = y0 + (float)G2;
            float b = 0.5f - x1 * x1 - y1 * y1;
            if (b <= 0) n1 = 0;
            else
            {
                n1 = (b * b) * (b * b) * GradCoord(seed, i + PrimeX, j, x1, y1);
            }
        }

        return (n0 + n1 + n2) * 99.83685446303647f;
    }

    template <typename FNfloat>
    float SingleOpenSimplex2(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        // 3D OpenSimplex2 case uses two offset rotated cube grids.

        /*
         * --- Rotation moved to TransformNoiseCoordinate method ---
         * const FNfloat R3 = (FNfloat)(2.0 / 3.0);
         * FNfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
        */

        int i = FastRound(x);
        int j = FastRound(y);
        int k = FastRound(z);
        float x0 = (float)(x - i);
        float y0 = (float)(y - j);
        float z0 = (float)(z - k);

        int xNSign = (int)(-1.0f - x0) | 1;
        int yNSign = (int)(-1.0f - y0) | 1;
        int zNSign = (int)(-1.0f - z0) | 1;

        float ax0 = xNSign * -x0;
        float ay0 = yNSign * -y0;
        float az0 = zNSign * -z0;

        i *= PrimeX;
        j *= PrimeY;
        k *= PrimeZ;

        float value = 0;
        float a = (0.6f - x0 * x0) - (y0 * y0 + z0 * z0);

        for (int l = 0; ; l++)
        {
            if (a > 0)
            {
                value += (a * a) * (a * a) * GradCoord(seed, i, j, k, x0, y0, z0);
            }

            float b = a + 1;
            int i1 = i;
            int j1 = j;
            int k1 = k;
            float x1 = x0;
            float y1 = y0;
            float z1 = z0;

            if (ax0 >= ay0 && ax0 >= az0)
            {
                x1 += xNSign;
                b -= xNSign * 2 * x1;
                i1 -= xNSign * PrimeX;
            }
            else if (ay0 > ax0 && ay0 >= az0)
            {
                y1 += yNSign;
                b -= yNSign * 2 * y1;
                j1 -= yNSign * PrimeY;
            }
            else
            {
                z1 += zNSign;
                b -= zNSign * 2 * z1;
                k1 -= zNSign * PrimeZ;
            }

            if (b > 0)
            {
                value += (b * b) * (b * b) * GradCoord(seed, i1, j1, k1, x1, y1, z1);
            }

            if (l == 1) break;

            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;

            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;

            a += (0.75f - ax0) - (ay0 + az0);

            i += (xNSign >> 1) & PrimeX;
            j += (yNSign >> 1) & PrimeY;
            k += (zNSign >> 1) & PrimeZ;

            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            seed = ~seed;
        }

        return value * 32.69428253173828125f;
    }


    // OpenSimplex2S Noise

    template <typename FNfloat>
    float SingleOpenSimplex2S(int seed, FNfloat x, FNfloat y)
    {
        // 2D OpenSimplex2S case is a modified 2D simplex noise.

        const FNfloat SQRT3 = (FNfloat)1.7320508075688772935274463415059;
        const FNfloat G2 = (3 - SQRT3) / 6;

        /*
         * --- Skew moved to TransformNoiseCoordinate method ---
         * const FNfloat F2 = 0.5f * (SQRT3 - 1);
         * FNfloat s = (x + y) * F2;
         * x += s; y += s;
        */

        int i = FastFloor(x);
        int j = FastFloor(y);
        float xi = (float)(x - i);
        float yi = (float)(y - j);

        i *= PrimeX;
        j *= PrimeY;
        int i1 = i + PrimeX;
        int j1 = j + PrimeY;

        float t = (xi + yi) * (float)G2;
        float x0 = xi - t;
        float y0 = yi - t;

        float a0 = (2.0f / 3.0f) - x0 * x0 - y0 * y0;
        float value = (a0 * a0) * (a0 * a0) * GradCoord(seed, i, j, x0, y0);

        float a1 = (float)(2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((float)(-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a0);
        float x1 = x0 - (float)(1 - 2 * G2);
        float y1 = y0 - (float)(1 - 2 * G2);
        value += (a1 * a1) * (a1 * a1) * GradCoord(seed, i1, j1, x1, y1);

        // Nested conditionals were faster than compact bit logic/arithmetic.
        float xmyi = xi - yi;
        if (t > G2)
        {
            if (xi + xmyi > 1)
            {
                float x2 = x0 + (float)(3 * G2 - 2);
                float y2 = y0 + (float)(3 * G2 - 1);
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i + (PrimeX << 1), j + PrimeY, x2, y2);
                }
            }
            else
            {
                float x2 = x0 + (float)G2;
                float y2 = y0 + (float)(G2 - 1);
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i, j + PrimeY, x2, y2);
                }
            }

            if (yi - xmyi > 1)
            {
                float x3 = x0 + (float)(3 * G2 - 1);
                float y3 = y0 + (float)(3 * G2 - 2);
                float a3 = (2.0f / 3.0f) - x3 * x3 - y3 * y3;
                if (a3 > 0)
                {
                    value += (a3 * a3) * (a3 * a3) * GradCoord(seed, i + PrimeX, j + (PrimeY << 1), x3, y3);
                }
            }
            else
            {
                float x3 = x0 + (float)(G2 - 1);
                float y3 = y0 + (float)G2;
                float a3 = (2.0f / 3.0f) - x3 * x3 - y3 * y3;
                if (a3 > 0)
                {
                    value += (a3 * a3) * (a3 * a3) * GradCoord(seed, i + PrimeX, j, x3, y3);
                }
            }
        }
        else
        {
            if (xi + xmyi < 0)
            {
                float x2 = x0 + (float)(1 - G2);
                float y2 = y0 - (float)G2;
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i - PrimeX, j, x2, y2);
                }
            }
            else
            {
                float x2 = x0 + (float)(G2 - 1);
                float y2 = y0 + (float)G2;
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i + PrimeX, j, x2, y2);
                }
            }

            if (yi < xmyi)
            {
                float x2 = x0 - (float)G2;
                float y2 = y0 - (float)(G2 - 1);
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i, j - PrimeY, x2, y2);
                }
            }
            else
            {
                float x2 = x0 + (float)G2;
                float y2 = y0 + (float)(G2 - 1);
                float a2 = (2.0f / 3.0f) - x2 * x2 - y2 * y2;
                if (a2 > 0)
                {
                    value += (a2 * a2) * (a2 * a2) * GradCoord(seed, i, j + PrimeY, x2, y2);
                }
            }
        }

        return value * 18.24196194486065f;
    }

    template <typename FNfloat>
    float SingleOpenSimplex2S(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        // 3D OpenSimplex2S case uses two offset rotated cube grids.

        /*
         * --- Rotation moved to TransformNoiseCoordinate method ---
         * const FNfloat R3 = (FNfloat)(2.0 / 3.0);
         * FNfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
        */

        int i = FastFloor(x);
        int j = FastFloor(y);
        int k = FastFloor(z);
        float xi = (float)(x - i);
        float yi = (float)(y - j);
        float zi = (float)(z - k);

        i *= PrimeX;
        j *= PrimeY;
        k *= PrimeZ;
        int seed2 = seed + 1293373;

        int xNMask = (int)(-0.5f - xi);
        int yNMask = (int)(-0.5f - yi);
        int zNMask = (int)(-0.5f - zi);

        float x0 = xi + xNMask;
        float y0 = yi + yNMask;
        float z0 = zi + zNMask;
        float a0 = 0.75f - x0 * x0 - y0 * y0 - z0 * z0;
        float value = (a0 * a0) * (a0 * a0) * GradCoord(seed,
            i + (xNMask & PrimeX), j + (yNMask & PrimeY), k + (zNMask & PrimeZ), x0, y0, z0);

        float x1 = xi - 0.5f;
        float y1 = yi - 0.5f;
        float z1 = zi - 0.5f;
        float a1 = 0.75f - x1 * x1 - y1 * y1 - z1 * z1;
        value += (a1 * a1) * (a1 * a1) * GradCoord(seed2,
            i + PrimeX, j + PrimeY, k + PrimeZ, x1, y1, z1);

        float xAFlipMask0 = ((xNMask | 1) << 1) * x1;
        float yAFlipMask0 = ((yNMask | 1) << 1) * y1;
        float zAFlipMask0 = ((zNMask | 1) << 1) * z1;
        float xAFlipMask1 = (-2 - (xNMask << 2)) * x1 - 1.0f;
        float yAFlipMask1 = (-2 - (yNMask << 2)) * y1 - 1.0f;
        float zAFlipMask1 = (-2 - (zNMask << 2)) * z1 - 1.0f;

        bool skip5 = false;
        float a2 = xAFlipMask0 + a0;
        if (a2 > 0)
        {
            float x2 = x0 - (xNMask | 1);
            float y2 = y0;
            float z2 = z0;
            value += (a2 * a2) * (a2 * a2) * GradCoord(seed,
                i + (~xNMask & PrimeX), j + (yNMask & PrimeY), k + (zNMask & PrimeZ), x2, y2, z2);
        }
        else
        {
            float a3 = yAFlipMask0 + zAFlipMask0 + a0;
            if (a3 > 0)
            {
                float x3 = x0;
                float y3 = y0 - (yNMask | 1);
                float z3 = z0 - (zNMask | 1);
                value += (a3 * a3) * (a3 * a3) * GradCoord(seed,
                    i + (xNMask & PrimeX), j + (~yNMask & PrimeY), k + (~zNMask & PrimeZ), x3, y3, z3);
            }

            float a4 = xAFlipMask1 + a1;
            if (a4 > 0)
            {
                float x4 = (xNMask | 1) + x1;
                float y4 = y1;
                float z4 = z1;
                value += (a4 * a4) * (a4 * a4) * GradCoord(seed2,
                    i + (xNMask & (PrimeX * 2)), j + PrimeY, k + PrimeZ, x4, y4, z4);
                skip5 = true;
            }
        }

        bool skip9 = false;
        float a6 = yAFlipMask0 + a0;
        if (a6 > 0)
        {
            float x6 = x0;
            float y6 = y0 - (yNMask | 1);
            float z6 = z0;
            value += (a6 * a6) * (a6 * a6) * GradCoord(seed,
                i + (xNMask & PrimeX), j + (~yNMask & PrimeY), k + (zNMask & PrimeZ), x6, y6, z6);
        }
        else
        {
            float a7 = xAFlipMask0 + zAFlipMask0 + a0;
            if (a7 > 0)
            {
                float x7 = x0 - (xNMask | 1);
                float y7 = y0;
                float z7 = z0 - (zNMask | 1);
                value += (a7 * a7) * (a7 * a7) * GradCoord(seed,
                    i + (~xNMask & PrimeX), j + (yNMask & PrimeY), k + (~zNMask & PrimeZ), x7, y7, z7);
            }

            float a8 = yAFlipMask1 + a1;
            if (a8 > 0)
            {
                float x8 = x1;
                float y8 = (yNMask | 1) + y1;
                float z8 = z1;
                value += (a8 * a8) * (a8 * a8) * GradCoord(seed2,
                    i + PrimeX, j + (yNMask & (PrimeY << 1)), k + PrimeZ, x8, y8, z8);
                skip9 = true;
            }
        }

        bool skipD = false;
        float aA = zAFlipMask0 + a0;
        if (aA > 0)
        {
            float xA = x0;
            float yA = y0;
            float zA = z0 - (zNMask | 1);
            value += (aA * aA) * (aA * aA) * GradCoord(seed,
                i + (xNMask & PrimeX), j + (yNMask & PrimeY), k + (~zNMask & PrimeZ), xA, yA, zA);
        }
        else
        {
            float aB = xAFlipMask0 + yAFlipMask0 + a0;
            if (aB > 0)
            {
                float xB = x0 - (xNMask | 1);
                float yB = y0 - (yNMask | 1);
                float zB = z0;
                value += (aB * aB) * (aB * aB) * GradCoord(seed,
                    i + (~xNMask & PrimeX), j + (~yNMask & PrimeY), k + (zNMask & PrimeZ), xB, yB, zB);
            }

            float aC = zAFlipMask1 + a1;
            if (aC > 0)
            {
                float xC = x1;
                float yC = y1;
                float zC = (zNMask | 1) + z1;
                value += (aC * aC) * (aC * aC) * GradCoord(seed2,
                    i + PrimeX, j + PrimeY, k + (zNMask & (PrimeZ << 1)), xC, yC, zC);
                skipD = true;
            }
        }

        if (!skip5)
        {
            float a5 = yAFlipMask1 + zAFlipMask1 + a1;
            if (a5 > 0)
            {
                float x5 = x1;
                float y5 = (yNMask | 1) + y1;
                float z5 = (zNMask | 1) + z1;
                value += (a5 * a5) * (a5 * a5) * GradCoord(seed2,
                    i + PrimeX, j + (yNMask & (PrimeY << 1)), k + (zNMask & (PrimeZ << 1)), x5, y5, z5);
            }
        }

        if (!skip9)
        {
            float a9 = xAFlipMask1 + zAFlipMask1 + a1;
            if (a9 > 0)
            {
                float x9 = (xNMask | 1) + x1;
                float y9 = y1;
                float z9 = (zNMask | 1) + z1;
                value += (a9 * a9) * (a9 * a9) * GradCoord(seed2,
                    i + (xNMask & (PrimeX * 2)), j + PrimeY, k + (zNMask & (PrimeZ << 1)), x9, y9, z9);
            }
        }

        if (!skipD)
        {
            float aD = xAFlipMask1 + yAFlipMask1 + a1;
            if (aD > 0)
            {
                float xD = (xNMask | 1) + x1;
                float yD = (yNMask | 1) + y1;
                float zD = z1;
                value += (aD * aD) * (aD * aD) * GradCoord(seed2,
                    i + (xNMask & (PrimeX << 1)), j + (yNMask & (PrimeY << 1)), k + PrimeZ, xD, yD, zD);
            }
        }

        return value * 9.046026385208288f;
    }


    // Cellular Noise

    template <typename FNfloat>
    float SingleCellular(int seed, FNfloat x, FNfloat y)
    {
        int xr = FastRound(x);
        int yr = FastRound(y);

        float distance0 = 1e10f;
        float distance1 = 1e10f;
        int closestHash = 0;

        float cellularJitter = 0.43701595f * mCellularJitterModifier;

        int xPrimed = (xr - 1) * PrimeX;
        int yPrimedBase = (yr - 1) * PrimeY;

        switch (mCellularDistanceFunction)
        {
        default:
        case CellularDistanceFunction_Euclidean:
        case CellularDistanceFunction_EuclideanSq:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = Hash(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = (float)(xi - x) + Lookup<float>::RandVecs2D[idx] * cellularJitter;
                    float vecY = (float)(yi - y) + Lookup<float>::RandVecs2D[idx | 1] * cellularJitter;

                    float newDistance = vecX * vecX + vecY * vecY;

                    distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        case CellularDistanceFunction_Manhattan:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = Hash(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = (float)(xi - x) + Lookup<float>::RandVecs2D[idx] * cellularJitter;
                    float vecY = (float)(yi - y) + Lookup<float>::RandVecs2D[idx | 1] * cellularJitter;

                    float newDistance = FastAbs(vecX) + FastAbs(vecY);

                    distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        case CellularDistanceFunction_Hybrid:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int hash = Hash(seed, xPrimed, yPrimed);
                    int idx = hash & (255 << 1);

                    float vecX = (float)(xi - x) + Lookup<float>::RandVecs2D[idx] * cellularJitter;
                    float vecY = (float)(yi - y) + Lookup<float>::RandVecs2D[idx | 1] * cellularJitter;

                    float newDistance = (FastAbs(vecX) + FastAbs(vecY)) + (vecX * vecX + vecY * vecY);

                    distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                    if (newDistance < distance0)
                    {
                        distance0 = newDistance;
                        closestHash = hash;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        }

        if (mCellularDistanceFunction == CellularDistanceFunction_Euclidean && mCellularReturnType >= CellularReturnType_Distance)
        {
            distance0 = FastSqrt(distance0);

            if (mCellularReturnType >= CellularReturnType_Distance2)
            {
                distance1 = FastSqrt(distance1);
            }
        }

        switch (mCellularReturnType)
        {
        case CellularReturnType_CellValue:
            return closestHash * (1 / 2147483648.0f);
        case CellularReturnType_Distance:
            return distance0 - 1;
        case CellularReturnType_Distance2:
            return distance1 - 1;
        case CellularReturnType_Distance2Add:
            return (distance1 + distance0) * 0.5f - 1;
        case CellularReturnType_Distance2Sub:
            return distance1 - distance0 - 1;
        case CellularReturnType_Distance2Mul:
            return distance1 * distance0 * 0.5f - 1;
        case CellularReturnType_Distance2Div:
            return distance0 / distance1 - 1;
        default:
            return 0;
        }
    }

    template <typename FNfloat>
    float SingleCellular(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        int xr = FastRound(x);
        int yr = FastRound(y);
        int zr = FastRound(z);

        float distance0 = 1e10f;
        float distance1 = 1e10f;
        int closestHash = 0;

        float cellularJitter = 0.39614353f * mCellularJitterModifier;

        int xPrimed = (xr - 1) * PrimeX;
        int yPrimedBase = (yr - 1) * PrimeY;
        int zPrimedBase = (zr - 1) * PrimeZ;

        switch (mCellularDistanceFunction)
        {
        case CellularDistanceFunction_Euclidean:
        case CellularDistanceFunction_EuclideanSq:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int zPrimed = zPrimedBase;

                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                        int idx = hash & (255 << 2);

                        float vecX = (float)(xi - x) + Lookup<float>::RandVecs3D[idx] * cellularJitter;
                        float vecY = (float)(yi - y) + Lookup<float>::RandVecs3D[idx | 1] * cellularJitter;
                        float vecZ = (float)(zi - z) + Lookup<float>::RandVecs3D[idx | 2] * cellularJitter;

                        float newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                        distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        zPrimed += PrimeZ;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        case CellularDistanceFunction_Manhattan:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int zPrimed = zPrimedBase;

                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                        int idx = hash & (255 << 2);

                        float vecX = (float)(xi - x) + Lookup<float>::RandVecs3D[idx] * cellularJitter;
                        float vecY = (float)(yi - y) + Lookup<float>::RandVecs3D[idx | 1] * cellularJitter;
                        float vecZ = (float)(zi - z) + Lookup<float>::RandVecs3D[idx | 2] * cellularJitter;

                        float newDistance = FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ);

                        distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        zPrimed += PrimeZ;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        case CellularDistanceFunction_Hybrid:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                int yPrimed = yPrimedBase;

                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    int zPrimed = zPrimedBase;

                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        int hash = Hash(seed, xPrimed, yPrimed, zPrimed);
                        int idx = hash & (255 << 2);

                        float vecX = (float)(xi - x) + Lookup<float>::RandVecs3D[idx] * cellularJitter;
                        float vecY = (float)(yi - y) + Lookup<float>::RandVecs3D[idx | 1] * cellularJitter;
                        float vecZ = (float)(zi - z) + Lookup<float>::RandVecs3D[idx | 2] * cellularJitter;

                        float newDistance = (FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);

                        distance1 = FastMax(FastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0 = newDistance;
                            closestHash = hash;
                        }
                        zPrimed += PrimeZ;
                    }
                    yPrimed += PrimeY;
                }
                xPrimed += PrimeX;
            }
            break;
        default:
            break;
        }

        if (mCellularDistanceFunction == CellularDistanceFunction_Euclidean && mCellularReturnType >= CellularReturnType_Distance)
        {
            distance0 = FastSqrt(distance0);

            if (mCellularReturnType >= CellularReturnType_Distance2)
            {
                distance1 = FastSqrt(distance1);
            }
        }

        switch (mCellularReturnType)
        {
        case CellularReturnType_CellValue:
            return closestHash * (1 / 2147483648.0f);
        case CellularReturnType_Distance:
            return distance0 - 1;
        case CellularReturnType_Distance2:
            return distance1 - 1;
        case CellularReturnType_Distance2Add:
            return (distance1 + distance0) * 0.5f - 1;
        case CellularReturnType_Distance2Sub:
            return distance1 - distance0 - 1;
        case CellularReturnType_Distance2Mul:
            return distance1 * distance0 * 0.5f - 1;
        case CellularReturnType_Distance2Div:
            return distance0 / distance1 - 1;
        default:
            return 0;
        }
    }


    // Perlin Noise

    template <typename FNfloat>
    float SinglePerlin(int seed, FNfloat x, FNfloat y)
    {
        int x0 = FastFloor(x);
        int y0 = FastFloor(y);

        float xd0 = (float)(x - x0);
        float yd0 = (float)(y - y0);
        float xd1 = xd0 - 1;
        float yd1 = yd0 - 1;

        float xs = InterpQuintic(xd0);
        float ys = InterpQuintic(yd0);

        x0 *= PrimeX;
        y0 *= PrimeY;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;

        float xf0 = Lerp(GradCoord(seed, x0, y0, xd0, yd0), GradCoord(seed, x1, y0, xd1, yd0), xs);
        float xf1 = Lerp(GradCoord(seed, x0, y1, xd0, yd1), GradCoord(seed, x1, y1, xd1, yd1), xs);

        return Lerp(xf0, xf1, ys) * 1.4247691104677813f;
    }

    template <typename FNfloat>
    float SinglePerlin(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        int x0 = FastFloor(x);
        int y0 = FastFloor(y);
        int z0 = FastFloor(z);

        float xd0 = (float)(x - x0);
        float yd0 = (float)(y - y0);
        float zd0 = (float)(z - z0);
        float xd1 = xd0 - 1;
        float yd1 = yd0 - 1;
        float zd1 = zd0 - 1;

        float xs = InterpQuintic(xd0);
        float ys = InterpQuintic(yd0);
        float zs = InterpQuintic(zd0);

        x0 *= PrimeX;
        y0 *= PrimeY;
        z0 *= PrimeZ;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;
        int z1 = z0 + PrimeZ;

        float xf00 = Lerp(GradCoord(seed, x0, y0, z0, xd0, yd0, zd0), GradCoord(seed, x1, y0, z0, xd1, yd0, zd0), xs);
        float xf10 = Lerp(GradCoord(seed, x0, y1, z0, xd0, yd1, zd0), GradCoord(seed, x1, y1, z0, xd1, yd1, zd0), xs);
        float xf01 = Lerp(GradCoord(seed, x0, y0, z1, xd0, yd0, zd1), GradCoord(seed, x1, y0, z1, xd1, yd0, zd1), xs);
        float xf11 = Lerp(GradCoord(seed, x0, y1, z1, xd0, yd1, zd1), GradCoord(seed, x1, y1, z1, xd1, yd1, zd1), xs);

        float yf0 = Lerp(xf00, xf10, ys);
        float yf1 = Lerp(xf01, xf11, ys);

        return Lerp(yf0, yf1, zs) * 0.964921414852142333984375f;
    }


    // Value Cubic Noise

    template <typename FNfloat>
    float SingleValueCubic(int seed, FNfloat x, FNfloat y)
    {
        int x1 = FastFloor(x);
        int y1 = FastFloor(y);

        float xs = (float)(x - x1);
        float ys = (float)(y - y1);

        x1 *= PrimeX;
        y1 *= PrimeY;
        int x0 = x1 - PrimeX;
        int y0 = y1 - PrimeY;
        int x2 = x1 + PrimeX;
        int y2 = y1 + PrimeY;
        int x3 = x1 + (int)((long)PrimeX << 1);
        int y3 = y1 + (int)((long)PrimeY << 1);

        return CubicLerp(
            CubicLerp(ValCoord(seed, x0, y0), ValCoord(seed, x1, y0), ValCoord(seed, x2, y0), ValCoord(seed, x3, y0),
                xs),
            CubicLerp(ValCoord(seed, x0, y1), ValCoord(seed, x1, y1), ValCoord(seed, x2, y1), ValCoord(seed, x3, y1),
                xs),
            CubicLerp(ValCoord(seed, x0, y2), ValCoord(seed, x1, y2), ValCoord(seed, x2, y2), ValCoord(seed, x3, y2),
                xs),
            CubicLerp(ValCoord(seed, x0, y3), ValCoord(seed, x1, y3), ValCoord(seed, x2, y3), ValCoord(seed, x3, y3),
                xs),
            ys) * (1 / (1.5f * 1.5f));
    }

    template <typename FNfloat>
    float SingleValueCubic(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        int x1 = FastFloor(x);
        int y1 = FastFloor(y);
        int z1 = FastFloor(z);

        float xs = (float)(x - x1);
        float ys = (float)(y - y1);
        float zs = (float)(z - z1);

        x1 *= PrimeX;
        y1 *= PrimeY;
        z1 *= PrimeZ;

        int x0 = x1 - PrimeX;
        int y0 = y1 - PrimeY;
        int z0 = z1 - PrimeZ;
        int x2 = x1 + PrimeX;
        int y2 = y1 + PrimeY;
        int z2 = z1 + PrimeZ;
        int x3 = x1 + (int)((long)PrimeX << 1);
        int y3 = y1 + (int)((long)PrimeY << 1);
        int z3 = z1 + (int)((long)PrimeZ << 1);


        return CubicLerp(
            CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z0), ValCoord(seed, x1, y0, z0), ValCoord(seed, x2, y0, z0), ValCoord(seed, x3, y0, z0), xs),
                CubicLerp(ValCoord(seed, x0, y1, z0), ValCoord(seed, x1, y1, z0), ValCoord(seed, x2, y1, z0), ValCoord(seed, x3, y1, z0), xs),
                CubicLerp(ValCoord(seed, x0, y2, z0), ValCoord(seed, x1, y2, z0), ValCoord(seed, x2, y2, z0), ValCoord(seed, x3, y2, z0), xs),
                CubicLerp(ValCoord(seed, x0, y3, z0), ValCoord(seed, x1, y3, z0), ValCoord(seed, x2, y3, z0), ValCoord(seed, x3, y3, z0), xs),
                ys),
            CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z1), ValCoord(seed, x1, y0, z1), ValCoord(seed, x2, y0, z1), ValCoord(seed, x3, y0, z1), xs),
                CubicLerp(ValCoord(seed, x0, y1, z1), ValCoord(seed, x1, y1, z1), ValCoord(seed, x2, y1, z1), ValCoord(seed, x3, y1, z1), xs),
                CubicLerp(ValCoord(seed, x0, y2, z1), ValCoord(seed, x1, y2, z1), ValCoord(seed, x2, y2, z1), ValCoord(seed, x3, y2, z1), xs),
                CubicLerp(ValCoord(seed, x0, y3, z1), ValCoord(seed, x1, y3, z1), ValCoord(seed, x2, y3, z1), ValCoord(seed, x3, y3, z1), xs),
                ys),
            CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z2), ValCoord(seed, x1, y0, z2), ValCoord(seed, x2, y0, z2), ValCoord(seed, x3, y0, z2), xs),
                CubicLerp(ValCoord(seed, x0, y1, z2), ValCoord(seed, x1, y1, z2), ValCoord(seed, x2, y1, z2), ValCoord(seed, x3, y1, z2), xs),
                CubicLerp(ValCoord(seed, x0, y2, z2), ValCoord(seed, x1, y2, z2), ValCoord(seed, x2, y2, z2), ValCoord(seed, x3, y2, z2), xs),
                CubicLerp(ValCoord(seed, x0, y3, z2), ValCoord(seed, x1, y3, z2), ValCoord(seed, x2, y3, z2), ValCoord(seed, x3, y3, z2), xs),
                ys),
            CubicLerp(
                CubicLerp(ValCoord(seed, x0, y0, z3), ValCoord(seed, x1, y0, z3), ValCoord(seed, x2, y0, z3), ValCoord(seed, x3, y0, z3), xs),
                CubicLerp(ValCoord(seed, x0, y1, z3), ValCoord(seed, x1, y1, z3), ValCoord(seed, x2, y1, z3), ValCoord(seed, x3, y1, z3), xs),
                CubicLerp(ValCoord(seed, x0, y2, z3), ValCoord(seed, x1, y2, z3), ValCoord(seed, x2, y2, z3), ValCoord(seed, x3, y2, z3), xs),
                CubicLerp(ValCoord(seed, x0, y3, z3), ValCoord(seed, x1, y3, z3), ValCoord(seed, x2, y3, z3), ValCoord(seed, x3, y3, z3), xs),
                ys),
            zs) * (1 / (1.5f * 1.5f * 1.5f));
    }


    // Value Noise

    template <typename FNfloat>
    float SingleValue(int seed, FNfloat x, FNfloat y)
    {
        int x0 = FastFloor(x);
        int y0 = FastFloor(y);

        float xs = InterpHermite((float)(x - x0));
        float ys = InterpHermite((float)(y - y0));

        x0 *= PrimeX;
        y0 *= PrimeY;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;

        float xf0 = Lerp(ValCoord(seed, x0, y0), ValCoord(seed, x1, y0), xs);
        float xf1 = Lerp(ValCoord(seed, x0, y1), ValCoord(seed, x1, y1), xs);

        return Lerp(xf0, xf1, ys);
    }

    template <typename FNfloat>
    float SingleValue(int seed, FNfloat x, FNfloat y, FNfloat z)
    {
        int x0 = FastFloor(x);
        int y0 = FastFloor(y);
        int z0 = FastFloor(z);

        float xs = InterpHermite((float)(x - x0));
        float ys = InterpHermite((float)(y - y0));
        float zs = InterpHermite((float)(z - z0));

        x0 *= PrimeX;
        y0 *= PrimeY;
        z0 *= PrimeZ;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;
        int z1 = z0 + PrimeZ;

        float xf00 = Lerp(ValCoord(seed, x0, y0, z0), ValCoord(seed, x1, y0, z0), xs);
        float xf10 = Lerp(ValCoord(seed, x0, y1, z0), ValCoord(seed, x1, y1, z0), xs);
        float xf01 = Lerp(ValCoord(seed, x0, y0, z1), ValCoord(seed, x1, y0, z1), xs);
        float xf11 = Lerp(ValCoord(seed, x0, y1, z1), ValCoord(seed, x1, y1, z1), xs);

        float yf0 = Lerp(xf00, xf10, ys);
        float yf1 = Lerp(xf01, xf11, ys);

        return Lerp(yf0, yf1, zs);
    }


    // Domain Warp

    template <typename FNfloat>
    void DoSingleDomainWarp(int seed, float amp, float freq, FNfloat x, FNfloat y, FNfloat& xr, FNfloat& yr)
    {
        switch (mDomainWarpType)
        {
        case DomainWarpType_OpenSimplex2:
            SingleDomainWarpSimplexGradient(seed, amp * 38.283687591552734375f, freq, x, y, xr, yr, false);
            break;
        case DomainWarpType_OpenSimplex2Reduced:
            SingleDomainWarpSimplexGradient(seed, amp * 16.0f, freq, x, y, xr, yr, true);
            break;
        case DomainWarpType_BasicGrid:
            SingleDomainWarpBasicGrid(seed, amp, freq, x, y, xr, yr);
            break;
        }
    }

    template <typename FNfloat>
    void DoSingleDomainWarp(int seed, float amp, float freq, FNfloat x, FNfloat y, FNfloat z, FNfloat& xr, FNfloat& yr, FNfloat& zr)
    {
        switch (mDomainWarpType)
        {
        case DomainWarpType_OpenSimplex2:
            SingleDomainWarpOpenSimplex2Gradient(seed, amp * 32.69428253173828125f, freq, x, y, z, xr, yr, zr, false);
            break;
        case DomainWarpType_OpenSimplex2Reduced:
            SingleDomainWarpOpenSimplex2Gradient(seed, amp * 7.71604938271605f, freq, x, y, z, xr, yr, zr, true);
            break;
        case DomainWarpType_BasicGrid:
            SingleDomainWarpBasicGrid(seed, amp, freq, x, y, z, xr, yr, zr);
            break;
        }
    }


    // Domain Warp Single Wrapper

    template <typename FNfloat>
    void DomainWarpSingle(FNfloat& x, FNfloat& y)
    {
        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        FNfloat xs = x;
        FNfloat ys = y;
        TransformDomainWarpCoordinate(xs, ys);

        DoSingleDomainWarp(seed, amp, freq, xs, ys, x, y);
    }

    template <typename FNfloat>
    void DomainWarpSingle(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        FNfloat xs = x;
        FNfloat ys = y;
        FNfloat zs = z;
        TransformDomainWarpCoordinate(xs, ys, zs);

        DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, x, y, z);
    }


    // Domain Warp Fractal Progressive

    template <typename FNfloat>
    void DomainWarpFractalProgressive(FNfloat& x, FNfloat& y)
    {
        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        for (int i = 0; i < mOctaves; i++)
        {
            FNfloat xs = x;
            FNfloat ys = y;
            TransformDomainWarpCoordinate(xs, ys);

            DoSingleDomainWarp(seed, amp, freq, xs, ys, x, y);

            seed++;
            amp *= mGain;
            freq *= mLacunarity;
        }
    }

    template <typename FNfloat>
    void DomainWarpFractalProgressive(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        for (int i = 0; i < mOctaves; i++)
        {
            FNfloat xs = x;
            FNfloat ys = y;
            FNfloat zs = z;
            TransformDomainWarpCoordinate(xs, ys, zs);

            DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, x, y, z);

            seed++;
            amp *= mGain;
            freq *= mLacunarity;
        }
    }


    // Domain Warp Fractal Independant

    template <typename FNfloat>
    void DomainWarpFractalIndependent(FNfloat& x, FNfloat& y)
    {
        FNfloat xs = x;
        FNfloat ys = y;
        TransformDomainWarpCoordinate(xs, ys);

        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        for (int i = 0; i < mOctaves; i++)
        {
            DoSingleDomainWarp(seed, amp, freq, xs, ys, x, y);

            seed++;
            amp *= mGain;
            freq *= mLacunarity;
        }
    }

    template <typename FNfloat>
    void DomainWarpFractalIndependent(FNfloat& x, FNfloat& y, FNfloat& z)
    {
        FNfloat xs = x;
        FNfloat ys = y;
        FNfloat zs = z;
        TransformDomainWarpCoordinate(xs, ys, zs);

        int seed = mSeed;
        float amp = mDomainWarpAmp * mFractalBounding;
        float freq = mFrequency;

        for (int i = 0; i < mOctaves; i++)
        {
            DoSingleDomainWarp(seed, amp, freq, xs, ys, zs, x, y, z);

            seed++;
            amp *= mGain;
            freq *= mLacunarity;
        }
    }


    // Domain Warp Basic Grid

    template <typename FNfloat>
    void SingleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat& xr, FNfloat& yr)
    {
        FNfloat xf = x * frequency;
        FNfloat yf = y * frequency;

        int x0 = FastFloor(xf);
        int y0 = FastFloor(yf);

        float xs = InterpHermite((float)(xf - x0));
        float ys = InterpHermite((float)(yf - y0));

        x0 *= PrimeX;
        y0 *= PrimeY;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;

        int hash0 = Hash(seed, x0, y0) & (255 << 1);
        int hash1 = Hash(seed, x1, y0) & (255 << 1);

        float lx0x = Lerp(Lookup<float>::RandVecs2D[hash0], Lookup<float>::RandVecs2D[hash1], xs);
        float ly0x = Lerp(Lookup<float>::RandVecs2D[hash0 | 1], Lookup<float>::RandVecs2D[hash1 | 1], xs);

        hash0 = Hash(seed, x0, y1) & (255 << 1);
        hash1 = Hash(seed, x1, y1) & (255 << 1);

        float lx1x = Lerp(Lookup<float>::RandVecs2D[hash0], Lookup<float>::RandVecs2D[hash1], xs);
        float ly1x = Lerp(Lookup<float>::RandVecs2D[hash0 | 1], Lookup<float>::RandVecs2D[hash1 | 1], xs);

        xr += Lerp(lx0x, lx1x, ys) * warpAmp;
        yr += Lerp(ly0x, ly1x, ys) * warpAmp;
    }

    template <typename FNfloat>
    void SingleDomainWarpBasicGrid(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat z, FNfloat& xr, FNfloat& yr, FNfloat& zr)
    {
        FNfloat xf = x * frequency;
        FNfloat yf = y * frequency;
        FNfloat zf = z * frequency;

        int x0 = FastFloor(xf);
        int y0 = FastFloor(yf);
        int z0 = FastFloor(zf);

        float xs = InterpHermite((float)(xf - x0));
        float ys = InterpHermite((float)(yf - y0));
        float zs = InterpHermite((float)(zf - z0));

        x0 *= PrimeX;
        y0 *= PrimeY;
        z0 *= PrimeZ;
        int x1 = x0 + PrimeX;
        int y1 = y0 + PrimeY;
        int z1 = z0 + PrimeZ;

        int hash0 = Hash(seed, x0, y0, z0) & (255 << 2);
        int hash1 = Hash(seed, x1, y0, z0) & (255 << 2);

        float lx0x = Lerp(Lookup<float>::RandVecs3D[hash0], Lookup<float>::RandVecs3D[hash1], xs);
        float ly0x = Lerp(Lookup<float>::RandVecs3D[hash0 | 1], Lookup<float>::RandVecs3D[hash1 | 1], xs);
        float lz0x = Lerp(Lookup<float>::RandVecs3D[hash0 | 2], Lookup<float>::RandVecs3D[hash1 | 2], xs);

        hash0 = Hash(seed, x0, y1, z0) & (255 << 2);
        hash1 = Hash(seed, x1, y1, z0) & (255 << 2);

        float lx1x = Lerp(Lookup<float>::RandVecs3D[hash0], Lookup<float>::RandVecs3D[hash1], xs);
        float ly1x = Lerp(Lookup<float>::RandVecs3D[hash0 | 1], Lookup<float>::RandVecs3D[hash1 | 1], xs);
        float lz1x = Lerp(Lookup<float>::RandVecs3D[hash0 | 2], Lookup<float>::RandVecs3D[hash1 | 2], xs);

        float lx0y = Lerp(lx0x, lx1x, ys);
        float ly0y = Lerp(ly0x, ly1x, ys);
        float lz0y = Lerp(lz0x, lz1x, ys);

        hash0 = Hash(seed, x0, y0, z1) & (255 << 2);
        hash1 = Hash(seed, x1, y0, z1) & (255 << 2);

        lx0x = Lerp(Lookup<float>::RandVecs3D[hash0], Lookup<float>::RandVecs3D[hash1], xs);
        ly0x = Lerp(Lookup<float>::RandVecs3D[hash0 | 1], Lookup<float>::RandVecs3D[hash1 | 1], xs);
        lz0x = Lerp(Lookup<float>::RandVecs3D[hash0 | 2], Lookup<float>::RandVecs3D[hash1 | 2], xs);

        hash0 = Hash(seed, x0, y1, z1) & (255 << 2);
        hash1 = Hash(seed, x1, y1, z1) & (255 << 2);

        lx1x = Lerp(Lookup<float>::RandVecs3D[hash0], Lookup<float>::RandVecs3D[hash1], xs);
        ly1x = Lerp(Lookup<float>::RandVecs3D[hash0 | 1], Lookup<float>::RandVecs3D[hash1 | 1], xs);
        lz1x = Lerp(Lookup<float>::RandVecs3D[hash0 | 2], Lookup<float>::RandVecs3D[hash1 | 2], xs);

        xr += Lerp(lx0y, Lerp(lx0x, lx1x, ys), zs) * warpAmp;
        yr += Lerp(ly0y, Lerp(ly0x, ly1x, ys), zs) * warpAmp;
        zr += Lerp(lz0y, Lerp(lz0x, lz1x, ys), zs) * warpAmp;
    }


    // Domain Warp Simplex/OpenSimplex2

    template <typename FNfloat>
    void SingleDomainWarpSimplexGradient(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat& xr, FNfloat& yr, bool outGradOnly)
    {
        const float SQRT3 = 1.7320508075688772935274463415059f;
        const float G2 = (3 - SQRT3) / 6;

        x *= frequency;
        y *= frequency;

        /*
         * --- Skew moved to TransformNoiseCoordinate method ---
         * const FNfloat F2 = 0.5f * (SQRT3 - 1);
         * FNfloat s = (x + y) * F2;
         * x += s; y += s;
        */

        int i = FastFloor(x);
        int j = FastFloor(y);
        float xi = (float)(x - i);
        float yi = (float)(y - j);

        float t = (xi + yi) * G2;
        float x0 = (float)(xi - t);
        float y0 = (float)(yi - t);

        i *= PrimeX;
        j *= PrimeY;

        float vx, vy;
        vx = vy = 0;

        float a = 0.5f - x0 * x0 - y0 * y0;
        if (a > 0)
        {
            float aaaa = (a * a) * (a * a);
            float xo, yo;
            if (outGradOnly)
                GradCoordOut(seed, i, j, xo, yo);
            else
                GradCoordDual(seed, i, j, x0, y0, xo, yo);
            vx += aaaa * xo;
            vy += aaaa * yo;
        }

        float c = (float)(2 * (1 - 2 * G2) * (1 / G2 - 2)) * t + ((float)(-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        if (c > 0)
        {
            float x2 = x0 + (2 * (float)G2 - 1);
            float y2 = y0 + (2 * (float)G2 - 1);
            float cccc = (c * c) * (c * c);
            float xo, yo;
            if (outGradOnly)
                GradCoordOut(seed, i + PrimeX, j + PrimeY, xo, yo);
            else
                GradCoordDual(seed, i + PrimeX, j + PrimeY, x2, y2, xo, yo);
            vx += cccc * xo;
            vy += cccc * yo;
        }

        if (y0 > x0)
        {
            float x1 = x0 + (float)G2;
            float y1 = y0 + ((float)G2 - 1);
            float b = 0.5f - x1 * x1 - y1 * y1;
            if (b > 0)
            {
                float bbbb = (b * b) * (b * b);
                float xo, yo;
                if (outGradOnly)
                    GradCoordOut(seed, i, j + PrimeY, xo, yo);
                else
                    GradCoordDual(seed, i, j + PrimeY, x1, y1, xo, yo);
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }
        else
        {
            float x1 = x0 + ((float)G2 - 1);
            float y1 = y0 + (float)G2;
            float b = 0.5f - x1 * x1 - y1 * y1;
            if (b > 0)
            {
                float bbbb = (b * b) * (b * b);
                float xo, yo;
                if (outGradOnly)
                    GradCoordOut(seed, i + PrimeX, j, xo, yo);
                else
                    GradCoordDual(seed, i + PrimeX, j, x1, y1, xo, yo);
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }

        xr += vx * warpAmp;
        yr += vy * warpAmp;
    }

    template <typename FNfloat>
    void SingleDomainWarpOpenSimplex2Gradient(int seed, float warpAmp, float frequency, FNfloat x, FNfloat y, FNfloat z, FNfloat& xr, FNfloat& yr, FNfloat& zr, bool outGradOnly)
    {
        x *= frequency;
        y *= frequency;
        z *= frequency;

        /*
         * --- Rotation moved to TransformDomainWarpCoordinate method ---
         * const FNfloat R3 = (FNfloat)(2.0 / 3.0);
         * FNfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
        */

        int i = FastRound(x);
        int j = FastRound(y);
        int k = FastRound(z);
        float x0 = (float)x - i;
        float y0 = (float)y - j;
        float z0 = (float)z - k;

        int xNSign = (int)(-x0 - 1.0f) | 1;
        int yNSign = (int)(-y0 - 1.0f) | 1;
        int zNSign = (int)(-z0 - 1.0f) | 1;

        float ax0 = xNSign * -x0;
        float ay0 = yNSign * -y0;
        float az0 = zNSign * -z0;

        i *= PrimeX;
        j *= PrimeY;
        k *= PrimeZ;

        float vx, vy, vz;
        vx = vy = vz = 0;

        float a = (0.6f - x0 * x0) - (y0 * y0 + z0 * z0);
        for (int l = 0; l < 2; l++)
        {
            if (a > 0)
            {
                float aaaa = (a * a) * (a * a);
                float xo, yo, zo;
                if (outGradOnly)
                    GradCoordOut(seed, i, j, k, xo, yo, zo);
                else
                    GradCoordDual(seed, i, j, k, x0, y0, z0, xo, yo, zo);
                vx += aaaa * xo;
                vy += aaaa * yo;
                vz += aaaa * zo;
            }

            float b = a + 1;
            int i1 = i;
            int j1 = j;
            int k1 = k;
            float x1 = x0;
            float y1 = y0;
            float z1 = z0;

            if (ax0 >= ay0 && ax0 >= az0)
            {
                x1 += xNSign;
                b -= xNSign * 2 * x1;
                i1 -= xNSign * PrimeX;
            }
            else if (ay0 > ax0 && ay0 >= az0)
            {
                y1 += yNSign;
                b -= yNSign * 2 * y1;
                j1 -= yNSign * PrimeY;
            }
            else
            {
                z1 += zNSign;
                b -= zNSign * 2 * z1;
                k1 -= zNSign * PrimeZ;
            }

            if (b > 0)
            {
                float bbbb = (b * b) * (b * b);
                float xo, yo, zo;
                if (outGradOnly)
                    GradCoordOut(seed, i1, j1, k1, xo, yo, zo);
                else
                    GradCoordDual(seed, i1, j1, k1, x1, y1, z1, xo, yo, zo);
                vx += bbbb * xo;
                vy += bbbb * yo;
                vz += bbbb * zo;
            }

            if (l == 1) break;

            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;

            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;

            a += (0.75f - ax0) - (ay0 + az0);

            i += (xNSign >> 1) & PrimeX;
            j += (yNSign >> 1) & PrimeY;
            k += (zNSign >> 1) & PrimeZ;

            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            seed += 1293373;
        }

        xr += vx * warpAmp;
        yr += vy * warpAmp;
        zr += vz * warpAmp;
    }
};

template <>
struct FastNoiseLite::Arguments_must_be_floating_point_values<float> {};
template <>
struct FastNoiseLite::Arguments_must_be_floating_point_values<double> {};
template <>
struct FastNoiseLite::Arguments_must_be_floating_point_values<long double> {};

template <typename T>
const T FastNoiseLite::Lookup<T>::Gradients2D[] =
{
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.130526192220052f, 0.99144486137381f, 0.38268343236509f, 0.923879532511287f, 0.608761429008721f, 0.793353340291235f, 0.793353340291235f, 0.608761429008721f,
    0.923879532511287f, 0.38268343236509f, 0.99144486137381f, 0.130526192220051f, 0.99144486137381f, -0.130526192220051f, 0.923879532511287f, -0.38268343236509f,
    0.793353340291235f, -0.60876142900872f, 0.608761429008721f, -0.793353340291235f, 0.38268343236509f, -0.923879532511287f, 0.130526192220052f, -0.99144486137381f,
    -0.130526192220052f, -0.99144486137381f, -0.38268343236509f, -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
    -0.923879532511287f, -0.38268343236509f, -0.99144486137381f, -0.130526192220052f, -0.99144486137381f, 0.130526192220051f, -0.923879532511287f, 0.38268343236509f,
    -0.793353340291235f, 0.608761429008721f, -0.608761429008721f, 0.793353340291235f, -0.38268343236509f, 0.923879532511287f, -0.130526192220052f, 0.99144486137381f,
    0.38268343236509f, 0.923879532511287f, 0.923879532511287f, 0.38268343236509f, 0.923879532511287f, -0.38268343236509f, 0.38268343236509f, -0.923879532511287f,
    -0.38268343236509f, -0.923879532511287f, -0.923879532511287f, -0.38268343236509f, -0.923879532511287f, 0.38268343236509f, -0.38268343236509f, 0.923879532511287f,
};

template <typename T>
const T FastNoiseLite::Lookup<T>::RandVecs2D[] =
{
    -0.2700222198f, -0.9628540911f, 0.3863092627f, -0.9223693152f, 0.04444859006f, -0.999011673f, -0.5992523158f, -0.8005602176f, -0.7819280288f, 0.6233687174f, 0.9464672271f, 0.3227999196f, -0.6514146797f, -0.7587218957f, 0.9378472289f, 0.347048376f,
    -0.8497875957f, -0.5271252623f, -0.879042592f, 0.4767432447f, -0.892300288f, -0.4514423508f, -0.379844434f, -0.9250503802f, -0.9951650832f, 0.0982163789f, 0.7724397808f, -0.6350880136f, 0.7573283322f, -0.6530343002f, -0.9928004525f, -0.119780055f,
    -0.0532665713f, 0.9985803285f, 0.9754253726f, -0.2203300762f, -0.7665018163f, 0.6422421394f, 0.991636706f, 0.1290606184f, -0.994696838f, 0.1028503788f, -0.5379205513f, -0.84299554f, 0.5022815471f, -0.8647041387f, 0.4559821461f, -0.8899889226f,
    -0.8659131224f, -0.5001944266f, 0.0879458407f, -0.9961252577f, -0.5051684983f, 0.8630207346f, 0.7753185226f, -0.6315704146f, -0.6921944612f, 0.7217110418f, -0.5191659449f, -0.8546734591f, 0.8978622882f, -0.4402764035f, -0.1706774107f, 0.9853269617f,
    -0.9353430106f, -0.3537420705f, -0.9992404798f, 0.03896746794f, -0.2882064021f, -0.9575683108f, -0.9663811329f, 0.2571137995f, -0.8759714238f, -0.4823630009f, -0.8303123018f, -0.5572983775f, 0.05110133755f, -0.9986934731f, -0.8558373281f, -0.5172450752f,
    0.09887025282f, 0.9951003332f, 0.9189016087f, 0.3944867976f, -0.2439375892f, -0.9697909324f, -0.8121409387f, -0.5834613061f, -0.9910431363f, 0.1335421355f, 0.8492423985f, -0.5280031709f, -0.9717838994f, -0.2358729591f, 0.9949457207f, 0.1004142068f,
    0.6241065508f, -0.7813392434f, 0.662910307f, 0.7486988212f, -0.7197418176f, 0.6942418282f, -0.8143370775f, -0.5803922158f, 0.104521054f, -0.9945226741f, -0.1065926113f, -0.9943027784f, 0.445799684f, -0.8951327509f, 0.105547406f, 0.9944142724f,
    -0.992790267f, 0.1198644477f, -0.8334366408f, 0.552615025f, 0.9115561563f, -0.4111755999f, 0.8285544909f, -0.5599084351f, 0.7217097654f, -0.6921957921f, 0.4940492677f, -0.8694339084f, -0.3652321272f, -0.9309164803f, -0.9696606758f, 0.2444548501f,
    0.08925509731f, -0.996008799f, 0.5354071276f, -0.8445941083f, -0.1053576186f, 0.9944343981f, -0.9890284586f, 0.1477251101f, 0.004856104961f, 0.9999882091f, 0.9885598478f, 0.1508291331f, 0.9286129562f, -0.3710498316f, -0.5832393863f, -0.8123003252f,
    0.3015207509f, 0.9534596146f, -0.9575110528f, 0.2883965738f, 0.9715802154f, -0.2367105511f, 0.229981792f, 0.9731949318f, 0.955763816f, -0.2941352207f, 0.740956116f, 0.6715534485f, -0.9971513787f, -0.07542630764f, 0.6905710663f, -0.7232645452f,
    -0.290713703f, -0.9568100872f, 0.5912777791f, -0.8064679708f, -0.9454592212f, -0.325740481f, 0.6664455681f, 0.74555369f, 0.6236134912f, 0.7817328275f, 0.9126993851f, -0.4086316587f, -0.8191762011f, 0.5735419353f, -0.8812745759f, -0.4726046147f,
    0.9953313627f, 0.09651672651f, 0.9855650846f, -0.1692969699f, -0.8495980887f, 0.5274306472f, 0.6174853946f, -0.7865823463f, 0.8508156371f, 0.52546432f, 0.9985032451f, -0.05469249926f, 0.1971371563f, -0.9803759185f, 0.6607855748f, -0.7505747292f,
    -0.03097494063f, 0.9995201614f, -0.6731660801f, 0.739491331f, -0.7195018362f, -0.6944905383f, 0.9727511689f, 0.2318515979f, 0.9997059088f, -0.0242506907f, 0.4421787429f, -0.8969269532f, 0.9981350961f, -0.061043673f, -0.9173660799f, -0.3980445648f,
    -0.8150056635f, -0.5794529907f, -0.8789331304f, 0.4769450202f, 0.0158605829f, 0.999874213f, -0.8095464474f, 0.5870558317f, -0.9165898907f, -0.3998286786f, -0.8023542565f, 0.5968480938f, -0.5176737917f, 0.8555780767f, -0.8154407307f, -0.5788405779f,
    0.4022010347f, -0.9155513791f, -0.9052556868f, -0.4248672045f, 0.7317445619f, 0.6815789728f, -0.5647632201f, -0.8252529947f, -0.8403276335f, -0.5420788397f, -0.9314281527f, 0.363925262f, 0.5238198472f, 0.8518290719f, 0.7432803869f, -0.6689800195f,
    -0.985371561f, -0.1704197369f, 0.4601468731f, 0.88784281f, 0.825855404f, 0.5638819483f, 0.6182366099f, 0.7859920446f, 0.8331502863f, -0.553046653f, 0.1500307506f, 0.9886813308f, -0.662330369f, -0.7492119075f, -0.668598664f, 0.743623444f,
    0.7025606278f, 0.7116238924f, -0.5419389763f, -0.8404178401f, -0.3388616456f, 0.9408362159f, 0.8331530315f, 0.5530425174f, -0.2989720662f, -0.9542618632f, 0.2638522993f, 0.9645630949f, 0.124108739f, -0.9922686234f, -0.7282649308f, -0.6852956957f,
    0.6962500149f, 0.7177993569f, -0.9183535368f, 0.3957610156f, -0.6326102274f, -0.7744703352f, -0.9331891859f, -0.359385508f, -0.1153779357f, -0.9933216659f, 0.9514974788f, -0.3076565421f, -0.08987977445f, -0.9959526224f, 0.6678496916f, 0.7442961705f,
    0.7952400393f, -0.6062947138f, -0.6462007402f, -0.7631674805f, -0.2733598753f, 0.9619118351f, 0.9669590226f, -0.254931851f, -0.9792894595f, 0.2024651934f, -0.5369502995f, -0.8436138784f, -0.270036471f, -0.9628500944f, -0.6400277131f, 0.7683518247f,
    -0.7854537493f, -0.6189203566f, 0.06005905383f, -0.9981948257f, -0.02455770378f, 0.9996984141f, -0.65983623f, 0.751409442f, -0.6253894466f, -0.7803127835f, -0.6210408851f, -0.7837781695f, 0.8348888491f, 0.5504185768f, -0.1592275245f, 0.9872419133f,
    0.8367622488f, 0.5475663786f, -0.8675753916f, -0.4973056806f, -0.2022662628f, -0.9793305667f, 0.9399189937f, 0.3413975472f, 0.9877404807f, -0.1561049093f, -0.9034455656f, 0.4287028224f, 0.1269804218f, -0.9919052235f, -0.3819600854f, 0.924178821f,
    0.9754625894f, 0.2201652486f, -0.3204015856f, -0.9472818081f, -0.9874760884f, 0.1577687387f, 0.02535348474f, -0.9996785487f, 0.4835130794f, -0.8753371362f, -0.2850799925f, -0.9585037287f, -0.06805516006f, -0.99768156f, -0.7885244045f, -0.6150034663f,
    0.3185392127f, -0.9479096845f, 0.8880043089f, 0.4598351306f, 0.6476921488f, -0.7619021462f, 0.9820241299f, 0.1887554194f, 0.9357275128f, -0.3527237187f, -0.8894895414f, 0.4569555293f, 0.7922791302f, 0.6101588153f, 0.7483818261f, 0.6632681526f,
    -0.7288929755f, -0.6846276581f, 0.8729032783f, -0.4878932944f, 0.8288345784f, 0.5594937369f, 0.08074567077f, 0.9967347374f, 0.9799148216f, -0.1994165048f, -0.580730673f, -0.8140957471f, -0.4700049791f, -0.8826637636f, 0.2409492979f, 0.9705377045f,
    0.9437816757f, -0.3305694308f, -0.8927998638f, -0.4504535528f, -0.8069622304f, 0.5906030467f, 0.06258973166f, 0.9980393407f, -0.9312597469f, 0.3643559849f, 0.5777449785f, 0.8162173362f, -0.3360095855f, -0.941858566f, 0.697932075f, -0.7161639607f,
    -0.002008157227f, -0.9999979837f, -0.1827294312f, -0.9831632392f, -0.6523911722f, 0.7578824173f, -0.4302626911f, -0.9027037258f, -0.9985126289f, -0.05452091251f, -0.01028102172f, -0.9999471489f, -0.4946071129f, 0.8691166802f, -0.2999350194f, 0.9539596344f,
    0.8165471961f, 0.5772786819f, 0.2697460475f, 0.962931498f, -0.7306287391f, -0.6827749597f, -0.7590952064f, -0.6509796216f, -0.907053853f, 0.4210146171f, -0.5104861064f, -0.8598860013f, 0.8613350597f, 0.5080373165f, 0.5007881595f, -0.8655698812f,
    -0.654158152f, 0.7563577938f, -0.8382755311f, -0.545246856f, 0.6940070834f, 0.7199681717f, 0.06950936031f, 0.9975812994f, 0.1702942185f, -0.9853932612f, 0.2695973274f, 0.9629731466f, 0.5519612192f, -0.8338697815f, 0.225657487f, -0.9742067022f,
    0.4215262855f, -0.9068161835f, 0.4881873305f, -0.8727388672f, -0.3683854996f, -0.9296731273f, -0.9825390578f, 0.1860564427f, 0.81256471f, 0.5828709909f, 0.3196460933f, -0.9475370046f, 0.9570913859f, 0.2897862643f, -0.6876655497f, -0.7260276109f,
    -0.9988770922f, -0.047376731f, -0.1250179027f, 0.992154486f, -0.8280133617f, 0.560708367f, 0.9324863769f, -0.3612051451f, 0.6394653183f, 0.7688199442f, -0.01623847064f, -0.9998681473f, -0.9955014666f, -0.09474613458f, -0.81453315f, 0.580117012f,
    0.4037327978f, -0.9148769469f, 0.9944263371f, 0.1054336766f, -0.1624711654f, 0.9867132919f, -0.9949487814f, -0.100383875f, -0.6995302564f, 0.7146029809f, 0.5263414922f, -0.85027327f, -0.5395221479f, 0.841971408f, 0.6579370318f, 0.7530729462f,
    0.01426758847f, -0.9998982128f, -0.6734383991f, 0.7392433447f, 0.639412098f, -0.7688642071f, 0.9211571421f, 0.3891908523f, -0.146637214f, -0.9891903394f, -0.782318098f, 0.6228791163f, -0.5039610839f, -0.8637263605f, -0.7743120191f, -0.6328039957f,
};

template <typename T>
const T FastNoiseLite::Lookup<T>::Gradients3D[] =
{
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
    1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
    1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
    1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
};

template <typename T>
const T FastNoiseLite::Lookup<T>::RandVecs3D[] =
{
    -0.7292736885f, -0.6618439697f, 0.1735581948f, 0, 0.790292081f, -0.5480887466f, -0.2739291014f, 0, 0.7217578935f, 0.6226212466f, -0.3023380997f, 0, 0.565683137f, -0.8208298145f, -0.0790000257f, 0, 0.760049034f, -0.5555979497f, -0.3370999617f, 0, 0.3713945616f, 0.5011264475f, 0.7816254623f, 0, -0.1277062463f, -0.4254438999f, -0.8959289049f, 0, -0.2881560924f, -0.5815838982f, 0.7607405838f, 0,
    0.5849561111f, -0.662820239f, -0.4674352136f, 0, 0.3307171178f, 0.0391653737f, 0.94291689f, 0, 0.8712121778f, -0.4113374369f, -0.2679381538f, 0, 0.580981015f, 0.7021915846f, 0.4115677815f, 0, 0.503756873f, 0.6330056931f, -0.5878203852f, 0, 0.4493712205f, 0.601390195f, 0.6606022552f, 0, -0.6878403724f, 0.09018890807f, -0.7202371714f, 0, -0.5958956522f, -0.6469350577f, 0.475797649f, 0,
    -0.5127052122f, 0.1946921978f, -0.8361987284f, 0, -0.9911507142f, -0.05410276466f, -0.1212153153f, 0, -0.2149721042f, 0.9720882117f, -0.09397607749f, 0, -0.7518650936f, -0.5428057603f, 0.3742469607f, 0, 0.5237068895f, 0.8516377189f, -0.02107817834f, 0, 0.6333504779f, 0.1926167129f, -0.7495104896f, 0, -0.06788241606f, 0.3998305789f, 0.9140719259f, 0, -0.5538628599f, -0.4729896695f, -0.6852128902f, 0,
    -0.7261455366f, -0.5911990757f, 0.3509933228f, 0, -0.9229274737f, -0.1782808786f, 0.3412049336f, 0, -0.6968815002f, 0.6511274338f, 0.3006480328f, 0, 0.9608044783f, -0.2098363234f, -0.1811724921f, 0, 0.06817146062f, -0.9743405129f, 0.2145069156f, 0, -0.3577285196f, -0.6697087264f, -0.6507845481f, 0, -0.1868621131f, 0.7648617052f, -0.6164974636f, 0, -0.6541697588f, 0.3967914832f, 0.6439087246f, 0,
    0.6993340405f, -0.6164538506f, 0.3618239211f, 0, -0.1546665739f, 0.6291283928f, 0.7617583057f, 0, -0.6841612949f, -0.2580482182f, -0.6821542638f, 0, 0.5383980957f, 0.4258654885f, 0.7271630328f, 0, -0.5026987823f, -0.7939832935f, -0.3418836993f, 0, 0.3202971715f, 0.2834415347f, 0.9039195862f, 0, 0.8683227101f, -0.0003762656404f, -0.4959995258f, 0, 0.791120031f, -0.08511045745f, 0.6057105799f, 0,
    -0.04011016052f, -0.4397248749f, 0.8972364289f, 0, 0.9145119872f, 0.3579346169f, -0.1885487608f, 0, -0.9612039066f, -0.2756484276f, 0.01024666929f, 0, 0.6510361721f, -0.2877799159f, -0.7023778346f, 0, -0.2041786351f, 0.7365237271f, 0.644859585f, 0, -0.7718263711f, 0.3790626912f, 0.5104855816f, 0, -0.3060082741f, -0.7692987727f, 0.5608371729f, 0, 0.454007341f, -0.5024843065f, 0.7357899537f, 0,
    0.4816795475f, 0.6021208291f, -0.6367380315f, 0, 0.6961980369f, -0.3222197429f, 0.641469197f, 0, -0.6532160499f, -0.6781148932f, 0.3368515753f, 0, 0.5089301236f, -0.6154662304f, -0.6018234363f, 0, -0.1635919754f, -0.9133604627f, -0.372840892f, 0, 0.52408019f, -0.8437664109f, 0.1157505864f, 0, 0.5902587356f, 0.4983817807f, -0.6349883666f, 0, 0.5863227872f, 0.494764745f, 0.6414307729f, 0,
    0.6779335087f, 0.2341345225f, 0.6968408593f, 0, 0.7177054546f, -0.6858979348f, 0.120178631f, 0, -0.5328819713f, -0.5205125012f, 0.6671608058f, 0, -0.8654874251f, -0.0700727088f, -0.4960053754f, 0, -0.2861810166f, 0.7952089234f, 0.5345495242f, 0, -0.04849529634f, 0.9810836427f, -0.1874115585f, 0, -0.6358521667f, 0.6058348682f, 0.4781800233f, 0, 0.6254794696f, -0.2861619734f, 0.7258696564f, 0,
    -0.2585259868f, 0.5061949264f, -0.8227581726f, 0, 0.02136306781f, 0.5064016808f, -0.8620330371f, 0, 0.200111773f, 0.8599263484f, 0.4695550591f, 0, 0.4743561372f, 0.6014985084f, -0.6427953014f, 0, 0.6622993731f, -0.5202474575f, -0.5391679918f, 0, 0.08084972818f, -0.6532720452f, 0.7527940996f, 0, -0.6893687501f, 0.0592860349f, 0.7219805347f, 0, -0.1121887082f, -0.9673185067f, 0.2273952515f, 0,
    0.7344116094f, 0.5979668656f, -0.3210532909f, 0, 0.5789393465f, -0.2488849713f, 0.7764570201f, 0, 0.6988182827f, 0.3557169806f, -0.6205791146f, 0, -0.8636845529f, -0.2748771249f, -0.4224826141f, 0, -0.4247027957f, -0.4640880967f, 0.777335046f, 0, 0.5257722489f, -0.8427017621f, 0.1158329937f, 0, 0.9343830603f, 0.316302472f, -0.1639543925f, 0, -0.1016836419f, -0.8057303073f, -0.5834887393f, 0,
    -0.6529238969f, 0.50602126f, -0.5635892736f, 0, -0.2465286165f, -0.9668205684f, -0.06694497494f, 0, -0.9776897119f, -0.2099250524f, -0.007368825344f, 0, 0.7736893337f, 0.5734244712f, 0.2694238123f, 0, -0.6095087895f, 0.4995678998f, 0.6155736747f, 0, 0.5794535482f, 0.7434546771f, 0.3339292269f, 0, -0.8226211154f, 0.08142581855f, 0.5627293636f, 0, -0.510385483f, 0.4703667658f, 0.7199039967f, 0,
    -0.5764971849f, -0.07231656274f, -0.8138926898f, 0, 0.7250628871f, 0.3949971505f, -0.5641463116f, 0, -0.1525424005f, 0.4860840828f, -0.8604958341f, 0, -0.5550976208f, -0.4957820792f, 0.667882296f, 0, -0.1883614327f, 0.9145869398f, 0.357841725f, 0, 0.7625556724f, -0.5414408243f, -0.3540489801f, 0, -0.5870231946f, -0.3226498013f, -0.7424963803f, 0, 0.3051124198f, 0.2262544068f, -0.9250488391f, 0,
    0.6379576059f, 0.577242424f, -0.5097070502f, 0, -0.5966775796f, 0.1454852398f, -0.7891830656f, 0, -0.658330573f, 0.6555487542f, -0.3699414651f, 0, 0.7434892426f, 0.2351084581f, 0.6260573129f, 0, 0.5562114096f, 0.8264360377f, -0.0873632843f, 0, -0.3028940016f, -0.8251527185f, 0.4768419182f, 0, 0.1129343818f, -0.985888439f, -0.1235710781f, 0, 0.5937652891f, -0.5896813806f, 0.5474656618f, 0,
    0.6757964092f, -0.5835758614f, -0.4502648413f, 0, 0.7242302609f, -0.1152719764f, 0.6798550586f, 0, -0.9511914166f, 0.0753623979f, -0.2992580792f, 0, 0.2539470961f, -0.1886339355f, 0.9486454084f, 0, 0.571433621f, -0.1679450851f, -0.8032795685f, 0, -0.06778234979f, 0.3978269256f, 0.9149531629f, 0, 0.6074972649f, 0.733060024f, -0.3058922593f, 0, -0.5435478392f, 0.1675822484f, 0.8224791405f, 0,
    -0.5876678086f, -0.3380045064f, -0.7351186982f, 0, -0.7967562402f, 0.04097822706f, -0.6029098428f, 0, -0.1996350917f, 0.8706294745f, 0.4496111079f, 0, -0.02787660336f, -0.9106232682f, -0.4122962022f, 0, -0.7797625996f, -0.6257634692f, 0.01975775581f, 0, -0.5211232846f, 0.7401644346f, -0.4249554471f, 0, 0.8575424857f, 0.4053272873f, -0.3167501783f, 0, 0.1045223322f, 0.8390195772f, -0.5339674439f, 0,
    0.3501822831f, 0.9242524096f, -0.1520850155f, 0, 0.1987849858f, 0.07647613266f, 0.9770547224f, 0, 0.7845996363f, 0.6066256811f, -0.1280964233f, 0, 0.09006737436f, -0.9750989929f, -0.2026569073f, 0, -0.8274343547f, -0.542299559f, 0.1458203587f, 0, -0.3485797732f, -0.415802277f, 0.840000362f, 0, -0.2471778936f, -0.7304819962f, -0.6366310879f, 0, -0.3700154943f, 0.8577948156f, 0.3567584454f, 0,
    0.5913394901f, -0.548311967f, -0.5913303597f, 0, 0.1204873514f, -0.7626472379f, -0.6354935001f, 0, 0.616959265f, 0.03079647928f, 0.7863922953f, 0, 0.1258156836f, -0.6640829889f, -0.7369967419f, 0, -0.6477565124f, -0.1740147258f, -0.7417077429f, 0, 0.6217889313f, -0.7804430448f, -0.06547655076f, 0, 0.6589943422f, -0.6096987708f, 0.4404473475f, 0, -0.2689837504f, -0.6732403169f, -0.6887635427f, 0,
    -0.3849775103f, 0.5676542638f, 0.7277093879f, 0, 0.5754444408f, 0.8110471154f, -0.1051963504f, 0, 0.9141593684f, 0.3832947817f, 0.131900567f, 0, -0.107925319f, 0.9245493968f, 0.3654593525f, 0, 0.377977089f, 0.3043148782f, 0.8743716458f, 0, -0.2142885215f, -0.8259286236f, 0.5214617324f, 0, 0.5802544474f, 0.4148098596f, -0.7008834116f, 0, -0.1982660881f, 0.8567161266f, -0.4761596756f, 0,
    -0.03381553704f, 0.3773180787f, -0.9254661404f, 0, -0.6867922841f, -0.6656597827f, 0.2919133642f, 0, 0.7731742607f, -0.2875793547f, -0.5652430251f, 0, -0.09655941928f, 0.9193708367f, -0.3813575004f, 0, 0.2715702457f, -0.9577909544f, -0.09426605581f, 0, 0.2451015704f, -0.6917998565f, -0.6792188003f, 0, 0.977700782f, -0.1753855374f, 0.1155036542f, 0, -0.5224739938f, 0.8521606816f, 0.02903615945f, 0,
    -0.7734880599f, -0.5261292347f, 0.3534179531f, 0, -0.7134492443f, -0.269547243f, 0.6467878011f, 0, 0.1644037271f, 0.5105846203f, -0.8439637196f, 0, 0.6494635788f, 0.05585611296f, 0.7583384168f, 0, -0.4711970882f, 0.5017280509f, -0.7254255765f, 0, -0.6335764307f, -0.2381686273f, -0.7361091029f, 0, -0.9021533097f, -0.270947803f, -0.3357181763f, 0, -0.3793711033f, 0.872258117f, 0.3086152025f, 0,
    -0.6855598966f, -0.3250143309f, 0.6514394162f, 0, 0.2900942212f, -0.7799057743f, -0.5546100667f, 0, -0.2098319339f, 0.85037073f, 0.4825351604f, 0, -0.4592603758f, 0.6598504336f, -0.5947077538f, 0, 0.8715945488f, 0.09616365406f, -0.4807031248f, 0, -0.6776666319f, 0.7118504878f, -0.1844907016f, 0, 0.7044377633f, 0.312427597f, 0.637304036f, 0, -0.7052318886f, -0.2401093292f, -0.6670798253f, 0,
    0.081921007f, -0.7207336136f, -0.6883545647f, 0, -0.6993680906f, -0.5875763221f, -0.4069869034f, 0, -0.1281454481f, 0.6419895885f, 0.7559286424f, 0, -0.6337388239f, -0.6785471501f, -0.3714146849f, 0, 0.5565051903f, -0.2168887573f, -0.8020356851f, 0, -0.5791554484f, 0.7244372011f, -0.3738578718f, 0, 0.1175779076f, -0.7096451073f, 0.6946792478f, 0, -0.6134619607f, 0.1323631078f, 0.7785527795f, 0,
    0.6984635305f, -0.02980516237f, -0.715024719f, 0, 0.8318082963f, -0.3930171956f, 0.3919597455f, 0, 0.1469576422f, 0.05541651717f, -0.9875892167f, 0, 0.708868575f, -0.2690503865f, 0.6520101478f, 0, 0.2726053183f, 0.67369766f, -0.68688995f, 0, -0.6591295371f, 0.3035458599f, -0.6880466294f, 0, 0.4815131379f, -0.7528270071f, 0.4487723203f, 0, 0.9430009463f, 0.1675647412f, -0.2875261255f, 0,
    0.434802957f, 0.7695304522f, -0.4677277752f, 0, 0.3931996188f, 0.594473625f, 0.7014236729f, 0, 0.7254336655f, -0.603925654f, 0.3301814672f, 0, 0.7590235227f, -0.6506083235f, 0.02433313207f, 0, -0.8552768592f, -0.3430042733f, 0.3883935666f, 0, -0.6139746835f, 0.6981725247f, 0.3682257648f, 0, -0.7465905486f, -0.5752009504f, 0.3342849376f, 0, 0.5730065677f, 0.810555537f, -0.1210916791f, 0,
    -0.9225877367f, -0.3475211012f, -0.167514036f, 0, -0.7105816789f, -0.4719692027f, -0.5218416899f, 0, -0.08564609717f, 0.3583001386f, 0.929669703f, 0, -0.8279697606f, -0.2043157126f, 0.5222271202f, 0, 0.427944023f, 0.278165994f, 0.8599346446f, 0, 0.5399079671f, -0.7857120652f, -0.3019204161f, 0, 0.5678404253f, -0.5495413974f, -0.6128307303f, 0, -0.9896071041f, 0.1365639107f, -0.04503418428f, 0,
    -0.6154342638f, -0.6440875597f, 0.4543037336f, 0, 0.1074204368f, -0.7946340692f, 0.5975094525f, 0, -0.3595449969f, -0.8885529948f, 0.28495784f, 0, -0.2180405296f, 0.1529888965f, 0.9638738118f, 0, -0.7277432317f, -0.6164050508f, -0.3007234646f, 0, 0.7249729114f, -0.00669719484f, 0.6887448187f, 0, -0.5553659455f, -0.5336586252f, 0.6377908264f, 0, 0.5137558015f, 0.7976208196f, -0.3160000073f, 0,
    -0.3794024848f, 0.9245608561f, -0.03522751494f, 0, 0.8229248658f, 0.2745365933f, -0.4974176556f, 0, -0.5404114394f, 0.6091141441f, 0.5804613989f, 0, 0.8036581901f, -0.2703029469f, 0.5301601931f, 0, 0.6044318879f, 0.6832968393f, 0.4095943388f, 0, 0.06389988817f, 0.9658208605f, -0.2512108074f, 0, 0.1087113286f, 0.7402471173f, -0.6634877936f, 0, -0.713427712f, -0.6926784018f, 0.1059128479f, 0,
    0.6458897819f, -0.5724548511f, -0.5050958653f, 0, -0.6553931414f, 0.7381471625f, 0.159995615f, 0, 0.3910961323f, 0.9188871375f, -0.05186755998f, 0, -0.4879022471f, -0.5904376907f, 0.6429111375f, 0, 0.6014790094f, 0.7707441366f, -0.2101820095f, 0, -0.5677173047f, 0.7511360995f, 0.3368851762f, 0, 0.7858573506f, 0.226674665f, 0.5753666838f, 0, -0.4520345543f, -0.604222686f, -0.6561857263f, 0,
    0.002272116345f, 0.4132844051f, -0.9105991643f, 0, -0.5815751419f, -0.5162925989f, 0.6286591339f, 0, -0.03703704785f, 0.8273785755f, 0.5604221175f, 0, -0.5119692504f, 0.7953543429f, -0.3244980058f, 0, -0.2682417366f, -0.9572290247f, -0.1084387619f, 0, -0.2322482736f, -0.9679131102f, -0.09594243324f, 0, 0.3554328906f, -0.8881505545f, 0.2913006227f, 0, 0.7346520519f, -0.4371373164f, 0.5188422971f, 0,
    0.9985120116f, 0.04659011161f, -0.02833944577f, 0, -0.3727687496f, -0.9082481361f, 0.1900757285f, 0, 0.91737377f, -0.3483642108f, 0.1925298489f, 0, 0.2714911074f, 0.4147529736f, -0.8684886582f, 0, 0.5131763485f, -0.7116334161f, 0.4798207128f, 0, -0.8737353606f, 0.18886992f, -0.4482350644f, 0, 0.8460043821f, -0.3725217914f, 0.3814499973f, 0, 0.8978727456f, -0.1780209141f, -0.4026575304f, 0,
    0.2178065647f, -0.9698322841f, -0.1094789531f, 0, -0.1518031304f, -0.7788918132f, -0.6085091231f, 0, -0.2600384876f, -0.4755398075f, -0.8403819825f, 0, 0.572313509f, -0.7474340931f, -0.3373418503f, 0, -0.7174141009f, 0.1699017182f, -0.6756111411f, 0, -0.684180784f, 0.02145707593f, -0.7289967412f, 0, -0.2007447902f, 0.06555605789f, -0.9774476623f, 0, -0.1148803697f, -0.8044887315f, 0.5827524187f, 0,
    -0.7870349638f, 0.03447489231f, 0.6159443543f, 0, -0.2015596421f, 0.6859872284f, 0.6991389226f, 0, -0.08581082512f, -0.10920836f, -0.9903080513f, 0, 0.5532693395f, 0.7325250401f, -0.396610771f, 0, -0.1842489331f, -0.9777375055f, -0.1004076743f, 0, 0.0775473789f, -0.9111505856f, 0.4047110257f, 0, 0.1399838409f, 0.7601631212f, -0.6344734459f, 0, 0.4484419361f, -0.845289248f, 0.2904925424f, 0
};

#endif
"./Utils\\LogUtils.cpp"
#include <iostream>
#include <iomanip>
#include "LogUtils.h"
#include "Clock.h"
#include <ctime>
#include "../FileManager/Files.h"
#include <sstream>

void LogUtils::MainLogger() {

    const uint64_t printLimit = 8192;

    std::string printOutput = "";

    while (!stop_) {
        if (!logs_cache_.empty()) {

            LogData log = logs_cache_.front();
            logs_cache_.pop_front();

            time_t timept = std::chrono::system_clock::to_time_t(log.time_);
            char* context = nullptr;

            std::string timestamp = std::string(strtok_s(ctime(&timept), "\n", &context));

            std::string str = "";
            std::string messageSeverity = "";

            if (log.type_ == 0x01) {
                messageSeverity = "INFO";
            } else if (log.type_ == 0x03) {
                messageSeverity = "WARNING";
            } else if (log.type_ == 0x02) {
                messageSeverity = "ERROR";
            } else if (log.type_ == 0x00) {
                messageSeverity = "DEBUG";
            }

            str = FormatMessage(messageSeverity, log.r_time_, timestamp, log.subtype_, log.message_);
            printOutput += str + "\n";

            if (printOutput.size() > printLimit) {
                printf("%s", printOutput.c_str());
                file_ << printOutput;
                printOutput.clear();
            }
        }
        else {
            if (printOutput.size() != 0) {
                printf("%s", printOutput.c_str());
                file_ << printOutput;
                printOutput.clear();
            }

            std::unique_lock<std::mutex> lock{ mutex_ };
            cv_.wait_for(lock, std::chrono::milliseconds(100), [this] { return !logs_cache_.empty() || stop_; });
            if (stop_) break;
            logs_cache_ = std::move(logs_);
            logs_.clear();
        }
    }
}

void LogUtils::Start() {
    if (!started_) {
        if (!FileManager::CheckFolder("Logs")) {
            FileManager::CreateFolder("Logs");
        }

        auto t = std::time(nullptr);
        auto tm = *std::localtime(&t);

        std::ostringstream oss;
        oss << std::put_time(&tm, "%d-%m-%Y %H-%M-%S");
        auto str = "Logs//" + oss.str() + ".log";

        file_.open(str);

        logging_thread_ = std::thread(&LogUtils::MainLogger, this);
        LogInfo("Logger","Started Logger");
    }
    else {
        LogError("Logger", "Logger Already Started");
    }
    
}

void LogUtils::LogError(std::string subtype, std::string message) {
    LogData log;
    log.type_ = LOG_TYPE_ERROR;
    log.message_ = message;
    log.time_ = std::chrono::system_clock::now();
    log.subtype_ = subtype;
    log.r_time_ = (std::chrono::high_resolution_clock::now() - init_time_).count();
    std::lock_guard<std::mutex> lock{ mutex_ };
    logs_.emplace_back(log);
    cv_.notify_one();
    throw std::runtime_error(subtype + " - " + message);
}

void LogUtils::LogWarn(std::string subtype, std::string message) {
    LogData log;
    log.type_ = LOG_TYPE_WARN;
    log.message_ = message;
    log.time_ = std::chrono::system_clock::now();
    log.subtype_ = subtype;
    log.r_time_ = (std::chrono::high_resolution_clock::now() - init_time_).count();
    std::lock_guard<std::mutex> lock{ mutex_ };
    logs_.emplace_back(log);
    cv_.notify_one();
}

void LogUtils::LogInfo(std::string subtype, std::string message) {
    LogData log;
    log.type_ = LOG_TYPE_INFO;
    log.message_ = message;
    log.time_ = std::chrono::system_clock::now();
    log.subtype_ = subtype;
    log.r_time_ = (std::chrono::high_resolution_clock::now() - init_time_).count();
    std::lock_guard<std::mutex> lock{mutex_};
    logs_.emplace_back(log);
    cv_.notify_one();
}

void LogUtils::LogDebug(std::string subtype, std::string message) {
    LogData log;
    log.type_ = LOG_TYPE_DEBUG;
    log.message_ = message;
    log.time_ = std::chrono::system_clock::now();
    log.subtype_ = subtype;
    log.r_time_ = (std::chrono::high_resolution_clock::now() - init_time_).count();
    std::lock_guard<std::mutex> lock{ mutex_ };
    logs_.emplace_back(log);
    cv_.notify_one();
}

void LogUtils::LogDebugf(std::string subtype, std::string message, ...) {
    va_list args;
    va_start(args, message);

    std::string formatedString = FormatString(message, args);

    va_end(args);

    LogData log;
    log.type_ = LOG_TYPE_DEBUG;
    log.message_ = formatedString;
    log.time_ = std::chrono::system_clock::now();
    log.subtype_ = subtype;
    log.r_time_ = (std::chrono::high_resolution_clock::now() - init_time_).count();
    std::lock_guard<std::mutex> lock{ mutex_ };
    logs_.emplace_back(log);
    cv_.notify_one();
}

void LogUtils::Stop() {
    stop_ = true;
}

LogUtils::LogUtils() {
    buffer_ = new char[buffer_size_];
    Start();
}

LogUtils::~LogUtils() {
    logging_thread_.join();
    delete[] buffer_;
}

std::string LogUtils::FormatString(std::string in, ...) {
    va_list args;
    va_start(args, in);

    vsnprintf(buffer_, buffer_size_, in.c_str(), args);

    va_end(args);

    std::string out(buffer_);
    memset(buffer_, NULL, out.size());
    return out;
}

std::string LogUtils::FormatMessage(std::string severity, long long time, std::string timestamp, std::string subtype, std::string message) {
    return FormatString("[ %lld NS ] [ %s ] [ %s / %s ]: %s", time, timestamp.c_str(), severity.c_str(), subtype.c_str(), message.c_str());
}
"./Utils\\LogUtils.h"
#pragma once

#include <thread>
#include <deque>
#include <string>
#include <chrono>
#include <mutex>
#include <fstream>
#include <cstdarg>
#include <condition_variable>

inline constexpr int LOG_TYPE_DEBUG = 0x00;
inline constexpr int LOG_TYPE_INFO = 0x01;
inline constexpr int LOG_TYPE_ERROR = 0x02;
inline constexpr int LOG_TYPE_WARN = 0x03;

struct LogData {
    int type_ = NULL;
    int thread = NULL;
    std::string message_;
    std::string subtype_;
    std::chrono::system_clock::time_point time_;
    long long int r_time_ = 0;
};

class LogUtils {
public:

    LogUtils();
    ~LogUtils();

    void Start();
    void Stop();

    void LogError(std::string subtype, std::string message);
    void LogWarn(std::string subtype, std::string message);
    void LogInfo(std::string subtype, std::string message);
    void LogDebug(std::string subtype, std::string message);
    void LogDebugf(std::string subtype, std::string message,...);

private:
    void MainLogger();

    std::string FormatString(std::string in, ...);
    std::string FormatMessage(std::string severity, long long time, std::string timestamp, std::string subtype, std::string message);

    std::chrono::high_resolution_clock::time_point init_time_ = std::chrono::high_resolution_clock::now();

    std::thread logging_thread_;
    std::mutex mutex_;
    std::condition_variable cv_;
    bool stop_ = false;
    bool started_ = false;
    std::deque<LogData> logs_;
    std::deque<LogData> logs_cache_;
    std::ofstream file_;
    char* buffer_;
    const uint64_t buffer_size_ = 4096;
};

extern LogUtils g_logger;
"./Utils\\Math\\Probability\\Probability.cpp"
#include "Probability.h"
#include <cstdlib>


bool TestProbability(double odds) {
    int rng = rand();

    if (((double)RAND_MAX) * odds >= (double)rng) {
        return true;
    }

    return false;
    
}
"./Utils\\Math\\Probability\\Probability.h"
#pragma once

bool TestProbability(double odds);
"./Utils\\Math\\Ray\\Ray.h"
#pragma once
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
struct Ray {
    float length_ = 0;

    glm::vec3 direction_ = glm::vec3(0., 0., 0.);
    glm::vec3 origin_ = glm::vec3(0., 0., 0.);
    glm::vec3 end_point_ = glm::vec3(0., 0., 0.);

    int bounce_surface_ = 0;
};
"./Utils\\Math\\vectorOperations.h"
#pragma once
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>
#include <cmath>

inline static glm::ivec3 Sign(glm::vec3 vector) {
    glm::ivec3 signs(0,0,0);

    signs[0] = (vector[0] > 0) - (vector[0] < 0);
    signs[1] = (vector[1] > 0) - (vector[1] < 0);
    signs[2] = (vector[2] > 0) - (vector[2] < 0);

    return signs;
}

inline static glm::bvec3 LessThan(glm::vec3 vec1, glm::vec3 vec2) {
    glm::bvec3 less(false, false, false);

    less[0] = vec1[0] < vec2[0];
    less[1] = vec1[1] < vec2[1];
    less[2] = vec1[2] < vec2[2];

    return less;
}

inline static glm::bvec3 LessThan(float x, float y, float z, float x1, float y1, float z1) {
    glm::bvec3 less(false, false, false);

    less[0] = x < x1;
    less[1] = y < y1;
    less[2] = z < z1;

    return less;
}

inline static glm::bvec3 LessThanEqual(glm::vec3 vec1, glm::vec3 vec2) {
    glm::bvec3 less(false, false, false);

    less[0] = vec1[0] <= vec2[0];
    less[1] = vec1[1] <= vec2[1];
    less[2] = vec1[2] <= vec2[2];

    return less;
}

inline static glm::bvec3 LessThanEqual(float x, float y, float z, float x1, float y1, float z1) {
    glm::bvec3 less(false, false, false);

    less[0] = x <= x1;
    less[1] = y <= y1;
    less[2] = z <= z1;

    return less;
}


// TODO: Overload std::min ?
inline static glm::bvec3 Min(glm::vec3 vec1, glm::vec3 vec2) {
    vec1[0] = vec1[0] < vec2[0] ? vec1[0] : vec2[0];
    vec1[1] = vec1[1] < vec2[1] ? vec1[1] : vec2[1];
    vec1[2] = vec1[2] < vec2[2] ? vec1[2] : vec2[2];

    return vec1;
}


inline static glm::bvec3 Min(float x, float y, float z, float x1, float y1, float z1) {
    glm::vec3 vec1(0.f, 0.f, 0.f);

    vec1[0] = x < x1 ? x : x1;
    vec1[1] = y < y1 ? y : y1;
    vec1[2] = z < z1 ? z : z1;

    return vec1;
}

inline static float Magnitude(glm::vec3 v) {
    return sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
}

inline static float Magnitude(glm::vec2 v) {
    return sqrtf(v.x * v.x + v.y * v.y);
}


"./Utils\\MathHelper.cpp"
#include <cmath>
#include <glm/vec2.hpp>
#include <glm/vec3.hpp>
#define _CRTDBG_MAP_ALLOC
double toRadians(double x)
{
    return x* 0.01745329251;
}

float FindDistanceNoSqrt(float x, float y, float z, float x1, float y1, float z1) {
    return (x - x1) * (x - x1) + (y - y1) * (y - y1) + (z - z1) * (z - z1);
}

double FindDistanceNoSqrt(int x, int y, int x1, int y1) {
    return pow(x - x1, 2) + pow(y - y1, 2);
}

double FindDistance(int x, int y, int z, int x1, int y1, int z1) {
    return sqrt(pow(x - x1, 2) + pow(y - y1, 2) + pow(z - z1, 2));
}

double FindDistance(int x, int y, int x1, int y1) {
    return sqrt(pow(x - x1, 2) + pow(y - y1, 2));
}

template <typename T> double FindDistance(T x, T x1) {
    return sqrt(pow((double)x - x1, 2));
}

double FindDistance(glm::ivec3 pos0, glm::ivec3 pos1) {
    return sqrt(pow((double)pos0.x - pos1.x, 2) + pow((double)pos0.y - pos1.y, 2) + pow((double)pos0.z - pos1.z, 2));
}

double FindDistance(glm::ivec2 pos0, glm::ivec2 pos1) {
    return sqrt(pow((double)pos0.x - pos1.x, 2) + pow((double)pos0.y - pos1.y, 2));
}

double FindDistance(glm::vec3 pos0, glm::vec3 pos1) {
    return sqrt(pow((double)pos0.x - pos1.x, 2) + pow((double)pos0.y - pos1.y, 2) + pow((double)pos0.z - pos1.z, 2));
}

double FindDistance(glm::vec2 pos0, glm::vec2 pos1) {
    return sqrt(pow((double)pos0.x - pos1.x, 2) + pow((double)pos0.y - pos1.y, 2));
}

"./Utils\\MathHelper.h"
#pragma once
#define DEGTORAD 0.017453

#include <glm/vec2.hpp>
#include <glm/vec3.hpp>

float FindDistanceNoSqrt(float x, float y, float z, float x1, float y1, float z1);
double FindDistance(int x, int y, int x1, int y1);

double FindDistanceNoSqrt(int x, int y, int x1, int y1);

double FindDistance(glm::ivec3 pos0, glm::ivec3 pos1);
double FindDistance(glm::ivec2 pos0, glm::ivec2 pos1);

double FindDistance(glm::vec3 pos0, glm::vec3 pos1);
double FindDistance(glm::vec2 pos0, glm::vec2 pos1);

template <typename T> double FindDistance(T x, T x1);
"./Utils\\stb_image.h"
/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
      2.26  (2020-07-13) many minor fixes
      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
    Phil Jordan                                Dave Moore           Roy Eltham
    Hayaki Saito            Nathan Reed        Won Chun
    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
    Thomas Ruf              Ronny Chevalier                         github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
    Cass Everitt            Ryamond Barbiero                        github:grim210
    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
                            Brad Weinberger    Matvey Cherevko      github:mosra
    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
    Ryan C. Gordon          [reserved]                              [reserved]
                     DO NOT ADD YOUR NAME HERE

                     Jacko Dirks

  To add your name to the credits, pick a random blank space in the middle and fill it.
  80% of merge conflicts on stb PRs are due to people adding their name at the end
  of the credits.
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// To query the width, height and component count of an image without having to
// decode the full file, you can use the stbi_info family of functions:
//
//   int x,y,n,ok;
//   ok = stbi_info(filename, &x, &y, &n);
//   // returns ok=1 and sets x, y, n if image is a supported format,
//   // 0 otherwise.
//
// Note that stb_image pervasively uses ints in its public API for sizes,
// including sizes of memory buffers. This is now part of the API and thus
// hard to change without causing breakage. As a result, the various image
// loaders all have certain limits on image size; these differ somewhat
// by format but generally boil down to either just under 2GB or just under
// 1GB. When the decoded image would be larger than this, stb_image decoding
// will fail.
//
// Additionally, stb_image will reject image files that have any of their
// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
// the only way to have an image with such dimensions load correctly
// is for it to have a rather extreme aspect ratio. Either way, the
// assumption here is that such larger images are likely to be malformed
// or malicious. If you do need to load an image with individual dimensions
// larger than that, and it still fits in the overall size limit, you can
// #define STBI_MAX_DIMENSIONS on your own to be something larger.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// We optionally support converting iPhone-formatted PNGs (which store
// premultiplied BGRA) back to RGB, even though they're internally encoded
// differently. To enable this conversion, call
// stbi_convert_iphone_png_to_rgb(1).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//
//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
//    than that size (in either width or height) without further processing.
//    This is to let programs in the wild set an upper bound to prevent
//    denial-of-service attacks on untrusted data, as one could generate a
//    valid image of gigantic dimensions and force stb_image to allocate a
//    huge block of memory and spend disproportionate time decoding it. By
//    default this is set to (1 << 24), which is 16777216, but that's still
//    very big.

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
    STBI_default = 0, // only used for desired_channels

    STBI_grey = 1,
    STBI_grey_alpha = 2,
    STBI_rgb = 3,
    STBI_rgb_alpha = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

    //////////////////////////////////////////////////////////////////////////////
    //
    // PRIMARY API - works on images of any type
    //

    //
    // load image by filename, open file, or memory buffer
    //

    typedef struct
    {
        int      (*read)  (void* user, char* data, int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
        void     (*skip)  (void* user, int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
        int      (*eof)   (void* user);                       // returns nonzero if we are at end of file/data
    } stbi_io_callbacks;

    ////////////////////////////////////
    //
    // 8-bits-per-channel interface
    //

    STBIDEF stbi_uc* stbi_load_from_memory(stbi_uc           const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF stbi_uc* stbi_load_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
    STBIDEF stbi_uc* stbi_load(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF stbi_uc* stbi_load_from_file(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);
    // for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
    STBIDEF stbi_uc* stbi_load_gif_from_memory(stbi_uc const* buffer, int len, int** delays, int* x, int* y, int* z, int* comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
    STBIDEF int stbi_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input);
#endif

    ////////////////////////////////////
    //
    // 16-bits-per-channel interface
    //

    STBIDEF stbi_us* stbi_load_16_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF stbi_us* stbi_load_16_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
    STBIDEF stbi_us* stbi_load_16(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF stbi_us* stbi_load_from_file_16(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);
#endif

    ////////////////////////////////////
    //
    // float-per-channel interface
    //
#ifndef STBI_NO_LINEAR
    STBIDEF float* stbi_loadf_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF float* stbi_loadf_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
    STBIDEF float* stbi_loadf(char const* filename, int* x, int* y, int* channels_in_file, int desired_channels);
    STBIDEF float* stbi_loadf_from_file(FILE* f, int* x, int* y, int* channels_in_file, int desired_channels);
#endif
#endif

#ifndef STBI_NO_HDR
    STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
    STBIDEF void   stbi_hdr_to_ldr_scale(float scale_);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
    STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
    STBIDEF void   stbi_ldr_to_hdr_scale(float scale_);
#endif // STBI_NO_LINEAR

    // stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
    STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const* clbk, void* user);
    STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const* buffer, int len);
#ifndef STBI_NO_STDIO
    STBIDEF int      stbi_is_hdr(char const* filename);
    STBIDEF int      stbi_is_hdr_from_file(FILE* f);
#endif // STBI_NO_STDIO


    // get a VERY brief reason for failure
    // on most compilers (and ALL modern mainstream compilers) this is threadsafe
    STBIDEF const char* stbi_failure_reason(void);

    // free the loaded image -- this is just free()
    STBIDEF void     stbi_image_free(void* retval_from_stbi_load);

    // get image dimensions & components without fully decoding
    STBIDEF int      stbi_info_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp);
    STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp);
    STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const* buffer, int len);
    STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const* clbk, void* user);

#ifndef STBI_NO_STDIO
    STBIDEF int      stbi_info(char const* filename, int* x, int* y, int* comp);
    STBIDEF int      stbi_info_from_file(FILE* f, int* x, int* y, int* comp);
    STBIDEF int      stbi_is_16_bit(char const* filename);
    STBIDEF int      stbi_is_16_bit_from_file(FILE* f);
#endif



    // for image formats that explicitly notate that they have premultiplied alpha,
    // we just return the colors as stored in the file. set this flag to force
    // unpremultiplication. results are undefined if the unpremultiply overflow.
    STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

    // indicate whether we should process iphone images back to canonical format,
    // or just pass them through "as-is"
    STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

    // flip the image vertically, so the first pixel in the output array is the bottom left
    STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

    // as above, but only applies to images loaded on the thread that calls the function
    // this function is only available if your compiler supports thread-local variables;
    // calling it will fail to link if your compiler doesn't
    STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
    STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
    STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

    // ZLIB client - used by PNG, available for other purposes

    STBIDEF char* stbi_zlib_decode_malloc_guesssize(const char* buffer, int len, int initial_size, int* outlen);
    STBIDEF char* stbi_zlib_decode_malloc_guesssize_headerflag(const char* buffer, int len, int initial_size, int* outlen, int parse_header);
    STBIDEF char* stbi_zlib_decode_malloc(const char* buffer, int len, int* outlen);
    STBIDEF int   stbi_zlib_decode_buffer(char* obuffer, int olen, const char* ibuffer, int ilen);

    STBIDEF char* stbi_zlib_decode_noheader_malloc(const char* buffer, int len, int* outlen);
    STBIDEF int   stbi_zlib_decode_noheader_buffer(char* obuffer, int olen, const char* ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
#ifndef STBI_ONLY_JPEG
#define STBI_NO_JPEG
#endif
#ifndef STBI_ONLY_PNG
#define STBI_NO_PNG
#endif
#ifndef STBI_ONLY_BMP
#define STBI_NO_BMP
#endif
#ifndef STBI_ONLY_PSD
#define STBI_NO_PSD
#endif
#ifndef STBI_ONLY_TGA
#define STBI_NO_TGA
#endif
#ifndef STBI_ONLY_GIF
#define STBI_NO_GIF
#endif
#ifndef STBI_ONLY_HDR
#define STBI_NO_HDR
#endif
#ifndef STBI_ONLY_PIC
#define STBI_NO_PIC
#endif
#ifndef STBI_ONLY_PNM
#define STBI_NO_PNM
#endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp, pow
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
#ifdef __cplusplus
#define stbi_inline inline
#else
#define stbi_inline
#endif
#else
#define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
#if defined(__cplusplus) &&  __cplusplus >= 201103L
#define STBI_THREAD_LOCAL       thread_local
#elif defined(__GNUC__) && __GNUC__ < 5
#define STBI_THREAD_LOCAL       __thread
#elif defined(_MSC_VER)
#define STBI_THREAD_LOCAL       __declspec(thread)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
#define STBI_THREAD_LOCAL       _Thread_local
#endif

#ifndef STBI_THREAD_LOCAL
#if defined(__GNUC__)
#define STBI_THREAD_LOCAL       __thread
#endif
#endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32) == 4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
#define stbi_lrot(x,y)  _lrotl(x,y)
#else
#define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
    int info[4];
    __cpuid(info, 1);
    return info[3];
}
#else
static int stbi__cpuid3(void)
{
    int res;
    __asm {
        mov  eax, 1
        cpuid
        mov  res, edx
    }
    return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
    int info3 = stbi__cpuid3();
    return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
    // If we're even attempting to compile this on GCC/Clang, that means
    // -msse2 is on, which means the compiler is allowed to use SSE2
    // instructions at will, and so are we.
    return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
#ifdef _MSC_VER
#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
#else
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

#ifndef STBI_MAX_DIMENSIONS
#define STBI_MAX_DIMENSIONS (1 << 24)
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
    stbi__uint32 img_x, img_y;
    int img_n, img_out_n;

    stbi_io_callbacks io;
    void* io_user_data;

    int read_from_callbacks;
    int buflen;
    stbi_uc buffer_start[128];
    int callback_already_read;

    stbi_uc* img_buffer, * img_buffer_end;
    stbi_uc* img_buffer_original, * img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context* s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context* s, stbi_uc const* buffer, int len)
{
    s->io.read = NULL;
    s->read_from_callbacks = 0;
    s->callback_already_read = 0;
    s->img_buffer = s->img_buffer_original = (stbi_uc*)buffer;
    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc*)buffer + len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context* s, stbi_io_callbacks* c, void* user)
{
    s->io = *c;
    s->io_user_data = user;
    s->buflen = sizeof(s->buffer_start);
    s->read_from_callbacks = 1;
    s->callback_already_read = 0;
    s->img_buffer = s->img_buffer_original = s->buffer_start;
    stbi__refill_buffer(s);
    s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void* user, char* data, int size)
{
    return (int)fread(data, 1, size, (FILE*)user);
}

static void stbi__stdio_skip(void* user, int n)
{
    int ch;
    fseek((FILE*)user, n, SEEK_CUR);
    ch = fgetc((FILE*)user);  /* have to read a byte to reset feof()'s flag */
    if (ch != EOF) {
        ungetc(ch, (FILE*)user);  /* push byte back onto stream if valid. */
    }
}

static int stbi__stdio_eof(void* user)
{
    return feof((FILE*)user) || ferror((FILE*)user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context* s, FILE* f)
{
    stbi__start_callbacks(s, &stbi__stdio_callbacks, (void*)f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context* s)
{
    // conceptually rewind SHOULD rewind to the beginning of the stream,
    // but we just rewind to the beginning of the initial buffer, because
    // we only use it after doing 'test', which only ever looks at at most 92 bytes
    s->img_buffer = s->img_buffer_original;
    s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
    STBI_ORDER_RGB,
    STBI_ORDER_BGR
};

typedef struct
{
    int bits_per_channel;
    int num_channels;
    int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context* s);
static void* stbi__jpeg_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__jpeg_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context* s);
static void* stbi__png_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__png_info(stbi__context* s, int* x, int* y, int* comp);
static int      stbi__png_is16(stbi__context* s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context* s);
static void* stbi__bmp_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__bmp_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context* s);
static void* stbi__tga_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__tga_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context* s);
static void* stbi__psd_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc);
static int      stbi__psd_info(stbi__context* s, int* x, int* y, int* comp);
static int      stbi__psd_is16(stbi__context* s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context* s);
static float* stbi__hdr_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__hdr_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context* s);
static void* stbi__pic_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__pic_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context* s);
static void* stbi__gif_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static void* stbi__load_gif_main(stbi__context* s, int** delays, int* x, int* y, int* z, int* comp, int req_comp);
static int      stbi__gif_info(stbi__context* s, int* x, int* y, int* comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context* s);
static void* stbi__pnm_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri);
static int      stbi__pnm_info(stbi__context* s, int* x, int* y, int* comp);
static int      stbi__pnm_is16(stbi__context* s);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char* stbi__g_failure_reason;

STBIDEF const char* stbi_failure_reason(void)
{
    return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char* str)
{
    stbi__g_failure_reason = str;
    return 0;
}
#endif

static void* stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
    if (b < 0) return 0;
    // now 0 <= b <= INT_MAX, hence also
    // 0 <= INT_MAX - b <= INTMAX.
    // And "a + b <= INT_MAX" (which might overflow) is the
    // same as a <= INT_MAX - b (no overflow)
    return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
    if (a < 0 || b < 0) return 0;
    if (b == 0) return 1; // mul-by-0 is always safe
    // portable way to check for no overflows in a*b
    return a <= INT_MAX / b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a * b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&
        stbi__addsizes_valid(a * b * c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a * b, c) &&
        stbi__mul2sizes_valid(a * b * c, d) && stbi__addsizes_valid(a * b * c * d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void* stbi__malloc_mad2(int a, int b, int add)
{
    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
    return stbi__malloc(a * b + add);
}
#endif

static void* stbi__malloc_mad3(int a, int b, int c, int add)
{
    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
    return stbi__malloc(a * b * c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static void* stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
    return stbi__malloc(a * b * c * d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
#define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
#define stbi__err(x,y)  stbi__err(y)
#else
#define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void* retval_from_stbi_load)
{
    STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float* stbi__ldr_to_hdr(stbi_uc* data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc* stbi__hdr_to_ldr(float* data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
    stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void* stbi__load_main(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc)
{
    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
    ri->num_channels = 0;

    // test the formats with a very explicit header first (at least a FOURCC
    // or distinctive magic number first)
#ifndef STBI_NO_PNG
    if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_BMP
    if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_GIF
    if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_PSD
    if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);
#else
    STBI_NOTUSED(bpc);
#endif
#ifndef STBI_NO_PIC
    if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp, ri);
#endif

    // then the formats that can end up attempting to load with just 1 or 2
    // bytes matching expectations; these are prone to false positives, so
    // try them later
#ifndef STBI_NO_JPEG
    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp, ri);
#endif
#ifndef STBI_NO_PNM
    if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp, ri);
#endif

#ifndef STBI_NO_HDR
    if (stbi__hdr_test(s)) {
        float* hdr = stbi__hdr_load(s, x, y, comp, req_comp, ri);
        return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
    }
#endif

#ifndef STBI_NO_TGA
    // test tga last because it's a crappy test!
    if (stbi__tga_test(s))
        return stbi__tga_load(s, x, y, comp, req_comp, ri);
#endif

    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc* stbi__convert_16_to_8(stbi__uint16* orig, int w, int h, int channels)
{
    int i;
    int img_len = w * h * channels;
    stbi_uc* reduced;

    reduced = (stbi_uc*)stbi__malloc(img_len);
    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

    for (i = 0; i < img_len; ++i)
        reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

    STBI_FREE(orig);
    return reduced;
}

static stbi__uint16* stbi__convert_8_to_16(stbi_uc* orig, int w, int h, int channels)
{
    int i;
    int img_len = w * h * channels;
    stbi__uint16* enlarged;

    enlarged = (stbi__uint16*)stbi__malloc(img_len * 2);
    if (enlarged == NULL) return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");

    for (i = 0; i < img_len; ++i)
        enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

    STBI_FREE(orig);
    return enlarged;
}

static void stbi__vertical_flip(void* image, int w, int h, int bytes_per_pixel)
{
    int row;
    size_t bytes_per_row = (size_t)w * bytes_per_pixel;
    stbi_uc temp[2048];
    stbi_uc* bytes = (stbi_uc*)image;

    for (row = 0; row < (h >> 1); row++) {
        stbi_uc* row0 = bytes + row * bytes_per_row;
        stbi_uc* row1 = bytes + (h - row - 1) * bytes_per_row;
        // swap row0 with row1
        size_t bytes_left = bytes_per_row;
        while (bytes_left) {
            size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
            memcpy(temp, row0, bytes_copy);
            memcpy(row0, row1, bytes_copy);
            memcpy(row1, temp, bytes_copy);
            row0 += bytes_copy;
            row1 += bytes_copy;
            bytes_left -= bytes_copy;
        }
    }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void* image, int w, int h, int z, int bytes_per_pixel)
{
    int slice;
    int slice_size = w * h * bytes_per_pixel;

    stbi_uc* bytes = (stbi_uc*)image;
    for (slice = 0; slice < z; ++slice) {
        stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
        bytes += slice_size;
    }
}
#endif

static unsigned char* stbi__load_and_postprocess_8bit(stbi__context* s, int* x, int* y, int* comp, int req_comp)
{
    stbi__result_info ri;
    void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

    if (result == NULL)
        return NULL;

    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

    if (ri.bits_per_channel != 8) {
        result = stbi__convert_16_to_8((stbi__uint16*)result, *x, *y, req_comp == 0 ? *comp : req_comp);
        ri.bits_per_channel = 8;
    }

    // @TODO: move stbi__convert_format to here

    if (stbi__vertically_flip_on_load) {
        int channels = req_comp ? req_comp : *comp;
        stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
    }

    return (unsigned char*)result;
}

static stbi__uint16* stbi__load_and_postprocess_16bit(stbi__context* s, int* x, int* y, int* comp, int req_comp)
{
    stbi__result_info ri;
    void* result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

    if (result == NULL)
        return NULL;

    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

    if (ri.bits_per_channel != 16) {
        result = stbi__convert_8_to_16((stbi_uc*)result, *x, *y, req_comp == 0 ? *comp : req_comp);
        ri.bits_per_channel = 16;
    }

    // @TODO: move stbi__convert_format16 to here
    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

    if (stbi__vertically_flip_on_load) {
        int channels = req_comp ? req_comp : *comp;
        stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
    }

    return (stbi__uint16*)result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float* result, int* x, int* y, int* comp, int req_comp)
{
    if (stbi__vertically_flip_on_load && result != NULL) {
        int channels = req_comp ? req_comp : *comp;
        stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
    }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char* str, int cbmb, wchar_t* widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t* widestr, int cchwide, char* str, int cbmb, const char* defchar, int* used_default);
#endif

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char* buffer, size_t bufferlen, const wchar_t* input)
{
    return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int)bufferlen, NULL, NULL);
}
#endif

static FILE* stbi__fopen(char const* filename, char const* mode)
{
    FILE* f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
    wchar_t wMode[64];
    wchar_t wFilename[1024];
    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename) / sizeof(*wFilename)))
        return 0;

    if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode) / sizeof(*wMode)))
        return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
    if (0 != _wfopen_s(&f, wFilename, wMode))
        f = 0;
#else
    f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
    if (0 != fopen_s(&f, filename, mode))
        f = 0;
#else
    f = fopen(filename, mode);
#endif
    return f;
}


STBIDEF stbi_uc* stbi_load(char const* filename, int* x, int* y, int* comp, int req_comp)
{
    FILE* f = stbi__fopen(filename, "rb");
    unsigned char* result;
    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
    result = stbi_load_from_file(f, x, y, comp, req_comp);
    fclose(f);
    return result;
}

STBIDEF stbi_uc* stbi_load_from_file(FILE* f, int* x, int* y, int* comp, int req_comp)
{
    unsigned char* result;
    stbi__context s;
    stbi__start_file(&s, f);
    result = stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
    if (result) {
        // need to 'unget' all the characters in the IO buffer
        fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);
    }
    return result;
}

STBIDEF stbi__uint16* stbi_load_from_file_16(FILE* f, int* x, int* y, int* comp, int req_comp)
{
    stbi__uint16* result;
    stbi__context s;
    stbi__start_file(&s, f);
    result = stbi__load_and_postprocess_16bit(&s, x, y, comp, req_comp);
    if (result) {
        // need to 'unget' all the characters in the IO buffer
        fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);
    }
    return result;
}

STBIDEF stbi_us* stbi_load_16(char const* filename, int* x, int* y, int* comp, int req_comp)
{
    FILE* f = stbi__fopen(filename, "rb");
    stbi__uint16* result;
    if (!f) return (stbi_us*)stbi__errpuc("can't fopen", "Unable to open file");
    result = stbi_load_from_file_16(f, x, y, comp, req_comp);
    fclose(f);
    return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us* stbi_load_16_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* channels_in_file, int desired_channels)
{
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);
}

STBIDEF stbi_us* stbi_load_16_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* channels_in_file, int desired_channels)
{
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);
    return stbi__load_and_postprocess_16bit(&s, x, y, channels_in_file, desired_channels);
}

STBIDEF stbi_uc* stbi_load_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp, int req_comp)
{
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
}

STBIDEF stbi_uc* stbi_load_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp, int req_comp)
{
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);
    return stbi__load_and_postprocess_8bit(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc* stbi_load_gif_from_memory(stbi_uc const* buffer, int len, int** delays, int* x, int* y, int* z, int* comp, int req_comp)
{
    unsigned char* result;
    stbi__context s;
    stbi__start_mem(&s, buffer, len);

    result = (unsigned char*)stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
    if (stbi__vertically_flip_on_load) {
        stbi__vertical_flip_slices(result, *x, *y, *z, *comp);
    }

    return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float* stbi__loadf_main(stbi__context* s, int* x, int* y, int* comp, int req_comp)
{
    unsigned char* data;
#ifndef STBI_NO_HDR
    if (stbi__hdr_test(s)) {
        stbi__result_info ri;
        float* hdr_data = stbi__hdr_load(s, x, y, comp, req_comp, &ri);
        if (hdr_data)
            stbi__float_postprocess(hdr_data, x, y, comp, req_comp);
        return hdr_data;
    }
#endif
    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
    if (data)
        return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float* stbi_loadf_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp, int req_comp)
{
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__loadf_main(&s, x, y, comp, req_comp);
}

STBIDEF float* stbi_loadf_from_callbacks(stbi_io_callbacks const* clbk, void* user, int* x, int* y, int* comp, int req_comp)
{
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);
    return stbi__loadf_main(&s, x, y, comp, req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float* stbi_loadf(char const* filename, int* x, int* y, int* comp, int req_comp)
{
    float* result;
    FILE* f = stbi__fopen(filename, "rb");
    if (!f) return stbi__errpf("can't fopen", "Unable to open file");
    result = stbi_loadf_from_file(f, x, y, comp, req_comp);
    fclose(f);
    return result;
}

STBIDEF float* stbi_loadf_from_file(FILE* f, int* x, int* y, int* comp, int req_comp)
{
    stbi__context s;
    stbi__start_file(&s, f);
    return stbi__loadf_main(&s, x, y, comp, req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const* buffer, int len)
{
#ifndef STBI_NO_HDR
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__hdr_test(&s);
#else
    STBI_NOTUSED(buffer);
    STBI_NOTUSED(len);
    return 0;
#endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr(char const* filename)
{
    FILE* f = stbi__fopen(filename, "rb");
    int result = 0;
    if (f) {
        result = stbi_is_hdr_from_file(f);
        fclose(f);
    }
    return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE* f)
{
#ifndef STBI_NO_HDR
    long pos = ftell(f);
    int res;
    stbi__context s;
    stbi__start_file(&s, f);
    res = stbi__hdr_test(&s);
    fseek(f, pos, SEEK_SET);
    return res;
#else
    STBI_NOTUSED(f);
    return 0;
#endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const* clbk, void* user)
{
#ifndef STBI_NO_HDR
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);
    return stbi__hdr_test(&s);
#else
    STBI_NOTUSED(clbk);
    STBI_NOTUSED(user);
    return 0;
#endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma = 2.2f, stbi__l2h_scale = 1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i = 1.0f / 2.2f, stbi__h2l_scale_i = 1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
    STBI__SCAN_load = 0,
    STBI__SCAN_type,
    STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context* s)
{
    int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);
    s->callback_already_read += (int)(s->img_buffer - s->img_buffer_original);
    if (n == 0) {
        // at end of file, treat same as if from memory, but need to handle case
        // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
        s->read_from_callbacks = 0;
        s->img_buffer = s->buffer_start;
        s->img_buffer_end = s->buffer_start + 1;
        *s->img_buffer = 0;
    }
    else {
        s->img_buffer = s->buffer_start;
        s->img_buffer_end = s->buffer_start + n;
    }
}

stbi_inline static stbi_uc stbi__get8(stbi__context* s)
{
    if (s->img_buffer < s->img_buffer_end)
        return *s->img_buffer++;
    if (s->read_from_callbacks) {
        stbi__refill_buffer(s);
        return *s->img_buffer++;
    }
    return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context* s)
{
    if (s->io.read) {
        if (!(s->io.eof)(s->io_user_data)) return 0;
        // if feof() is true, check if buffer = end
        // special case: we've only got the special 0 character at the end
        if (s->read_from_callbacks == 0) return 1;
    }

    return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context* s, int n)
{
    if (n == 0) return;  // already there!
    if (n < 0) {
        s->img_buffer = s->img_buffer_end;
        return;
    }
    if (s->io.read) {
        int blen = (int)(s->img_buffer_end - s->img_buffer);
        if (blen < n) {
            s->img_buffer = s->img_buffer_end;
            (s->io.skip)(s->io_user_data, n - blen);
            return;
        }
    }
    s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context* s, stbi_uc* buffer, int n)
{
    if (s->io.read) {
        int blen = (int)(s->img_buffer_end - s->img_buffer);
        if (blen < n) {
            int res, count;

            memcpy(buffer, s->img_buffer, blen);

            count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);
            res = (count == (n - blen));
            s->img_buffer = s->img_buffer_end;
            return res;
        }
    }

    if (s->img_buffer + n <= s->img_buffer_end) {
        memcpy(buffer, s->img_buffer, n);
        s->img_buffer += n;
        return 1;
    }
    else
        return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context* s)
{
    int z = stbi__get8(s);
    return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context* s)
{
    stbi__uint32 z = stbi__get16be(s);
    return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context* s)
{
    int z = stbi__get8(s);
    return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context* s)
{
    stbi__uint32 z = stbi__get16le(s);
    z += (stbi__uint32)stbi__get16le(s) << 16;
    return z;
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
    return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char* stbi__convert_format(unsigned char* data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
    int i, j;
    unsigned char* good;

    if (req_comp == img_n) return data;
    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

    good = (unsigned char*)stbi__malloc_mad3(req_comp, x, y, 0);
    if (good == NULL) {
        STBI_FREE(data);
        return stbi__errpuc("outofmem", "Out of memory");
    }

    for (j = 0; j < (int)y; ++j) {
        unsigned char* src = data + j * x * img_n;
        unsigned char* dest = good + j * x * req_comp;

#define STBI__COMBO(a,b)  ((a)*8+(b))
#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        // convert source image with img_n components to one with req_comp components;
        // avoid switch per pixel, so use switch per scanline and massive macros
        switch (STBI__COMBO(img_n, req_comp)) {
            STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 255; } break;
            STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
            STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 255; } break;
            STBI__CASE(2, 1) { dest[0] = src[0]; } break;
            STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
            STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;
            STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 255; } break;
            STBI__CASE(3, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;
            STBI__CASE(3, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = 255; } break;
            STBI__CASE(4, 1) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); } break;
            STBI__CASE(4, 2) { dest[0] = stbi__compute_y(src[0], src[1], src[2]); dest[1] = src[3]; } break;
            STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;
        default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
        }
#undef STBI__CASE
    }

    STBI_FREE(data);
    return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
    return (stbi__uint16)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16* stbi__convert_format16(stbi__uint16* data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
    int i, j;
    stbi__uint16* good;

    if (req_comp == img_n) return data;
    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

    good = (stbi__uint16*)stbi__malloc(req_comp * x * y * 2);
    if (good == NULL) {
        STBI_FREE(data);
        return (stbi__uint16*)stbi__errpuc("outofmem", "Out of memory");
    }

    for (j = 0; j < (int)y; ++j) {
        stbi__uint16* src = data + j * x * img_n;
        stbi__uint16* dest = good + j * x * req_comp;

#define STBI__COMBO(a,b)  ((a)*8+(b))
#define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        // convert source image with img_n components to one with req_comp components;
        // avoid switch per pixel, so use switch per scanline and massive macros
        switch (STBI__COMBO(img_n, req_comp)) {
            STBI__CASE(1, 2) { dest[0] = src[0]; dest[1] = 0xffff; } break;
            STBI__CASE(1, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
            STBI__CASE(1, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = 0xffff; } break;
            STBI__CASE(2, 1) { dest[0] = src[0]; } break;
            STBI__CASE(2, 3) { dest[0] = dest[1] = dest[2] = src[0]; } break;
            STBI__CASE(2, 4) { dest[0] = dest[1] = dest[2] = src[0]; dest[3] = src[1]; } break;
            STBI__CASE(3, 4) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; dest[3] = 0xffff; } break;
            STBI__CASE(3, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;
            STBI__CASE(3, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = 0xffff; } break;
            STBI__CASE(4, 1) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); } break;
            STBI__CASE(4, 2) { dest[0] = stbi__compute_y_16(src[0], src[1], src[2]); dest[1] = src[3]; } break;
            STBI__CASE(4, 3) { dest[0] = src[0]; dest[1] = src[1]; dest[2] = src[2]; } break;
        default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*)stbi__errpuc("unsupported", "Unsupported format conversion");
        }
#undef STBI__CASE
    }

    STBI_FREE(data);
    return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float* stbi__ldr_to_hdr(stbi_uc* data, int x, int y, int comp)
{
    int i, k, n;
    float* output;
    if (!data) return NULL;
    output = (float*)stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
    // compute number of non-alpha components
    if (comp & 1) n = comp; else n = comp - 1;
    for (i = 0; i < x * y; ++i) {
        for (k = 0; k < n; ++k) {
            output[i * comp + k] = (float)(pow(data[i * comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
        }
    }
    if (n < comp) {
        for (i = 0; i < x * y; ++i) {
            output[i * comp + n] = data[i * comp + n] / 255.0f;
        }
    }
    STBI_FREE(data);
    return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc* stbi__hdr_to_ldr(float* data, int x, int y, int comp)
{
    int i, k, n;
    stbi_uc* output;
    if (!data) return NULL;
    output = (stbi_uc*)stbi__malloc_mad3(x, y, comp, 0);
    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
    // compute number of non-alpha components
    if (comp & 1) n = comp; else n = comp - 1;
    for (i = 0; i < x * y; ++i) {
        for (k = 0; k < n; ++k) {
            float z = (float)pow(data[i * comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
            if (z < 0) z = 0;
            if (z > 255) z = 255;
            output[i * comp + k] = (stbi_uc)stbi__float2int(z);
        }
        if (k < comp) {
            float z = data[i * comp + k] * 255 + 0.5f;
            if (z < 0) z = 0;
            if (z > 255) z = 255;
            output[i * comp + k] = (stbi_uc)stbi__float2int(z);
        }
    }
    STBI_FREE(data);
    return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
    stbi_uc  fast[1 << FAST_BITS];
    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
    stbi__uint16 code[256];
    stbi_uc  values[256];
    stbi_uc  size[257];
    unsigned int maxcode[18];
    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
    stbi__context* s;
    stbi__huffman huff_dc[4];
    stbi__huffman huff_ac[4];
    stbi__uint16 dequant[4][64];
    stbi__int16 fast_ac[4][1 << FAST_BITS];

    // sizes for components, interleaved MCUs
    int img_h_max, img_v_max;
    int img_mcu_x, img_mcu_y;
    int img_mcu_w, img_mcu_h;

    // definition of jpeg image component
    struct
    {
        int id;
        int h, v;
        int tq;
        int hd, ha;
        int dc_pred;

        int x, y, w2, h2;
        stbi_uc* data;
        void* raw_data, * raw_coeff;
        stbi_uc* linebuf;
        short* coeff;   // progressive only
        int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
    } img_comp[4];

    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
    int            code_bits;   // number of valid bits
    unsigned char  marker;      // marker seen while filling entropy buffer
    int            nomore;      // flag if we saw a marker so must stop

    int            progressive;
    int            spec_start;
    int            spec_end;
    int            succ_high;
    int            succ_low;
    int            eob_run;
    int            jfif;
    int            app14_color_transform; // Adobe APP14 tag
    int            rgb;

    int scan_n, order[4];
    int restart_interval, todo;

    // kernels
    void (*idct_block_kernel)(stbi_uc* out, int out_stride, short data[64]);
    void (*YCbCr_to_RGB_kernel)(stbi_uc* out, const stbi_uc* y, const stbi_uc* pcb, const stbi_uc* pcr, int count, int step);
    stbi_uc* (*resample_row_hv_2_kernel)(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman* h, int* count)
{
    int i, j, k = 0;
    unsigned int code;
    // build size list for each symbol (from JPEG spec)
    for (i = 0; i < 16; ++i)
        for (j = 0; j < count[i]; ++j)
            h->size[k++] = (stbi_uc)(i + 1);
    h->size[k] = 0;

    // compute actual symbols (from jpeg spec)
    code = 0;
    k = 0;
    for (j = 1; j <= 16; ++j) {
        // compute delta to add to code to compute symbol id
        h->delta[j] = k - code;
        if (h->size[k] == j) {
            while (h->size[k] == j)
                h->code[k++] = (stbi__uint16)(code++);
            if (code - 1 >= (1u << j)) return stbi__err("bad code lengths", "Corrupt JPEG");
        }
        // compute largest code + 1 for this size, preshifted as needed later
        h->maxcode[j] = code << (16 - j);
        code <<= 1;
    }
    h->maxcode[j] = 0xffffffff;

    // build non-spec acceleration table; 255 is flag for not-accelerated
    memset(h->fast, 255, 1 << FAST_BITS);
    for (i = 0; i < k; ++i) {
        int s = h->size[i];
        if (s <= FAST_BITS) {
            int c = h->code[i] << (FAST_BITS - s);
            int m = 1 << (FAST_BITS - s);
            for (j = 0; j < m; ++j) {
                h->fast[c + j] = (stbi_uc)i;
            }
        }
    }
    return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16* fast_ac, stbi__huffman* h)
{
    int i;
    for (i = 0; i < (1 << FAST_BITS); ++i) {
        stbi_uc fast = h->fast[i];
        fast_ac[i] = 0;
        if (fast < 255) {
            int rs = h->values[fast];
            int run = (rs >> 4) & 15;
            int magbits = rs & 15;
            int len = h->size[fast];

            if (magbits && len + magbits <= FAST_BITS) {
                // magnitude code followed by receive_extend code
                int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
                int m = 1 << (magbits - 1);
                if (k < m) k += (~0U << magbits) + 1;
                // if the result is small enough, we can fit it in fast_ac table
                if (k >= -128 && k <= 127)
                    fast_ac[i] = (stbi__int16)((k * 256) + (run * 16) + (len + magbits));
            }
        }
    }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg* j)
{
    do {
        unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
        if (b == 0xff) {
            int c = stbi__get8(j->s);
            while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
            if (c != 0) {
                j->marker = (unsigned char)c;
                j->nomore = 1;
                return;
            }
        }
        j->code_buffer |= b << (24 - j->code_bits);
        j->code_bits += 8;
    } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17] = { 0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535 };

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg* j, stbi__huffman* h)
{
    unsigned int temp;
    int c, k;

    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

    // look at the top FAST_BITS and determine what symbol ID it is,
    // if the code is <= FAST_BITS
    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
    k = h->fast[c];
    if (k < 255) {
        int s = h->size[k];
        if (s > j->code_bits)
            return -1;
        j->code_buffer <<= s;
        j->code_bits -= s;
        return h->values[k];
    }

    // naive test is to shift the code_buffer down so k bits are
    // valid, then test against maxcode. To speed this up, we've
    // preshifted maxcode left so that it has (16-k) 0s at the
    // end; in other words, regardless of the number of bits, it
    // wants to be compared against something shifted to have 16;
    // that way we don't need to shift inside the loop.
    temp = j->code_buffer >> 16;
    for (k = FAST_BITS + 1; ; ++k)
        if (temp < h->maxcode[k])
            break;
    if (k == 17) {
        // error! code not found
        j->code_bits -= 16;
        return -1;
    }

    if (k > j->code_bits)
        return -1;

    // convert the huffman code to the symbol id
    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

    // convert the id to a symbol
    j->code_bits -= k;
    j->code_buffer <<= k;
    return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = { 0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767 };

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg* j, int n)
{
    unsigned int k;
    int sgn;
    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
    k = stbi_lrot(j->code_buffer, n);
    j->code_buffer = k & ~stbi__bmask[n];
    k &= stbi__bmask[n];
    j->code_bits -= n;
    return k + (stbi__jbias[n] & (sgn - 1));
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg* j, int n)
{
    unsigned int k;
    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    k = stbi_lrot(j->code_buffer, n);
    j->code_buffer = k & ~stbi__bmask[n];
    k &= stbi__bmask[n];
    j->code_bits -= n;
    return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg* j)
{
    unsigned int k;
    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
    k = j->code_buffer;
    j->code_buffer <<= 1;
    --j->code_bits;
    return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64 + 15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg* j, short data[64], stbi__huffman* hdc, stbi__huffman* hac, stbi__int16* fac, int b, stbi__uint16* dequant)
{
    int diff, dc, k;
    int t;

    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    t = stbi__jpeg_huff_decode(j, hdc);
    if (t < 0 || t > 15) return stbi__err("bad huffman code", "Corrupt JPEG");

    // 0 all the ac values now so we can do it 32-bits at a time
    memset(data, 0, 64 * sizeof(data[0]));

    diff = t ? stbi__extend_receive(j, t) : 0;
    dc = j->img_comp[b].dc_pred + diff;
    j->img_comp[b].dc_pred = dc;
    data[0] = (short)(dc * dequant[0]);

    // decode AC components, see JPEG spec
    k = 1;
    do {
        unsigned int zig;
        int c, r, s;
        if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
        c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
        r = fac[c];
        if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short)((r >> 8) * dequant[zig]);
        }
        else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
                if (rs != 0xf0) break; // end block
                k += 16;
            }
            else {
                k += r;
                // decode into unzigzag'd location
                zig = stbi__jpeg_dezigzag[k++];
                data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);
            }
        }
    } while (k < 64);
    return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg* j, short data[64], stbi__huffman* hdc, int b)
{
    int diff, dc;
    int t;
    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

    if (j->succ_high == 0) {
        // first scan for DC coefficient, must be first
        memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now
        t = stbi__jpeg_huff_decode(j, hdc);
        if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
        diff = t ? stbi__extend_receive(j, t) : 0;

        dc = j->img_comp[b].dc_pred + diff;
        j->img_comp[b].dc_pred = dc;
        data[0] = (short)(dc * (1 << j->succ_low));
    }
    else {
        // refinement scan for DC coefficient
        if (stbi__jpeg_get_bit(j))
            data[0] += (short)(1 << j->succ_low);
    }
    return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg* j, short data[64], stbi__huffman* hac, stbi__int16* fac)
{
    int k;
    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

    if (j->succ_high == 0) {
        int shift = j->succ_low;

        if (j->eob_run) {
            --j->eob_run;
            return 1;
        }

        k = j->spec_start;
        do {
            unsigned int zig;
            int c, r, s;
            if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
            c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);
            r = fac[c];
            if (r) { // fast-AC path
                k += (r >> 4) & 15; // run
                s = r & 15; // combined length
                j->code_buffer <<= s;
                j->code_bits -= s;
                zig = stbi__jpeg_dezigzag[k++];
                data[zig] = (short)((r >> 8) * (1 << shift));
            }
            else {
                int rs = stbi__jpeg_huff_decode(j, hac);
                if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
                s = rs & 15;
                r = rs >> 4;
                if (s == 0) {
                    if (r < 15) {
                        j->eob_run = (1 << r);
                        if (r)
                            j->eob_run += stbi__jpeg_get_bits(j, r);
                        --j->eob_run;
                        break;
                    }
                    k += 16;
                }
                else {
                    k += r;
                    zig = stbi__jpeg_dezigzag[k++];
                    data[zig] = (short)(stbi__extend_receive(j, s) * (1 << shift));
                }
            }
        } while (k <= j->spec_end);
    }
    else {
        // refinement scan for these AC coefficients

        short bit = (short)(1 << j->succ_low);

        if (j->eob_run) {
            --j->eob_run;
            for (k = j->spec_start; k <= j->spec_end; ++k) {
                short* p = &data[stbi__jpeg_dezigzag[k]];
                if (*p != 0)
                    if (stbi__jpeg_get_bit(j))
                        if ((*p & bit) == 0) {
                            if (*p > 0)
                                *p += bit;
                            else
                                *p -= bit;
                        }
            }
        }
        else {
            k = j->spec_start;
            do {
                int r, s;
                int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
                if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");
                s = rs & 15;
                r = rs >> 4;
                if (s == 0) {
                    if (r < 15) {
                        j->eob_run = (1 << r) - 1;
                        if (r)
                            j->eob_run += stbi__jpeg_get_bits(j, r);
                        r = 64; // force end of block
                    }
                    else {
                        // r=15 s=0 should write 16 0s, so we just do
                        // a run of 15 0s and then write s (which is 0),
                        // so we don't have to do anything special here
                    }
                }
                else {
                    if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
                    // sign bit
                    if (stbi__jpeg_get_bit(j))
                        s = bit;
                    else
                        s = -bit;
                }

                // advance by r
                while (k <= j->spec_end) {
                    short* p = &data[stbi__jpeg_dezigzag[k++]];
                    if (*p != 0) {
                        if (stbi__jpeg_get_bit(j))
                            if ((*p & bit) == 0) {
                                if (*p > 0)
                                    *p += bit;
                                else
                                    *p -= bit;
                            }
                    }
                    else {
                        if (r == 0) {
                            *p = (short)s;
                            break;
                        }
                        --r;
                    }
                }
            } while (k <= j->spec_end);
        }
    }
    return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
    // trick to use a single test to catch both cases
    if ((unsigned int)x > 255) {
        if (x < 0) return 0;
        if (x > 255) return 255;
    }
    return (stbi_uc)x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc* out, int out_stride, short data[64])
{
    int i, val[64], * v = val;
    stbi_uc* o;
    short* d = data;

    // columns
    for (i = 0; i < 8; ++i, ++d, ++v) {
        // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
        if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
            && d[40] == 0 && d[48] == 0 && d[56] == 0) {
            //    no shortcut                 0     seconds
            //    (1|2|3|4|5|6|7)==0          0     seconds
            //    all separate               -0.047 seconds
            //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
            int dcterm = d[0] * 4;
            v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
        }
        else {
            STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])
                // constants scaled things up by 1<<12; let's bring them back
                // down, but keep 2 extra bits of precision
                x0 += 512; x1 += 512; x2 += 512; x3 += 512;
            v[0] = (x0 + t3) >> 10;
            v[56] = (x0 - t3) >> 10;
            v[8] = (x1 + t2) >> 10;
            v[48] = (x1 - t2) >> 10;
            v[16] = (x2 + t1) >> 10;
            v[40] = (x2 - t1) >> 10;
            v[24] = (x3 + t0) >> 10;
            v[32] = (x3 - t0) >> 10;
        }
    }

    for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {
        // no fast case since the first 1D IDCT spread components out
        STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
            // constants scaled things up by 1<<12, plus we had 1<<2 from first
            // loop, plus horizontal and vertical each scale by sqrt(8) so together
            // we've got an extra 1<<3, so 1<<17 total we need to remove.
            // so we want to round that, which means adding 0.5 * 1<<17,
            // aka 65536. Also, we'll end up with -128 to 127 that we want
            // to encode as 0..255 by adding 128, so we'll add that before the shift
            x0 += 65536 + (128 << 17);
        x1 += 65536 + (128 << 17);
        x2 += 65536 + (128 << 17);
        x3 += 65536 + (128 << 17);
        // tried computing the shifts into temps, or'ing the temps to see
        // if any were out of range, but that was slower
        o[0] = stbi__clamp((x0 + t3) >> 17);
        o[7] = stbi__clamp((x0 - t3) >> 17);
        o[1] = stbi__clamp((x1 + t2) >> 17);
        o[6] = stbi__clamp((x1 - t2) >> 17);
        o[2] = stbi__clamp((x2 + t1) >> 17);
        o[5] = stbi__clamp((x2 - t1) >> 17);
        o[3] = stbi__clamp((x3 + t0) >> 17);
        o[4] = stbi__clamp((x3 - t0) >> 17);
    }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc* out, int out_stride, short data[64])
{
    // This is constructed to match our regular (generic) integer IDCT exactly.
    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
    __m128i tmp;

    // dot product constant: even elems=x, odd elems=y
#define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

// out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
// out(1) = c1[even]*x + c1[odd]*y
#define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
#define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
#define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
#define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
#define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
#define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
#define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

#define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f(0.765366865f), stbi__f2f(0.5411961f));
    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f(0.298631336f), stbi__f2f(-1.961570560f));
    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f(3.072711026f));
    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f(2.053119869f), stbi__f2f(-0.390180644f));
    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f(1.501321110f));

    // rounding biases in column/row passes, see stbi__idct_block for explanation.
    __m128i bias_0 = _mm_set1_epi32(512);
    __m128i bias_1 = _mm_set1_epi32(65536 + (128 << 17));

    // load
    row0 = _mm_load_si128((const __m128i*) (data + 0 * 8));
    row1 = _mm_load_si128((const __m128i*) (data + 1 * 8));
    row2 = _mm_load_si128((const __m128i*) (data + 2 * 8));
    row3 = _mm_load_si128((const __m128i*) (data + 3 * 8));
    row4 = _mm_load_si128((const __m128i*) (data + 4 * 8));
    row5 = _mm_load_si128((const __m128i*) (data + 5 * 8));
    row6 = _mm_load_si128((const __m128i*) (data + 6 * 8));
    row7 = _mm_load_si128((const __m128i*) (data + 7 * 8));

    // column pass
    dct_pass(bias_0, 10);

    {
        // 16bit 8x8 transpose pass 1
        dct_interleave16(row0, row4);
        dct_interleave16(row1, row5);
        dct_interleave16(row2, row6);
        dct_interleave16(row3, row7);

        // transpose pass 2
        dct_interleave16(row0, row2);
        dct_interleave16(row1, row3);
        dct_interleave16(row4, row6);
        dct_interleave16(row5, row7);

        // transpose pass 3
        dct_interleave16(row0, row1);
        dct_interleave16(row2, row3);
        dct_interleave16(row4, row5);
        dct_interleave16(row6, row7);
    }

    // row pass
    dct_pass(bias_1, 17);

    {
        // pack
        __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
        __m128i p1 = _mm_packus_epi16(row2, row3);
        __m128i p2 = _mm_packus_epi16(row4, row5);
        __m128i p3 = _mm_packus_epi16(row6, row7);

        // 8bit 8x8 transpose pass 1
        dct_interleave8(p0, p2); // a0e0a1e1...
        dct_interleave8(p1, p3); // c0g0c1g1...

        // transpose pass 2
        dct_interleave8(p0, p1); // a0c0e0g0...
        dct_interleave8(p2, p3); // b0d0f0h0...

        // transpose pass 3
        dct_interleave8(p0, p2); // a0b0c0d0...
        dct_interleave8(p1, p3); // a4b4c4d4...

        // store
        _mm_storel_epi64((__m128i*) out, p0); out += out_stride;
        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
        _mm_storel_epi64((__m128i*) out, p2); out += out_stride;
        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
        _mm_storel_epi64((__m128i*) out, p1); out += out_stride;
        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
        _mm_storel_epi64((__m128i*) out, p3); out += out_stride;
        _mm_storel_epi64((__m128i*) out, _mm_shuffle_epi32(p3, 0x4e));
    }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc* out, int out_stride, short data[64])
{
    int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

    int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
    int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
    int16x4_t rot0_2 = vdup_n_s16(stbi__f2f(0.765366865f));
    int16x4_t rot1_0 = vdup_n_s16(stbi__f2f(1.175875602f));
    int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
    int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
    int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
    int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
    int16x4_t rot3_0 = vdup_n_s16(stbi__f2f(0.298631336f));
    int16x4_t rot3_1 = vdup_n_s16(stbi__f2f(2.053119869f));
    int16x4_t rot3_2 = vdup_n_s16(stbi__f2f(3.072711026f));
    int16x4_t rot3_3 = vdup_n_s16(stbi__f2f(1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

    // wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
    row0 = vld1q_s16(data + 0 * 8);
    row1 = vld1q_s16(data + 1 * 8);
    row2 = vld1q_s16(data + 2 * 8);
    row3 = vld1q_s16(data + 3 * 8);
    row4 = vld1q_s16(data + 4 * 8);
    row5 = vld1q_s16(data + 5 * 8);
    row6 = vld1q_s16(data + 6 * 8);
    row7 = vld1q_s16(data + 7 * 8);

    // add DC bias
    row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

    // column pass
    dct_pass(vrshrn_n_s32, 10);

    // 16bit 8x8 transpose
    {
        // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
        // whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
        dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
        dct_trn16(row2, row3);
        dct_trn16(row4, row5);
        dct_trn16(row6, row7);

        // pass 2
        dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
        dct_trn32(row1, row3);
        dct_trn32(row4, row6);
        dct_trn32(row5, row7);

        // pass 3
        dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
        dct_trn64(row1, row5);
        dct_trn64(row2, row6);
        dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
    }

    // row pass
    // vrshrn_n_s32 only supports shifts up to 16, we need
    // 17. so do a non-rounding shift of 16 first then follow
    // up with a rounding shift by 1.
    dct_pass(vshrn_n_s32, 16);

    {
        // pack and round
        uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
        uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
        uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
        uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
        uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
        uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
        uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
        uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

        // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
        dct_trn8_8(p0, p1);
        dct_trn8_8(p2, p3);
        dct_trn8_8(p4, p5);
        dct_trn8_8(p6, p7);

        // pass 2
        dct_trn8_16(p0, p2);
        dct_trn8_16(p1, p3);
        dct_trn8_16(p4, p6);
        dct_trn8_16(p5, p7);

        // pass 3
        dct_trn8_32(p0, p4);
        dct_trn8_32(p1, p5);
        dct_trn8_32(p2, p6);
        dct_trn8_32(p3, p7);

        // store
        vst1_u8(out, p0); out += out_stride;
        vst1_u8(out, p1); out += out_stride;
        vst1_u8(out, p2); out += out_stride;
        vst1_u8(out, p3); out += out_stride;
        vst1_u8(out, p4); out += out_stride;
        vst1_u8(out, p5); out += out_stride;
        vst1_u8(out, p6); out += out_stride;
        vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
    }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg* j)
{
    stbi_uc x;
    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
    x = stbi__get8(j->s);
    if (x != 0xff) return STBI__MARKER_none;
    while (x == 0xff)
        x = stbi__get8(j->s); // consume repeated 0xff fill bytes
    return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg* j)
{
    j->code_bits = 0;
    j->code_buffer = 0;
    j->nomore = 0;
    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
    j->marker = STBI__MARKER_none;
    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
    j->eob_run = 0;
    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
    // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg* z)
{
    stbi__jpeg_reset(z);
    if (!z->progressive) {
        if (z->scan_n == 1) {
            int i, j;
            STBI_SIMD_ALIGN(short, data[64]);
            int n = z->order[0];
            // non-interleaved data, we just need to process one block at a time,
            // in trivial scanline order
            // number of blocks to do just depends on how many actual "pixels" this
            // component has, independent of interleaved MCU blocking and such
            int w = (z->img_comp[n].x + 7) >> 3;
            int h = (z->img_comp[n].y + 7) >> 3;
            for (j = 0; j < h; ++j) {
                for (i = 0; i < w; ++i) {
                    int ha = z->img_comp[n].ha;
                    if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                    z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);
                    // every data block is an MCU, so countdown the restart interval
                    if (--z->todo <= 0) {
                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                        // if it's NOT a restart, then just bail, so we get corrupt data
                        // rather than no data
                        if (!STBI__RESTART(z->marker)) return 1;
                        stbi__jpeg_reset(z);
                    }
                }
            }
            return 1;
        }
        else { // interleaved
            int i, j, k, x, y;
            STBI_SIMD_ALIGN(short, data[64]);
            for (j = 0; j < z->img_mcu_y; ++j) {
                for (i = 0; i < z->img_mcu_x; ++i) {
                    // scan an interleaved mcu... process scan_n components in order
                    for (k = 0; k < z->scan_n; ++k) {
                        int n = z->order[k];
                        // scan out an mcu's worth of this component; that's just determined
                        // by the basic H and V specified for the component
                        for (y = 0; y < z->img_comp[n].v; ++y) {
                            for (x = 0; x < z->img_comp[n].h; ++x) {
                                int x2 = (i * z->img_comp[n].h + x) * 8;
                                int y2 = (j * z->img_comp[n].v + y) * 8;
                                int ha = z->img_comp[n].ha;
                                if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                                z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * y2 + x2, z->img_comp[n].w2, data);
                            }
                        }
                    }
                    // after all interleaved components, that's an interleaved MCU,
                    // so now count down the restart interval
                    if (--z->todo <= 0) {
                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                        if (!STBI__RESTART(z->marker)) return 1;
                        stbi__jpeg_reset(z);
                    }
                }
            }
            return 1;
        }
    }
    else {
        if (z->scan_n == 1) {
            int i, j;
            int n = z->order[0];
            // non-interleaved data, we just need to process one block at a time,
            // in trivial scanline order
            // number of blocks to do just depends on how many actual "pixels" this
            // component has, independent of interleaved MCU blocking and such
            int w = (z->img_comp[n].x + 7) >> 3;
            int h = (z->img_comp[n].y + 7) >> 3;
            for (j = 0; j < h; ++j) {
                for (i = 0; i < w; ++i) {
                    short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
                    if (z->spec_start == 0) {
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                            return 0;
                    }
                    else {
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                            return 0;
                    }
                    // every data block is an MCU, so countdown the restart interval
                    if (--z->todo <= 0) {
                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                        if (!STBI__RESTART(z->marker)) return 1;
                        stbi__jpeg_reset(z);
                    }
                }
            }
            return 1;
        }
        else { // interleaved
            int i, j, k, x, y;
            for (j = 0; j < z->img_mcu_y; ++j) {
                for (i = 0; i < z->img_mcu_x; ++i) {
                    // scan an interleaved mcu... process scan_n components in order
                    for (k = 0; k < z->scan_n; ++k) {
                        int n = z->order[k];
                        // scan out an mcu's worth of this component; that's just determined
                        // by the basic H and V specified for the component
                        for (y = 0; y < z->img_comp[n].v; ++y) {
                            for (x = 0; x < z->img_comp[n].h; ++x) {
                                int x2 = (i * z->img_comp[n].h + x);
                                int y2 = (j * z->img_comp[n].v + y);
                                short* data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                                if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                                    return 0;
                            }
                        }
                    }
                    // after all interleaved components, that's an interleaved MCU,
                    // so now count down the restart interval
                    if (--z->todo <= 0) {
                        if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                        if (!STBI__RESTART(z->marker)) return 1;
                        stbi__jpeg_reset(z);
                    }
                }
            }
            return 1;
        }
    }
}

static void stbi__jpeg_dequantize(short* data, stbi__uint16* dequant)
{
    int i;
    for (i = 0; i < 64; ++i)
        data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg* z)
{
    if (z->progressive) {
        // dequantize and idct the data
        int i, j, n;
        for (n = 0; n < z->s->img_n; ++n) {
            int w = (z->img_comp[n].x + 7) >> 3;
            int h = (z->img_comp[n].y + 7) >> 3;
            for (j = 0; j < h; ++j) {
                for (i = 0; i < w; ++i) {
                    short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
                    stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
                    z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);
                }
            }
        }
    }
}

static int stbi__process_marker(stbi__jpeg* z, int m)
{
    int L;
    switch (m) {
    case STBI__MARKER_none: // no marker found
        return stbi__err("expected marker", "Corrupt JPEG");

    case 0xDD: // DRI - specify restart interval
        if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");
        z->restart_interval = stbi__get16be(z->s);
        return 1;

    case 0xDB: // DQT - define quantization table
        L = stbi__get16be(z->s) - 2;
        while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15, i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type", "Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");

            for (i = 0; i < 64; ++i)
                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
        }
        return L == 0;

    case 0xC4: // DHT - define huffman table
        L = stbi__get16be(z->s) - 2;
        while (L > 0) {
            stbi_uc* v;
            int sizes[16], i, n = 0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");
            for (i = 0; i < 16; ++i) {
                sizes[i] = stbi__get8(z->s);
                n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
                if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;
                v = z->huff_dc[th].values;
            }
            else {
                if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;
                v = z->huff_ac[th].values;
            }
            for (i = 0; i < n; ++i)
                v[i] = stbi__get8(z->s);
            if (tc != 0)
                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
        }
        return L == 0;
    }

    // check for comment block or APP blocks
    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
        L = stbi__get16be(z->s);
        if (L < 2) {
            if (m == 0xFE)
                return stbi__err("bad COM len", "Corrupt JPEG");
            else
                return stbi__err("bad APP len", "Corrupt JPEG");
        }
        L -= 2;

        if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
            static const unsigned char tag[5] = { 'J','F','I','F','\0' };
            int ok = 1;
            int i;
            for (i = 0; i < 5; ++i)
                if (stbi__get8(z->s) != tag[i])
                    ok = 0;
            L -= 5;
            if (ok)
                z->jfif = 1;
        }
        else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
            static const unsigned char tag[6] = { 'A','d','o','b','e','\0' };
            int ok = 1;
            int i;
            for (i = 0; i < 6; ++i)
                if (stbi__get8(z->s) != tag[i])
                    ok = 0;
            L -= 6;
            if (ok) {
                stbi__get8(z->s); // version
                stbi__get16be(z->s); // flags0
                stbi__get16be(z->s); // flags1
                z->app14_color_transform = stbi__get8(z->s); // color transform
                L -= 6;
            }
        }

        stbi__skip(z->s, L);
        return 1;
    }

    return stbi__err("unknown marker", "Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg* z)
{
    int i;
    int Ls = stbi__get16be(z->s);
    z->scan_n = stbi__get8(z->s);
    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");
    if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");
    for (i = 0; i < z->scan_n; ++i) {
        int id = stbi__get8(z->s), which;
        int q = stbi__get8(z->s);
        for (which = 0; which < z->s->img_n; ++which)
            if (z->img_comp[which].id == id)
                break;
        if (which == z->s->img_n) return 0; // no match
        z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");
        z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");
        z->order[i] = which;
    }

    {
        int aa;
        z->spec_start = stbi__get8(z->s);
        z->spec_end = stbi__get8(z->s); // should be 63, but might be 0
        aa = stbi__get8(z->s);
        z->succ_high = (aa >> 4);
        z->succ_low = (aa & 15);
        if (z->progressive) {
            if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
                return stbi__err("bad SOS", "Corrupt JPEG");
        }
        else {
            if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");
            if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");
            z->spec_end = 63;
        }
    }

    return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg* z, int ncomp, int why)
{
    int i;
    for (i = 0; i < ncomp; ++i) {
        if (z->img_comp[i].raw_data) {
            STBI_FREE(z->img_comp[i].raw_data);
            z->img_comp[i].raw_data = NULL;
            z->img_comp[i].data = NULL;
        }
        if (z->img_comp[i].raw_coeff) {
            STBI_FREE(z->img_comp[i].raw_coeff);
            z->img_comp[i].raw_coeff = 0;
            z->img_comp[i].coeff = 0;
        }
        if (z->img_comp[i].linebuf) {
            STBI_FREE(z->img_comp[i].linebuf);
            z->img_comp[i].linebuf = NULL;
        }
    }
    return why;
}

static int stbi__process_frame_header(stbi__jpeg* z, int scan)
{
    stbi__context* s = z->s;
    int Lf, p, i, q, h_max = 1, v_max = 1, c;
    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG
    p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline
    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires
    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");
    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");
    c = stbi__get8(s);
    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count", "Corrupt JPEG");
    s->img_n = c;
    for (i = 0; i < c; ++i) {
        z->img_comp[i].data = NULL;
        z->img_comp[i].linebuf = NULL;
    }

    if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

    z->rgb = 0;
    for (i = 0; i < s->img_n; ++i) {
        static const unsigned char rgb[3] = { 'R', 'G', 'B' };
        z->img_comp[i].id = stbi__get8(s);
        if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
            ++z->rgb;
        q = stbi__get8(s);
        z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");
        z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");
        z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");
    }

    if (scan != STBI__SCAN_load) return 1;

    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

    for (i = 0; i < s->img_n; ++i) {
        if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
        if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
    }

    // compute interleaved mcu info
    z->img_h_max = h_max;
    z->img_v_max = v_max;
    z->img_mcu_w = h_max * 8;
    z->img_mcu_h = v_max * 8;
    // these sizes can't be more than 17 bits
    z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;
    z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

    for (i = 0; i < s->img_n; ++i) {
        // number of effective pixels (e.g. for non-interleaved MCU)
        z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;
        z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;
        // to simplify generation, we'll allocate enough memory to decode
        // the bogus oversized data from using interleaved MCUs and their
        // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
        // discard the extra data until colorspace conversion
        //
        // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
        // so these muls can't overflow with 32-bit ints (which we require)
        z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
        z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
        z->img_comp[i].coeff = 0;
        z->img_comp[i].raw_coeff = 0;
        z->img_comp[i].linebuf = NULL;
        z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
        if (z->img_comp[i].raw_data == NULL)
            return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));
        // align blocks for idct using mmx/sse
        z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);
        if (z->progressive) {
            // w2, h2 are multiples of 8 (see above)
            z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
            z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
            z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
            if (z->img_comp[i].raw_coeff == NULL)
                return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem", "Out of memory"));
            z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);
        }
    }

    return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg* z, int scan)
{
    int m;
    z->jfif = 0;
    z->app14_color_transform = -1; // valid values are 0,1,2
    z->marker = STBI__MARKER_none; // initialize cached marker to empty
    m = stbi__get_marker(z);
    if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");
    if (scan == STBI__SCAN_type) return 1;
    m = stbi__get_marker(z);
    while (!stbi__SOF(m)) {
        if (!stbi__process_marker(z, m)) return 0;
        m = stbi__get_marker(z);
        while (m == STBI__MARKER_none) {
            // some files have extra padding after their blocks, so ok, we'll scan
            if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
            m = stbi__get_marker(z);
        }
    }
    z->progressive = stbi__SOF_progressive(m);
    if (!stbi__process_frame_header(z, scan)) return 0;
    return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg* j)
{
    int m;
    for (m = 0; m < 4; m++) {
        j->img_comp[m].raw_data = NULL;
        j->img_comp[m].raw_coeff = NULL;
    }
    j->restart_interval = 0;
    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
    m = stbi__get_marker(j);
    while (!stbi__EOI(m)) {
        if (stbi__SOS(m)) {
            if (!stbi__process_scan_header(j)) return 0;
            if (!stbi__parse_entropy_coded_data(j)) return 0;
            if (j->marker == STBI__MARKER_none) {
                // handle 0s at the end of image data from IP Kamera 9060
                while (!stbi__at_eof(j->s)) {
                    int x = stbi__get8(j->s);
                    if (x == 255) {
                        j->marker = stbi__get8(j->s);
                        break;
                    }
                }
                // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
            }
        }
        else if (stbi__DNL(m)) {
            int Ld = stbi__get16be(j->s);
            stbi__uint32 NL = stbi__get16be(j->s);
            if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
            if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
        }
        else {
            if (!stbi__process_marker(j, m)) return 0;
        }
        m = stbi__get_marker(j);
    }
    if (j->progressive)
        stbi__jpeg_finish(j);
    return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc* (*resample_row_func)(stbi_uc* out, stbi_uc* in0, stbi_uc* in1,
    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc* resample_row_1(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    STBI_NOTUSED(out);
    STBI_NOTUSED(in_far);
    STBI_NOTUSED(w);
    STBI_NOTUSED(hs);
    return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    // need to generate two samples vertically for every one in input
    int i;
    STBI_NOTUSED(hs);
    for (i = 0; i < w; ++i)
        out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);
    return out;
}

static stbi_uc* stbi__resample_row_h_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    // need to generate two samples horizontally for every one in input
    int i;
    stbi_uc* input = in_near;

    if (w == 1) {
        // if only one sample, can't do any interpolation
        out[0] = out[1] = input[0];
        return out;
    }

    out[0] = input[0];
    out[1] = stbi__div4(input[0] * 3 + input[1] + 2);
    for (i = 1; i < w - 1; ++i) {
        int n = 3 * input[i] + 2;
        out[i * 2 + 0] = stbi__div4(n + input[i - 1]);
        out[i * 2 + 1] = stbi__div4(n + input[i + 1]);
    }
    out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);
    out[i * 2 + 1] = input[w - 1];

    STBI_NOTUSED(in_far);
    STBI_NOTUSED(hs);

    return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc* stbi__resample_row_hv_2(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    // need to generate 2x2 samples for every one in input
    int i, t0, t1;
    if (w == 1) {
        out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
        return out;
    }

    t1 = 3 * in_near[0] + in_far[0];
    out[0] = stbi__div4(t1 + 2);
    for (i = 1; i < w; ++i) {
        t0 = t1;
        t1 = 3 * in_near[i] + in_far[i];
        out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
        out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
    }
    out[w * 2 - 1] = stbi__div4(t1 + 2);

    STBI_NOTUSED(hs);

    return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc* stbi__resample_row_hv_2_simd(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    // need to generate 2x2 samples for every one in input
    int i = 0, t0, t1;

    if (w == 1) {
        out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);
        return out;
    }

    t1 = 3 * in_near[0] + in_far[0];
    // process groups of 8 pixels for as long as we can.
    // note we can't handle the last pixel in a row in this loop
    // because we need to handle the filter boundary conditions.
    for (; i < ((w - 1) & ~7); i += 8) {
#if defined(STBI_SSE2)
        // load and perform the vertical filtering pass
        // this uses 3*x + y = 4*x + (y - x)
        __m128i zero = _mm_setzero_si128();
        __m128i farb = _mm_loadl_epi64((__m128i*) (in_far + i));
        __m128i nearb = _mm_loadl_epi64((__m128i*) (in_near + i));
        __m128i farw = _mm_unpacklo_epi8(farb, zero);
        __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
        __m128i diff = _mm_sub_epi16(farw, nearw);
        __m128i nears = _mm_slli_epi16(nearw, 2);
        __m128i curr = _mm_add_epi16(nears, diff); // current row

        // horizontal filter works the same based on shifted vers of current
        // row. "prev" is current row shifted right by 1 pixel; we need to
        // insert the previous pixel value (from t1).
        // "next" is current row shifted left by 1 pixel, with first pixel
        // of next block of 8 pixels added in.
        __m128i prv0 = _mm_slli_si128(curr, 2);
        __m128i nxt0 = _mm_srli_si128(curr, 2);
        __m128i prev = _mm_insert_epi16(prv0, t1, 0);
        __m128i next = _mm_insert_epi16(nxt0, 3 * in_near[i + 8] + in_far[i + 8], 7);

        // horizontal filter, polyphase implementation since it's convenient:
        // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        // note the shared term.
        __m128i bias = _mm_set1_epi16(8);
        __m128i curs = _mm_slli_epi16(curr, 2);
        __m128i prvd = _mm_sub_epi16(prev, curr);
        __m128i nxtd = _mm_sub_epi16(next, curr);
        __m128i curb = _mm_add_epi16(curs, bias);
        __m128i even = _mm_add_epi16(prvd, curb);
        __m128i odd = _mm_add_epi16(nxtd, curb);

        // interleave even and odd pixels, then undo scaling.
        __m128i int0 = _mm_unpacklo_epi16(even, odd);
        __m128i int1 = _mm_unpackhi_epi16(even, odd);
        __m128i de0 = _mm_srli_epi16(int0, 4);
        __m128i de1 = _mm_srli_epi16(int1, 4);

        // pack and write output
        __m128i outv = _mm_packus_epi16(de0, de1);
        _mm_storeu_si128((__m128i*) (out + i * 2), outv);
#elif defined(STBI_NEON)
        // load and perform the vertical filtering pass
        // this uses 3*x + y = 4*x + (y - x)
        uint8x8_t farb = vld1_u8(in_far + i);
        uint8x8_t nearb = vld1_u8(in_near + i);
        int16x8_t diff = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
        int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
        int16x8_t curr = vaddq_s16(nears, diff); // current row

        // horizontal filter works the same based on shifted vers of current
        // row. "prev" is current row shifted right by 1 pixel; we need to
        // insert the previous pixel value (from t1).
        // "next" is current row shifted left by 1 pixel, with first pixel
        // of next block of 8 pixels added in.
        int16x8_t prv0 = vextq_s16(curr, curr, 7);
        int16x8_t nxt0 = vextq_s16(curr, curr, 1);
        int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
        int16x8_t next = vsetq_lane_s16(3 * in_near[i + 8] + in_far[i + 8], nxt0, 7);

        // horizontal filter, polyphase implementation since it's convenient:
        // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        // note the shared term.
        int16x8_t curs = vshlq_n_s16(curr, 2);
        int16x8_t prvd = vsubq_s16(prev, curr);
        int16x8_t nxtd = vsubq_s16(next, curr);
        int16x8_t even = vaddq_s16(curs, prvd);
        int16x8_t odd = vaddq_s16(curs, nxtd);

        // undo scaling and round, then store with even/odd phases interleaved
        uint8x8x2_t o;
        o.val[0] = vqrshrun_n_s16(even, 4);
        o.val[1] = vqrshrun_n_s16(odd, 4);
        vst2_u8(out + i * 2, o);
#endif

        // "previous" value for next iter
        t1 = 3 * in_near[i + 7] + in_far[i + 7];
    }

    t0 = t1;
    t1 = 3 * in_near[i] + in_far[i];
    out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

    for (++i; i < w; ++i) {
        t0 = t1;
        t1 = 3 * in_near[i] + in_far[i];
        out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);
        out[i * 2] = stbi__div16(3 * t1 + t0 + 8);
    }
    out[w * 2 - 1] = stbi__div4(t1 + 2);

    STBI_NOTUSED(hs);

    return out;
}
#endif

static stbi_uc* stbi__resample_row_generic(stbi_uc* out, stbi_uc* in_near, stbi_uc* in_far, int w, int hs)
{
    // resample with nearest-neighbor
    int i, j;
    STBI_NOTUSED(in_far);
    for (i = 0; i < w; ++i)
        for (j = 0; j < hs; ++j)
            out[i * hs + j] = in_near[i];
    return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc* out, const stbi_uc* y, const stbi_uc* pcb, const stbi_uc* pcr, int count, int step)
{
    int i;
    for (i = 0; i < count; ++i) {
        int y_fixed = (y[i] << 20) + (1 << 19); // rounding
        int r, g, b;
        int cr = pcr[i] - 128;
        int cb = pcb[i] - 128;
        r = y_fixed + cr * stbi__float2fixed(1.40200f);
        g = y_fixed + (cr * -stbi__float2fixed(0.71414f)) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);
        b = y_fixed + cb * stbi__float2fixed(1.77200f);
        r >>= 20;
        g >>= 20;
        b >>= 20;
        if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
        if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
        if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
        out[0] = (stbi_uc)r;
        out[1] = (stbi_uc)g;
        out[2] = (stbi_uc)b;
        out[3] = 255;
        out += step;
    }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc* out, stbi_uc const* y, stbi_uc const* pcb, stbi_uc const* pcr, int count, int step)
{
    int i = 0;

#ifdef STBI_SSE2
    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
    // it's useful in practice (you wouldn't use it for textures, for example).
    // so just accelerate step == 4 case.
    if (step == 4) {
        // this is a fairly straightforward implementation and not super-optimized.
        __m128i signflip = _mm_set1_epi8(-0x80);
        __m128i cr_const0 = _mm_set1_epi16((short)(1.40200f * 4096.0f + 0.5f));
        __m128i cr_const1 = _mm_set1_epi16(-(short)(0.71414f * 4096.0f + 0.5f));
        __m128i cb_const0 = _mm_set1_epi16(-(short)(0.34414f * 4096.0f + 0.5f));
        __m128i cb_const1 = _mm_set1_epi16((short)(1.77200f * 4096.0f + 0.5f));
        __m128i y_bias = _mm_set1_epi8((char)(unsigned char)128);
        __m128i xw = _mm_set1_epi16(255); // alpha channel

        for (; i + 7 < count; i += 8) {
            // load
            __m128i y_bytes = _mm_loadl_epi64((__m128i*) (y + i));
            __m128i cr_bytes = _mm_loadl_epi64((__m128i*) (pcr + i));
            __m128i cb_bytes = _mm_loadl_epi64((__m128i*) (pcb + i));
            __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
            __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

            // unpack to short (and left-shift cr, cb by 8)
            __m128i yw = _mm_unpacklo_epi8(y_bias, y_bytes);
            __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
            __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

            // color transform
            __m128i yws = _mm_srli_epi16(yw, 4);
            __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
            __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
            __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
            __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
            __m128i rws = _mm_add_epi16(cr0, yws);
            __m128i gwt = _mm_add_epi16(cb0, yws);
            __m128i bws = _mm_add_epi16(yws, cb1);
            __m128i gws = _mm_add_epi16(gwt, cr1);

            // descale
            __m128i rw = _mm_srai_epi16(rws, 4);
            __m128i bw = _mm_srai_epi16(bws, 4);
            __m128i gw = _mm_srai_epi16(gws, 4);

            // back to byte, set up for transpose
            __m128i brb = _mm_packus_epi16(rw, bw);
            __m128i gxb = _mm_packus_epi16(gw, xw);

            // transpose to interleave channels
            __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
            __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
            __m128i o0 = _mm_unpacklo_epi16(t0, t1);
            __m128i o1 = _mm_unpackhi_epi16(t0, t1);

            // store
            _mm_storeu_si128((__m128i*) (out + 0), o0);
            _mm_storeu_si128((__m128i*) (out + 16), o1);
            out += 32;
        }
    }
#endif

#ifdef STBI_NEON
    // in this version, step=3 support would be easy to add. but is there demand?
    if (step == 4) {
        // this is a fairly straightforward implementation and not super-optimized.
        uint8x8_t signflip = vdup_n_u8(0x80);
        int16x8_t cr_const0 = vdupq_n_s16((short)(1.40200f * 4096.0f + 0.5f));
        int16x8_t cr_const1 = vdupq_n_s16(-(short)(0.71414f * 4096.0f + 0.5f));
        int16x8_t cb_const0 = vdupq_n_s16(-(short)(0.34414f * 4096.0f + 0.5f));
        int16x8_t cb_const1 = vdupq_n_s16((short)(1.77200f * 4096.0f + 0.5f));

        for (; i + 7 < count; i += 8) {
            // load
            uint8x8_t y_bytes = vld1_u8(y + i);
            uint8x8_t cr_bytes = vld1_u8(pcr + i);
            uint8x8_t cb_bytes = vld1_u8(pcb + i);
            int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
            int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

            // expand to s16
            int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
            int16x8_t crw = vshll_n_s8(cr_biased, 7);
            int16x8_t cbw = vshll_n_s8(cb_biased, 7);

            // color transform
            int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
            int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
            int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
            int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
            int16x8_t rws = vaddq_s16(yws, cr0);
            int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
            int16x8_t bws = vaddq_s16(yws, cb1);

            // undo scaling, round, convert to byte
            uint8x8x4_t o;
            o.val[0] = vqrshrun_n_s16(rws, 4);
            o.val[1] = vqrshrun_n_s16(gws, 4);
            o.val[2] = vqrshrun_n_s16(bws, 4);
            o.val[3] = vdup_n_u8(255);

            // store, interleaving r/g/b/a
            vst4_u8(out, o);
            out += 8 * 4;
        }
    }
#endif

    for (; i < count; ++i) {
        int y_fixed = (y[i] << 20) + (1 << 19); // rounding
        int r, g, b;
        int cr = pcr[i] - 128;
        int cb = pcb[i] - 128;
        r = y_fixed + cr * stbi__float2fixed(1.40200f);
        g = y_fixed + cr * -stbi__float2fixed(0.71414f) + ((cb * -stbi__float2fixed(0.34414f)) & 0xffff0000);
        b = y_fixed + cb * stbi__float2fixed(1.77200f);
        r >>= 20;
        g >>= 20;
        b >>= 20;
        if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }
        if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }
        if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }
        out[0] = (stbi_uc)r;
        out[1] = (stbi_uc)g;
        out[2] = (stbi_uc)b;
        out[3] = 255;
        out += step;
    }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg* j)
{
    j->idct_block_kernel = stbi__idct_block;
    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
    if (stbi__sse2_available()) {
        j->idct_block_kernel = stbi__idct_simd;
        j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
        j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
    }
#endif

#ifdef STBI_NEON
    j->idct_block_kernel = stbi__idct_simd;
    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg* j)
{
    stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
    resample_row_func resample;
    stbi_uc* line0, * line1;
    int hs, vs;   // expansion factor in each axis
    int w_lores; // horizontal pixels pre-expansion
    int ystep;   // how far through vertical expansion we are
    int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
    unsigned int t = x * y + 128;
    return (stbi_uc)((t + (t >> 8)) >> 8);
}

static stbi_uc* load_jpeg_image(stbi__jpeg* z, int* out_x, int* out_y, int* comp, int req_comp)
{
    int n, decode_n, is_rgb;
    z->s->img_n = 0; // make stbi__cleanup_jpeg safe

    // validate req_comp
    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

    // load a jpeg image from whichever source, but leave in YCbCr format
    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

    // determine actual number of components to generate
    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

    if (z->s->img_n == 3 && n < 3 && !is_rgb)
        decode_n = 1;
    else
        decode_n = z->s->img_n;

    // nothing to do if no components requested; check this now to avoid
    // accessing uninitialized coutput[0] later
    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

    // resample and color-convert
    {
        int k;
        unsigned int i, j;
        stbi_uc* output;
        stbi_uc* coutput[4] = { NULL, NULL, NULL, NULL };

        stbi__resample res_comp[4];

        for (k = 0; k < decode_n; ++k) {
            stbi__resample* r = &res_comp[k];

            // allocate line buffer big enough for upsampling off the edges
            // with upsample factor of 4
            z->img_comp[k].linebuf = (stbi_uc*)stbi__malloc(z->s->img_x + 3);
            if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

            r->hs = z->img_h_max / z->img_comp[k].h;
            r->vs = z->img_v_max / z->img_comp[k].v;
            r->ystep = r->vs >> 1;
            r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;
            r->ypos = 0;
            r->line0 = r->line1 = z->img_comp[k].data;

            if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
            else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
            else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
            else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
            else                               r->resample = stbi__resample_row_generic;
        }

        // can't error after this so, this is safe
        output = (stbi_uc*)stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
        if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

        // now go ahead and resample
        for (j = 0; j < z->s->img_y; ++j) {
            stbi_uc* out = output + n * z->s->img_x * j;
            for (k = 0; k < decode_n; ++k) {
                stbi__resample* r = &res_comp[k];
                int y_bot = r->ystep >= (r->vs >> 1);
                coutput[k] = r->resample(z->img_comp[k].linebuf,
                    y_bot ? r->line1 : r->line0,
                    y_bot ? r->line0 : r->line1,
                    r->w_lores, r->hs);
                if (++r->ystep >= r->vs) {
                    r->ystep = 0;
                    r->line0 = r->line1;
                    if (++r->ypos < z->img_comp[k].y)
                        r->line1 += z->img_comp[k].w2;
                }
            }
            if (n >= 3) {
                stbi_uc* y = coutput[0];
                if (z->s->img_n == 3) {
                    if (is_rgb) {
                        for (i = 0; i < z->s->img_x; ++i) {
                            out[0] = y[i];
                            out[1] = coutput[1][i];
                            out[2] = coutput[2][i];
                            out[3] = 255;
                            out += n;
                        }
                    }
                    else {
                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                    }
                }
                else if (z->s->img_n == 4) {
                    if (z->app14_color_transform == 0) { // CMYK
                        for (i = 0; i < z->s->img_x; ++i) {
                            stbi_uc m = coutput[3][i];
                            out[0] = stbi__blinn_8x8(coutput[0][i], m);
                            out[1] = stbi__blinn_8x8(coutput[1][i], m);
                            out[2] = stbi__blinn_8x8(coutput[2][i], m);
                            out[3] = 255;
                            out += n;
                        }
                    }
                    else if (z->app14_color_transform == 2) { // YCCK
                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                        for (i = 0; i < z->s->img_x; ++i) {
                            stbi_uc m = coutput[3][i];
                            out[0] = stbi__blinn_8x8(255 - out[0], m);
                            out[1] = stbi__blinn_8x8(255 - out[1], m);
                            out[2] = stbi__blinn_8x8(255 - out[2], m);
                            out += n;
                        }
                    }
                    else { // YCbCr + alpha?  Ignore the fourth channel for now
                        z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                    }
                }
                else
                    for (i = 0; i < z->s->img_x; ++i) {
                        out[0] = out[1] = out[2] = y[i];
                        out[3] = 255; // not used if n==3
                        out += n;
                    }
            }
            else {
                if (is_rgb) {
                    if (n == 1)
                        for (i = 0; i < z->s->img_x; ++i)
                            *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                    else {
                        for (i = 0; i < z->s->img_x; ++i, out += 2) {
                            out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                            out[1] = 255;
                        }
                    }
                }
                else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
                    for (i = 0; i < z->s->img_x; ++i) {
                        stbi_uc m = coutput[3][i];
                        stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                        stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                        stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                        out[0] = stbi__compute_y(r, g, b);
                        out[1] = 255;
                        out += n;
                    }
                }
                else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
                    for (i = 0; i < z->s->img_x; ++i) {
                        out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                        out[1] = 255;
                        out += n;
                    }
                }
                else {
                    stbi_uc* y = coutput[0];
                    if (n == 1)
                        for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];
                    else
                        for (i = 0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
                }
            }
        }
        stbi__cleanup_jpeg(z);
        *out_x = z->s->img_x;
        *out_y = z->s->img_y;
        if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
        return output;
    }
}

static void* stbi__jpeg_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    unsigned char* result;
    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
    if (!j) return stbi__errpuc("outofmem", "Out of memory");
    STBI_NOTUSED(ri);
    j->s = s;
    stbi__setup_jpeg(j);
    result = load_jpeg_image(j, x, y, comp, req_comp);
    STBI_FREE(j);
    return result;
}

static int stbi__jpeg_test(stbi__context* s)
{
    int r;
    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
    if (!j) return stbi__err("outofmem", "Out of memory");
    j->s = s;
    stbi__setup_jpeg(j);
    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
    stbi__rewind(s);
    STBI_FREE(j);
    return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg* j, int* x, int* y, int* comp)
{
    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
        stbi__rewind(j->s);
        return 0;
    }
    if (x) *x = j->s->img_x;
    if (y) *y = j->s->img_y;
    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
    return 1;
}

static int stbi__jpeg_info(stbi__context* s, int* x, int* y, int* comp)
{
    int result;
    stbi__jpeg* j = (stbi__jpeg*)(stbi__malloc(sizeof(stbi__jpeg)));
    if (!j) return stbi__err("outofmem", "Out of memory");
    j->s = s;
    result = stbi__jpeg_info_raw(j, x, y, comp);
    STBI_FREE(j);
    return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
    stbi__uint16 firstcode[16];
    int maxcode[17];
    stbi__uint16 firstsymbol[16];
    stbi_uc  size[STBI__ZNSYMS];
    stbi__uint16 value[STBI__ZNSYMS];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
    n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);
    n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);
    n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);
    n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);
    return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
    STBI_ASSERT(bits <= 16);
    // to bit reverse n bits, reverse 16 and shift
    // e.g. 11 bits, bit reverse and shift away 5
    return stbi__bitreverse16(v) >> (16 - bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman* z, const stbi_uc* sizelist, int num)
{
    int i, k = 0;
    int code, next_code[16], sizes[17];

    // DEFLATE spec for generating codes
    memset(sizes, 0, sizeof(sizes));
    memset(z->fast, 0, sizeof(z->fast));
    for (i = 0; i < num; ++i)
        ++sizes[sizelist[i]];
    sizes[0] = 0;
    for (i = 1; i < 16; ++i)
        if (sizes[i] > (1 << i))
            return stbi__err("bad sizes", "Corrupt PNG");
    code = 0;
    for (i = 1; i < 16; ++i) {
        next_code[i] = code;
        z->firstcode[i] = (stbi__uint16)code;
        z->firstsymbol[i] = (stbi__uint16)k;
        code = (code + sizes[i]);
        if (sizes[i])
            if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");
        z->maxcode[i] = code << (16 - i); // preshift for inner loop
        code <<= 1;
        k += sizes[i];
    }
    z->maxcode[16] = 0x10000; // sentinel
    for (i = 0; i < num; ++i) {
        int s = sizelist[i];
        if (s) {
            int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
            stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);
            z->size[c] = (stbi_uc)s;
            z->value[c] = (stbi__uint16)i;
            if (s <= STBI__ZFAST_BITS) {
                int j = stbi__bit_reverse(next_code[s], s);
                while (j < (1 << STBI__ZFAST_BITS)) {
                    z->fast[j] = fastv;
                    j += (1 << s);
                }
            }
            ++next_code[s];
        }
    }
    return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
    stbi_uc* zbuffer, * zbuffer_end;
    int num_bits;
    stbi__uint32 code_buffer;

    char* zout;
    char* zout_start;
    char* zout_end;
    int   z_expandable;

    stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static int stbi__zeof(stbi__zbuf* z)
{
    return (z->zbuffer >= z->zbuffer_end);
}

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf* z)
{
    return stbi__zeof(z) ? 0 : *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf* z)
{
    do {
        if (z->code_buffer >= (1U << z->num_bits)) {
            z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
            return;
        }
        z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;
        z->num_bits += 8;
    } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf* z, int n)
{
    unsigned int k;
    if (z->num_bits < n) stbi__fill_bits(z);
    k = z->code_buffer & ((1 << n) - 1);
    z->code_buffer >>= n;
    z->num_bits -= n;
    return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf* a, stbi__zhuffman* z)
{
    int b, s, k;
    // not resolved by fast table, so compute it the slow way
    // use jpeg approach, which requires MSbits at top
    k = stbi__bit_reverse(a->code_buffer, 16);
    for (s = STBI__ZFAST_BITS + 1; ; ++s)
        if (k < z->maxcode[s])
            break;
    if (s >= 16) return -1; // invalid code!
    // code size is s, so:
    b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];
    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
    a->code_buffer >>= s;
    a->num_bits -= s;
    return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf* a, stbi__zhuffman* z)
{
    int b, s;
    if (a->num_bits < 16) {
        if (stbi__zeof(a)) {
            return -1;   /* report error for unexpected end of data. */
        }
        stbi__fill_bits(a);
    }
    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
    if (b) {
        s = b >> 9;
        a->code_buffer >>= s;
        a->num_bits -= s;
        return b & 511;
    }
    return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf* z, char* zout, int n)  // need to make room for n bytes
{
    char* q;
    unsigned int cur, limit, old_limit;
    z->zout = zout;
    if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");
    cur = (unsigned int)(z->zout - z->zout_start);
    limit = old_limit = (unsigned)(z->zout_end - z->zout_start);
    if (UINT_MAX - cur < (unsigned)n) return stbi__err("outofmem", "Out of memory");
    while (cur + n > limit) {
        if (limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
        limit *= 2;
    }
    q = (char*)STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
    STBI_NOTUSED(old_limit);
    if (q == NULL) return stbi__err("outofmem", "Out of memory");
    z->zout_start = q;
    z->zout = q + cur;
    z->zout_end = q + limit;
    return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31] =
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0 };

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };

static int stbi__parse_huffman_block(stbi__zbuf* a)
{
    char* zout = a->zout;
    for (;;) {
        int z = stbi__zhuffman_decode(a, &a->z_length);
        if (z < 256) {
            if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes
            if (zout >= a->zout_end) {
                if (!stbi__zexpand(a, zout, 1)) return 0;
                zout = a->zout;
            }
            *zout++ = (char)z;
        }
        else {
            stbi_uc* p;
            int len, dist;
            if (z == 256) {
                a->zout = zout;
                return 1;
            }
            z -= 257;
            len = stbi__zlength_base[z];
            if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
            z = stbi__zhuffman_decode(a, &a->z_distance);
            if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG");
            dist = stbi__zdist_base[z];
            if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
            if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");
            if (zout + len > a->zout_end) {
                if (!stbi__zexpand(a, zout, len)) return 0;
                zout = a->zout;
            }
            p = (stbi_uc*)(zout - dist);
            if (dist == 1) { // run of one byte; common in images.
                stbi_uc v = *p;
                if (len) { do *zout++ = v; while (--len); }
            }
            else {
                if (len) { do *zout++ = *p++; while (--len); }
            }
        }
    }
}

static int stbi__compute_huffman_codes(stbi__zbuf* a)
{
    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
    stbi__zhuffman z_codelength;
    stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
    stbi_uc codelength_sizes[19];
    int i, n;

    int hlit = stbi__zreceive(a, 5) + 257;
    int hdist = stbi__zreceive(a, 5) + 1;
    int hclen = stbi__zreceive(a, 4) + 4;
    int ntot = hlit + hdist;

    memset(codelength_sizes, 0, sizeof(codelength_sizes));
    for (i = 0; i < hclen; ++i) {
        int s = stbi__zreceive(a, 3);
        codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;
    }
    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

    n = 0;
    while (n < ntot) {
        int c = stbi__zhuffman_decode(a, &z_codelength);
        if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
        if (c < 16)
            lencodes[n++] = (stbi_uc)c;
        else {
            stbi_uc fill = 0;
            if (c == 16) {
                c = stbi__zreceive(a, 2) + 3;
                if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
                fill = lencodes[n - 1];
            }
            else if (c == 17) {
                c = stbi__zreceive(a, 3) + 3;
            }
            else if (c == 18) {
                c = stbi__zreceive(a, 7) + 11;
            }
            else {
                return stbi__err("bad codelengths", "Corrupt PNG");
            }
            if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
            memset(lencodes + n, fill, c);
            n += c;
        }
    }
    if (n != ntot) return stbi__err("bad codelengths", "Corrupt PNG");
    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
    if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;
    return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf* a)
{
    stbi_uc header[4];
    int len, nlen, k;
    if (a->num_bits & 7)
        stbi__zreceive(a, a->num_bits & 7); // discard
     // drain the bit-packed data into header
    k = 0;
    while (a->num_bits > 0) {
        header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check
        a->code_buffer >>= 8;
        a->num_bits -= 8;
    }
    if (a->num_bits < 0) return stbi__err("zlib corrupt", "Corrupt PNG");
    // now fill header the normal way
    while (k < 4)
        header[k++] = stbi__zget8(a);
    len = header[1] * 256 + header[0];
    nlen = header[3] * 256 + header[2];
    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");
    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");
    if (a->zout + len > a->zout_end)
        if (!stbi__zexpand(a, a->zout, len)) return 0;
    memcpy(a->zout, a->zbuffer, len);
    a->zbuffer += len;
    a->zout += len;
    return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf* a)
{
    int cmf = stbi__zget8(a);
    int cm = cmf & 15;
    /* int cinfo = cmf >> 4; */
    int flg = stbi__zget8(a);
    if (stbi__zeof(a)) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec
    if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec
    if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png
    if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png
    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
    return 1;
}

static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf* a, int parse_header)
{
    int final, type;
    if (parse_header)
        if (!stbi__parse_zlib_header(a)) return 0;
    a->num_bits = 0;
    a->code_buffer = 0;
    do {
        final = stbi__zreceive(a, 1);
        type = stbi__zreceive(a, 2);
        if (type == 0) {
            if (!stbi__parse_uncompressed_block(a)) return 0;
        }
        else if (type == 3) {
            return 0;
        }
        else {
            if (type == 1) {
                // use fixed code lengths
                if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, STBI__ZNSYMS)) return 0;
                if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;
            }
            else {
                if (!stbi__compute_huffman_codes(a)) return 0;
            }
            if (!stbi__parse_huffman_block(a)) return 0;
        }
    } while (!final);
    return 1;
}

static int stbi__do_zlib(stbi__zbuf* a, char* obuf, int olen, int exp, int parse_header)
{
    a->zout_start = obuf;
    a->zout = obuf;
    a->zout_end = obuf + olen;
    a->z_expandable = exp;

    return stbi__parse_zlib(a, parse_header);
}

STBIDEF char* stbi_zlib_decode_malloc_guesssize(const char* buffer, int len, int initial_size, int* outlen)
{
    stbi__zbuf a;
    char* p = (char*)stbi__malloc(initial_size);
    if (p == NULL) return NULL;
    a.zbuffer = (stbi_uc*)buffer;
    a.zbuffer_end = (stbi_uc*)buffer + len;
    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
        if (outlen) *outlen = (int)(a.zout - a.zout_start);
        return a.zout_start;
    }
    else {
        STBI_FREE(a.zout_start);
        return NULL;
    }
}

STBIDEF char* stbi_zlib_decode_malloc(char const* buffer, int len, int* outlen)
{
    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char* stbi_zlib_decode_malloc_guesssize_headerflag(const char* buffer, int len, int initial_size, int* outlen, int parse_header)
{
    stbi__zbuf a;
    char* p = (char*)stbi__malloc(initial_size);
    if (p == NULL) return NULL;
    a.zbuffer = (stbi_uc*)buffer;
    a.zbuffer_end = (stbi_uc*)buffer + len;
    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
        if (outlen) *outlen = (int)(a.zout - a.zout_start);
        return a.zout_start;
    }
    else {
        STBI_FREE(a.zout_start);
        return NULL;
    }
}

STBIDEF int stbi_zlib_decode_buffer(char* obuffer, int olen, char const* ibuffer, int ilen)
{
    stbi__zbuf a;
    a.zbuffer = (stbi_uc*)ibuffer;
    a.zbuffer_end = (stbi_uc*)ibuffer + ilen;
    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
        return (int)(a.zout - a.zout_start);
    else
        return -1;
}

STBIDEF char* stbi_zlib_decode_noheader_malloc(char const* buffer, int len, int* outlen)
{
    stbi__zbuf a;
    char* p = (char*)stbi__malloc(16384);
    if (p == NULL) return NULL;
    a.zbuffer = (stbi_uc*)buffer;
    a.zbuffer_end = (stbi_uc*)buffer + len;
    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
        if (outlen) *outlen = (int)(a.zout - a.zout_start);
        return a.zout_start;
    }
    else {
        STBI_FREE(a.zout_start);
        return NULL;
    }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char* obuffer, int olen, const char* ibuffer, int ilen)
{
    stbi__zbuf a;
    a.zbuffer = (stbi_uc*)ibuffer;
    a.zbuffer_end = (stbi_uc*)ibuffer + ilen;
    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
        return (int)(a.zout - a.zout_start);
    else
        return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
    stbi__uint32 length;
    stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context* s)
{
    stbi__pngchunk c;
    c.length = stbi__get32be(s);
    c.type = stbi__get32be(s);
    return c;
}

static int stbi__check_png_header(stbi__context* s)
{
    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
    int i;
    for (i = 0; i < 8; ++i)
        if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");
    return 1;
}

typedef struct
{
    stbi__context* s;
    stbi_uc* idata, * expanded, * out;
    int depth;
} stbi__png;


enum {
    STBI__F_none = 0,
    STBI__F_sub = 1,
    STBI__F_up = 2,
    STBI__F_avg = 3,
    STBI__F_paeth = 4,
    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
    STBI__F_avg_first,
    STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);
    if (pa <= pb && pa <= pc) return a;
    if (pb <= pc) return b;
    return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png* a, stbi_uc* raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
    int bytes = (depth == 16 ? 2 : 1);
    stbi__context* s = a->s;
    stbi__uint32 i, j, stride = x * out_n * bytes;
    stbi__uint32 img_len, img_width_bytes;
    int k;
    int img_n = s->img_n; // copy it into a local for later

    int output_bytes = out_n * bytes;
    int filter_bytes = img_n * bytes;
    int width = x;

    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);
    a->out = (stbi_uc*)stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
    if (!a->out) return stbi__err("outofmem", "Out of memory");

    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
    img_width_bytes = (((img_n * x * depth) + 7) >> 3);
    img_len = (img_width_bytes + 1) * y;

    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
    // so just check for raw_len < img_len always.
    if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");

    for (j = 0; j < y; ++j) {
        stbi_uc* cur = a->out + stride * j;
        stbi_uc* prior;
        int filter = *raw++;

        if (filter > 4)
            return stbi__err("invalid filter", "Corrupt PNG");

        if (depth < 8) {
            if (img_width_bytes > x) return stbi__err("invalid width", "Corrupt PNG");
            cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
            filter_bytes = 1;
            width = img_width_bytes;
        }
        prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

        // if first row, use special filter that doesn't sample previous row
        if (j == 0) filter = first_row_filter[filter];

        // handle first byte explicitly
        for (k = 0; k < filter_bytes; ++k) {
            switch (filter) {
            case STBI__F_none: cur[k] = raw[k]; break;
            case STBI__F_sub: cur[k] = raw[k]; break;
            case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;
            case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;
            case STBI__F_avg_first: cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
            }
        }

        if (depth == 8) {
            if (img_n != out_n)
                cur[img_n] = 255; // first pixel
            raw += img_n;
            cur += out_n;
            prior += out_n;
        }
        else if (depth == 16) {
            if (img_n != out_n) {
                cur[filter_bytes] = 255; // first pixel top byte
                cur[filter_bytes + 1] = 255; // first pixel bottom byte
            }
            raw += filter_bytes;
            cur += output_bytes;
            prior += output_bytes;
        }
        else {
            raw += 1;
            cur += 1;
            prior += 1;
        }

        // this is a little gross, so that we don't switch per-pixel or per-component
        if (depth < 8 || img_n == out_n) {
            int nk = (width - 1) * filter_bytes;
#define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
            switch (filter) {
                // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
                STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); } break;
                STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
                STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); } break;
                STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); } break;
                STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); } break;
                STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); } break;
            }
#undef STBI__CASE
            raw += nk;
        }
        else {
            STBI_ASSERT(img_n + 1 == out_n);
#define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
            switch (filter) {
                STBI__CASE(STBI__F_none) { cur[k] = raw[k]; } break;
                STBI__CASE(STBI__F_sub) { cur[k] = STBI__BYTECAST(raw[k] + cur[k - output_bytes]); } break;
                STBI__CASE(STBI__F_up) { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
                STBI__CASE(STBI__F_avg) { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)); } break;
                STBI__CASE(STBI__F_paeth) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes])); } break;
                STBI__CASE(STBI__F_avg_first) { cur[k] = STBI__BYTECAST(raw[k] + (cur[k - output_bytes] >> 1)); } break;
                STBI__CASE(STBI__F_paeth_first) { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0)); } break;
            }
#undef STBI__CASE

            // the loop above sets the high byte of the pixels' alpha, but for
            // 16 bit png files we also need the low byte set. we'll do that here.
            if (depth == 16) {
                cur = a->out + stride * j; // start at the beginning of the row again
                for (i = 0; i < x; ++i, cur += output_bytes) {
                    cur[filter_bytes + 1] = 255;
                }
            }
        }
    }

    // we make a separate pass to expand bits to pixels; for performance,
    // this could run two scanlines behind the above code, so it won't
    // intefere with filtering but will still be in the cache.
    if (depth < 8) {
        for (j = 0; j < y; ++j) {
            stbi_uc* cur = a->out + stride * j;
            stbi_uc* in = a->out + stride * j + x * out_n - img_width_bytes;
            // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
            // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
            stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

            // note that the final byte might overshoot and write more data than desired.
            // we can allocate enough data that this never writes out of memory, but it
            // could also overwrite the next scanline. can it overwrite non-empty data
            // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
            // so we need to explicitly clamp the final ones

            if (depth == 4) {
                for (k = x * img_n; k >= 2; k -= 2, ++in) {
                    *cur++ = scale * ((*in >> 4));
                    *cur++ = scale * ((*in) & 0x0f);
                }
                if (k > 0) *cur++ = scale * ((*in >> 4));
            }
            else if (depth == 2) {
                for (k = x * img_n; k >= 4; k -= 4, ++in) {
                    *cur++ = scale * ((*in >> 6));
                    *cur++ = scale * ((*in >> 4) & 0x03);
                    *cur++ = scale * ((*in >> 2) & 0x03);
                    *cur++ = scale * ((*in) & 0x03);
                }
                if (k > 0) *cur++ = scale * ((*in >> 6));
                if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
                if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
            }
            else if (depth == 1) {
                for (k = x * img_n; k >= 8; k -= 8, ++in) {
                    *cur++ = scale * ((*in >> 7));
                    *cur++ = scale * ((*in >> 6) & 0x01);
                    *cur++ = scale * ((*in >> 5) & 0x01);
                    *cur++ = scale * ((*in >> 4) & 0x01);
                    *cur++ = scale * ((*in >> 3) & 0x01);
                    *cur++ = scale * ((*in >> 2) & 0x01);
                    *cur++ = scale * ((*in >> 1) & 0x01);
                    *cur++ = scale * ((*in) & 0x01);
                }
                if (k > 0) *cur++ = scale * ((*in >> 7));
                if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
                if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
                if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
                if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
                if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
                if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
            }
            if (img_n != out_n) {
                int q;
                // insert alpha = 255
                cur = a->out + stride * j;
                if (img_n == 1) {
                    for (q = x - 1; q >= 0; --q) {
                        cur[q * 2 + 1] = 255;
                        cur[q * 2 + 0] = cur[q];
                    }
                }
                else {
                    STBI_ASSERT(img_n == 3);
                    for (q = x - 1; q >= 0; --q) {
                        cur[q * 4 + 3] = 255;
                        cur[q * 4 + 2] = cur[q * 3 + 2];
                        cur[q * 4 + 1] = cur[q * 3 + 1];
                        cur[q * 4 + 0] = cur[q * 3 + 0];
                    }
                }
            }
        }
    }
    else if (depth == 16) {
        // force the image data from big-endian to platform-native.
        // this is done in a separate pass due to the decoding relying
        // on the data being untouched, but could probably be done
        // per-line during decode if care is taken.
        stbi_uc* cur = a->out;
        stbi__uint16* cur16 = (stbi__uint16*)cur;

        for (i = 0; i < x * y * out_n; ++i, cur16++, cur += 2) {
            *cur16 = (cur[0] << 8) | cur[1];
        }
    }

    return 1;
}

static int stbi__create_png_image(stbi__png* a, stbi_uc* image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
    int bytes = (depth == 16 ? 2 : 1);
    int out_bytes = out_n * bytes;
    stbi_uc* final;
    int p;
    if (!interlaced)
        return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

    // de-interlacing
    final = (stbi_uc*)stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
    if (!final) return stbi__err("outofmem", "Out of memory");
    for (p = 0; p < 7; ++p) {
        int xorig[] = { 0,4,0,2,0,1,0 };
        int yorig[] = { 0,0,4,0,2,0,1 };
        int xspc[] = { 8,8,4,4,2,2,1 };
        int yspc[] = { 8,8,8,4,4,2,2 };
        int i, j, x, y;
        // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
        x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];
        y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];
        if (x && y) {
            stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
            if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
                STBI_FREE(final);
                return 0;
            }
            for (j = 0; j < y; ++j) {
                for (i = 0; i < x; ++i) {
                    int out_y = j * yspc[p] + yorig[p];
                    int out_x = i * xspc[p] + xorig[p];
                    memcpy(final + out_y * a->s->img_x * out_bytes + out_x * out_bytes,
                        a->out + (j * x + i) * out_bytes, out_bytes);
                }
            }
            STBI_FREE(a->out);
            image_data += img_len;
            image_data_len -= img_len;
        }
    }
    a->out = final;

    return 1;
}

static int stbi__compute_transparency(stbi__png* z, stbi_uc tc[3], int out_n)
{
    stbi__context* s = z->s;
    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    stbi_uc* p = z->out;

    // compute color-based transparency, assuming we've
    // already got 255 as the alpha value in the output
    STBI_ASSERT(out_n == 2 || out_n == 4);

    if (out_n == 2) {
        for (i = 0; i < pixel_count; ++i) {
            p[1] = (p[0] == tc[0] ? 0 : 255);
            p += 2;
        }
    }
    else {
        for (i = 0; i < pixel_count; ++i) {
            if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
                p[3] = 0;
            p += 4;
        }
    }
    return 1;
}

static int stbi__compute_transparency16(stbi__png* z, stbi__uint16 tc[3], int out_n)
{
    stbi__context* s = z->s;
    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    stbi__uint16* p = (stbi__uint16*)z->out;

    // compute color-based transparency, assuming we've
    // already got 65535 as the alpha value in the output
    STBI_ASSERT(out_n == 2 || out_n == 4);

    if (out_n == 2) {
        for (i = 0; i < pixel_count; ++i) {
            p[1] = (p[0] == tc[0] ? 0 : 65535);
            p += 2;
        }
    }
    else {
        for (i = 0; i < pixel_count; ++i) {
            if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
                p[3] = 0;
            p += 4;
        }
    }
    return 1;
}

static int stbi__expand_png_palette(stbi__png* a, stbi_uc* palette, int len, int pal_img_n)
{
    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
    stbi_uc* p, * temp_out, * orig = a->out;

    p = (stbi_uc*)stbi__malloc_mad2(pixel_count, pal_img_n, 0);
    if (p == NULL) return stbi__err("outofmem", "Out of memory");

    // between here and free(out) below, exitting would leak
    temp_out = p;

    if (pal_img_n == 3) {
        for (i = 0; i < pixel_count; ++i) {
            int n = orig[i] * 4;
            p[0] = palette[n];
            p[1] = palette[n + 1];
            p[2] = palette[n + 2];
            p += 3;
        }
    }
    else {
        for (i = 0; i < pixel_count; ++i) {
            int n = orig[i] * 4;
            p[0] = palette[n];
            p[1] = palette[n + 1];
            p[2] = palette[n + 2];
            p[3] = palette[n + 3];
            p += 4;
        }
    }
    STBI_FREE(a->out);
    a->out = temp_out;

    STBI_NOTUSED(len);

    return 1;
}

static int stbi__unpremultiply_on_load_global = 0;
static int stbi__de_iphone_flag_global = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
    stbi__de_iphone_flag_global = flag_true_if_should_convert;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
#else
static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;

STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
    stbi__unpremultiply_on_load_set = 1;
}

STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
    stbi__de_iphone_flag_local = flag_true_if_should_convert;
    stbi__de_iphone_flag_set = 1;
}

#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
                                       ? stbi__unpremultiply_on_load_local      \
                                       : stbi__unpremultiply_on_load_global)
#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
                                ? stbi__de_iphone_flag_local                    \
                                : stbi__de_iphone_flag_global)
#endif // STBI_THREAD_LOCAL

static void stbi__de_iphone(stbi__png* z)
{
    stbi__context* s = z->s;
    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    stbi_uc* p = z->out;

    if (s->img_out_n == 3) {  // convert bgr to rgb
        for (i = 0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 3;
        }
    }
    else {
        STBI_ASSERT(s->img_out_n == 4);
        if (stbi__unpremultiply_on_load) {
            // convert bgr to rgb and unpremultiply
            for (i = 0; i < pixel_count; ++i) {
                stbi_uc a = p[3];
                stbi_uc t = p[0];
                if (a) {
                    stbi_uc half = a / 2;
                    p[0] = (p[2] * 255 + half) / a;
                    p[1] = (p[1] * 255 + half) / a;
                    p[2] = (t * 255 + half) / a;
                }
                else {
                    p[0] = p[2];
                    p[2] = t;
                }
                p += 4;
            }
        }
        else {
            // convert bgr to rgb
            for (i = 0; i < pixel_count; ++i) {
                stbi_uc t = p[0];
                p[0] = p[2];
                p[2] = t;
                p += 4;
            }
        }
    }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png* z, int scan, int req_comp)
{
    stbi_uc palette[1024], pal_img_n = 0;
    stbi_uc has_trans = 0, tc[3] = { 0 };
    stbi__uint16 tc16[3];
    stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;
    int first = 1, k, interlace = 0, color = 0, is_iphone = 0;
    stbi__context* s = z->s;

    z->expanded = NULL;
    z->idata = NULL;
    z->out = NULL;

    if (!stbi__check_png_header(s)) return 0;

    if (scan == STBI__SCAN_type) return 1;

    for (;;) {
        stbi__pngchunk c = stbi__get_chunk_header(s);
        switch (c.type) {
        case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
        case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
            int comp, filter;
            if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only", "PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype", "Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");
            comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");
            filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");
            interlace = stbi__get8(s); if (interlace > 1) return stbi__err("bad interlace method", "Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");
            if (!pal_img_n) {
                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
                if (scan == STBI__SCAN_header) return 1;
            }
            else {
                // if paletted, then pal_n is our final components, and
                // img_n is # components to decompress/filter.
                s->img_n = 1;
                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");
                // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
        }

        case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");
            for (i = 0; i < pal_len; ++i) {
                palette[i * 4 + 0] = stbi__get8(s);
                palette[i * 4 + 1] = stbi__get8(s);
                palette[i * 4 + 2] = stbi__get8(s);
                palette[i * 4 + 3] = 255;
            }
            break;
        }

        case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");
            if (pal_img_n) {
                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
                if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");
                if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");
                pal_img_n = 4;
                for (i = 0; i < c.length; ++i)
                    palette[i * 4 + 3] = stbi__get8(s);
            }
            else {
                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");
                if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");
                has_trans = 1;
                if (z->depth == 16) {
                    for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
                }
                else {
                    for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
                }
            }
            break;
        }

        case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
                stbi__uint32 idata_limit_old = idata_limit;
                stbi_uc* p;
                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
                while (ioff + c.length > idata_limit)
                    idata_limit *= 2;
                STBI_NOTUSED(idata_limit_old);
                p = (stbi_uc*)STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
                z->idata = p;
            }
            if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");
            ioff += c.length;
            break;
        }

        case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc*)stbi_zlib_decode_malloc_guesssize_headerflag((char*)z->idata, ioff, raw_len, (int*)&raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)
                s->img_out_n = s->img_n + 1;
            else
                s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
                if (z->depth == 16) {
                    if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
                }
                else {
                    if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
                }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
                stbi__de_iphone(z);
            if (pal_img_n) {
                // pal_img_n == 3 or 4
                s->img_n = pal_img_n; // record the actual colors we had
                s->img_out_n = pal_img_n;
                if (req_comp >= 3) s->img_out_n = req_comp;
                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                    return 0;
            }
            else if (has_trans) {
                // non-paletted image with tRNS -> source image has (constant) alpha
                ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
        }

        default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
#ifndef STBI_NO_FAILURE_STRINGS
                // not threadsafe
                static char invalid_chunk[] = "XXXX PNG chunk not known";
                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
                invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);
                invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);
#endif
                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
        }
        // end of PNG chunk, read and skip CRC
        stbi__get32be(s);
    }
}

static void* stbi__do_png(stbi__png* p, int* x, int* y, int* n, int req_comp, stbi__result_info* ri)
{
    void* result = NULL;
    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
        if (p->depth <= 8)
            ri->bits_per_channel = 8;
        else if (p->depth == 16)
            ri->bits_per_channel = 16;
        else
            return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
        result = p->out;
        p->out = NULL;
        if (req_comp && req_comp != p->s->img_out_n) {
            if (ri->bits_per_channel == 8)
                result = stbi__convert_format((unsigned char*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
            else
                result = stbi__convert_format16((stbi__uint16*)result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
            p->s->img_out_n = req_comp;
            if (result == NULL) return result;
        }
        *x = p->s->img_x;
        *y = p->s->img_y;
        if (n) *n = p->s->img_n;
    }
    STBI_FREE(p->out);      p->out = NULL;
    STBI_FREE(p->expanded); p->expanded = NULL;
    STBI_FREE(p->idata);    p->idata = NULL;

    return result;
}

static void* stbi__png_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    stbi__png p;
    p.s = s;
    return stbi__do_png(&p, x, y, comp, req_comp, ri);
}

static int stbi__png_test(stbi__context* s)
{
    int r;
    r = stbi__check_png_header(s);
    stbi__rewind(s);
    return r;
}

static int stbi__png_info_raw(stbi__png* p, int* x, int* y, int* comp)
{
    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
        stbi__rewind(p->s);
        return 0;
    }
    if (x) *x = p->s->img_x;
    if (y) *y = p->s->img_y;
    if (comp) *comp = p->s->img_n;
    return 1;
}

static int stbi__png_info(stbi__context* s, int* x, int* y, int* comp)
{
    stbi__png p;
    p.s = s;
    return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context* s)
{
    stbi__png p;
    p.s = s;
    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
        return 0;
    if (p.depth != 16) {
        stbi__rewind(p.s);
        return 0;
    }
    return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context* s)
{
    int r;
    int sz;
    if (stbi__get8(s) != 'B') return 0;
    if (stbi__get8(s) != 'M') return 0;
    stbi__get32le(s); // discard filesize
    stbi__get16le(s); // discard reserved
    stbi__get16le(s); // discard reserved
    stbi__get32le(s); // discard data offset
    sz = stbi__get32le(s);
    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
    return r;
}

static int stbi__bmp_test(stbi__context* s)
{
    int r = stbi__bmp_test_raw(s);
    stbi__rewind(s);
    return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
    int n = 0;
    if (z == 0) return -1;
    if (z >= 0x10000) { n += 16; z >>= 16; }
    if (z >= 0x00100) { n += 8; z >>= 8; }
    if (z >= 0x00010) { n += 4; z >>= 4; }
    if (z >= 0x00004) { n += 2; z >>= 2; }
    if (z >= 0x00002) { n += 1;/* >>=  1;*/ }
    return n;
}

static int stbi__bitcount(unsigned int a)
{
    a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2
    a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4
    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
    a = (a + (a >> 8)); // max 16 per 8 bits
    a = (a + (a >> 16)); // max 32 per 8 bits
    return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
    static unsigned int mul_table[9] = {
       0,
       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
    };
    static unsigned int shift_table[9] = {
       0, 0,0,1,0,2,4,6,0,
    };
    if (shift < 0)
        v <<= -shift;
    else
        v >>= shift;
    STBI_ASSERT(v < 256);
    v >>= (8 - bits);
    STBI_ASSERT(bits >= 0 && bits <= 8);
    return (int)((unsigned)v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
    int bpp, offset, hsz;
    unsigned int mr, mg, mb, ma, all_a;
    int extra_read;
} stbi__bmp_data;

static int stbi__bmp_set_mask_defaults(stbi__bmp_data* info, int compress)
{
    // BI_BITFIELDS specifies masks explicitly, don't override
    if (compress == 3)
        return 1;

    if (compress == 0) {
        if (info->bpp == 16) {
            info->mr = 31u << 10;
            info->mg = 31u << 5;
            info->mb = 31u << 0;
        }
        else if (info->bpp == 32) {
            info->mr = 0xffu << 16;
            info->mg = 0xffu << 8;
            info->mb = 0xffu << 0;
            info->ma = 0xffu << 24;
            info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
        }
        else {
            // otherwise, use defaults, which is all-0
            info->mr = info->mg = info->mb = info->ma = 0;
        }
        return 1;
    }
    return 0; // error
}

static void* stbi__bmp_parse_header(stbi__context* s, stbi__bmp_data* info)
{
    int hsz;
    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
    stbi__get32le(s); // discard filesize
    stbi__get16le(s); // discard reserved
    stbi__get16le(s); // discard reserved
    info->offset = stbi__get32le(s);
    info->hsz = hsz = stbi__get32le(s);
    info->mr = info->mg = info->mb = info->ma = 0;
    info->extra_read = 14;

    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
    if (hsz == 12) {
        s->img_x = stbi__get16le(s);
        s->img_y = stbi__get16le(s);
    }
    else {
        s->img_x = stbi__get32le(s);
        s->img_y = stbi__get32le(s);
    }
    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
    info->bpp = stbi__get16le(s);
    if (hsz != 12) {
        int compress = stbi__get32le(s);
        if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
        if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
        if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
        stbi__get32le(s); // discard sizeof
        stbi__get32le(s); // discard hres
        stbi__get32le(s); // discard vres
        stbi__get32le(s); // discard colorsused
        stbi__get32le(s); // discard max important
        if (hsz == 40 || hsz == 56) {
            if (hsz == 56) {
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
            }
            if (info->bpp == 16 || info->bpp == 32) {
                if (compress == 0) {
                    stbi__bmp_set_mask_defaults(info, compress);
                }
                else if (compress == 3) {
                    info->mr = stbi__get32le(s);
                    info->mg = stbi__get32le(s);
                    info->mb = stbi__get32le(s);
                    info->extra_read += 12;
                    // not documented, but generated by photoshop and handled by mspaint
                    if (info->mr == info->mg && info->mg == info->mb) {
                        // ?!?!?
                        return stbi__errpuc("bad BMP", "bad BMP");
                    }
                }
                else
                    return stbi__errpuc("bad BMP", "bad BMP");
            }
        }
        else {
            // V4/V5 header
            int i;
            if (hsz != 108 && hsz != 124)
                return stbi__errpuc("bad BMP", "bad BMP");
            info->mr = stbi__get32le(s);
            info->mg = stbi__get32le(s);
            info->mb = stbi__get32le(s);
            info->ma = stbi__get32le(s);
            if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
                stbi__bmp_set_mask_defaults(info, compress);
            stbi__get32le(s); // discard color space
            for (i = 0; i < 12; ++i)
                stbi__get32le(s); // discard color space parameters
            if (hsz == 124) {
                stbi__get32le(s); // discard rendering intent
                stbi__get32le(s); // discard offset of profile data
                stbi__get32le(s); // discard size of profile data
                stbi__get32le(s); // discard reserved
            }
        }
    }
    return (void*)1;
}


static void* stbi__bmp_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    stbi_uc* out;
    unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a;
    stbi_uc pal[256][4];
    int psize = 0, i, j, width;
    int flip_vertically, pad, target;
    stbi__bmp_data info;
    STBI_NOTUSED(ri);

    info.all_a = 255;
    if (stbi__bmp_parse_header(s, &info) == NULL)
        return NULL; // error code already set

    flip_vertically = ((int)s->img_y) > 0;
    s->img_y = abs((int)s->img_y);

    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");
    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

    mr = info.mr;
    mg = info.mg;
    mb = info.mb;
    ma = info.ma;
    all_a = info.all_a;

    if (info.hsz == 12) {
        if (info.bpp < 24)
            psize = (info.offset - info.extra_read - 24) / 3;
    }
    else {
        if (info.bpp < 16)
            psize = (info.offset - info.extra_read - info.hsz) >> 2;
    }
    if (psize == 0) {
        if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
            return stbi__errpuc("bad offset", "Corrupt BMP");
        }
    }

    if (info.bpp == 24 && ma == 0xff000000)
        s->img_n = 3;
    else
        s->img_n = ma ? 4 : 3;
    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
        target = req_comp;
    else
        target = s->img_n; // if they want monochrome, we'll post-convert

     // sanity-check size
    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
        return stbi__errpuc("too large", "Corrupt BMP");

    out = (stbi_uc*)stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
    if (!out) return stbi__errpuc("outofmem", "Out of memory");
    if (info.bpp < 16) {
        int z = 0;
        if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
        for (i = 0; i < psize; ++i) {
            pal[i][2] = stbi__get8(s);
            pal[i][1] = stbi__get8(s);
            pal[i][0] = stbi__get8(s);
            if (info.hsz != 12) stbi__get8(s);
            pal[i][3] = 255;
        }
        stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
        if (info.bpp == 1) width = (s->img_x + 7) >> 3;
        else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
        else if (info.bpp == 8) width = s->img_x;
        else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
        pad = (-width) & 3;
        if (info.bpp == 1) {
            for (j = 0; j < (int)s->img_y; ++j) {
                int bit_offset = 7, v = stbi__get8(s);
                for (i = 0; i < (int)s->img_x; ++i) {
                    int color = (v >> bit_offset) & 0x1;
                    out[z++] = pal[color][0];
                    out[z++] = pal[color][1];
                    out[z++] = pal[color][2];
                    if (target == 4) out[z++] = 255;
                    if (i + 1 == (int)s->img_x) break;
                    if ((--bit_offset) < 0) {
                        bit_offset = 7;
                        v = stbi__get8(s);
                    }
                }
                stbi__skip(s, pad);
            }
        }
        else {
            for (j = 0; j < (int)s->img_y; ++j) {
                for (i = 0; i < (int)s->img_x; i += 2) {
                    int v = stbi__get8(s), v2 = 0;
                    if (info.bpp == 4) {
                        v2 = v & 15;
                        v >>= 4;
                    }
                    out[z++] = pal[v][0];
                    out[z++] = pal[v][1];
                    out[z++] = pal[v][2];
                    if (target == 4) out[z++] = 255;
                    if (i + 1 == (int)s->img_x) break;
                    v = (info.bpp == 8) ? stbi__get8(s) : v2;
                    out[z++] = pal[v][0];
                    out[z++] = pal[v][1];
                    out[z++] = pal[v][2];
                    if (target == 4) out[z++] = 255;
                }
                stbi__skip(s, pad);
            }
        }
    }
    else {
        int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;
        int z = 0;
        int easy = 0;
        stbi__skip(s, info.offset - info.extra_read - info.hsz);
        if (info.bpp == 24) width = 3 * s->img_x;
        else if (info.bpp == 16) width = 2 * s->img_x;
        else /* bpp = 32 and pad = 0 */ width = 0;
        pad = (-width) & 3;
        if (info.bpp == 24) {
            easy = 1;
        }
        else if (info.bpp == 32) {
            if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
                easy = 2;
        }
        if (!easy) {
            if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
            // right shift amt to put high bit in position #7
            rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);
            gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);
            bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);
            ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);
            if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
        }
        for (j = 0; j < (int)s->img_y; ++j) {
            if (easy) {
                for (i = 0; i < (int)s->img_x; ++i) {
                    unsigned char a;
                    out[z + 2] = stbi__get8(s);
                    out[z + 1] = stbi__get8(s);
                    out[z + 0] = stbi__get8(s);
                    z += 3;
                    a = (easy == 2 ? stbi__get8(s) : 255);
                    all_a |= a;
                    if (target == 4) out[z++] = a;
                }
            }
            else {
                int bpp = info.bpp;
                for (i = 0; i < (int)s->img_x; ++i) {
                    stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));
                    unsigned int a;
                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
                    out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
                    a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
                    all_a |= a;
                    if (target == 4) out[z++] = STBI__BYTECAST(a);
                }
            }
            stbi__skip(s, pad);
        }
    }

    // if alpha channel is all 0s, replace with all 255s
    if (target == 4 && all_a == 0)
        for (i = 4 * s->img_x * s->img_y - 1; i >= 0; i -= 4)
            out[i] = 255;

    if (flip_vertically) {
        stbi_uc t;
        for (j = 0; j < (int)s->img_y >> 1; ++j) {
            stbi_uc* p1 = out + j * s->img_x * target;
            stbi_uc* p2 = out + (s->img_y - 1 - j) * s->img_x * target;
            for (i = 0; i < (int)s->img_x * target; ++i) {
                t = p1[i]; p1[i] = p2[i]; p2[i] = t;
            }
        }
    }

    if (req_comp && req_comp != target) {
        out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
        if (out == NULL) return out; // stbi__convert_format frees input on failure
    }

    *x = s->img_x;
    *y = s->img_y;
    if (comp) *comp = s->img_n;
    return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
    // only RGB or RGBA (incl. 16bit) or grey allowed
    if (is_rgb16) *is_rgb16 = 0;
    switch (bits_per_pixel) {
    case 8:  return STBI_grey;
    case 16: if (is_grey) return STBI_grey_alpha;
        // fallthrough
    case 15: if (is_rgb16) *is_rgb16 = 1;
        return STBI_rgb;
    case 24: // fallthrough
    case 32: return bits_per_pixel / 8;
    default: return 0;
    }
}

static int stbi__tga_info(stbi__context* s, int* x, int* y, int* comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if (tga_colormap_type > 1) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if (tga_colormap_type == 1) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s, 4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    }
    else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ((tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11)) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s, 9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if (tga_w < 1) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if (tga_h < 1) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    }
    else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if (!tga_comp) {
        stbi__rewind(s);
        return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context* s)
{
    int res = 0;
    int sz, tga_color_type;
    stbi__get8(s);      //   discard Offset
    tga_color_type = stbi__get8(s);   //   color type
    if (tga_color_type > 1) goto errorEnd;   //   only RGB or indexed allowed
    sz = stbi__get8(s);   //   image type
    if (tga_color_type == 1) { // colormapped (paletted) image
        if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
        stbi__skip(s, 4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;
        stbi__skip(s, 4);       // skip image x and y origin
    }
    else { // "normal" image w/o colormap
        if ((sz != 2) && (sz != 3) && (sz != 10) && (sz != 11)) goto errorEnd; // only RGB or grey allowed, +/- RLE
        stbi__skip(s, 9); // skip colormap specification and image x/y origin
    }
    if (stbi__get16le(s) < 1) goto errorEnd;      //   test width
    if (stbi__get16le(s) < 1) goto errorEnd;      //   test height
    sz = stbi__get8(s);   //   bits per pixel
    if ((tga_color_type == 1) && (sz != 8) && (sz != 16)) goto errorEnd; // for colormapped images, bpp is size of an index
    if ((sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32)) goto errorEnd;

    res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
    stbi__rewind(s);
    return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context* s, stbi_uc* out)
{
    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
    stbi__uint16 fiveBitMask = 31;
    // we have 3 channels with 5bits each
    int r = (px >> 10) & fiveBitMask;
    int g = (px >> 5) & fiveBitMask;
    int b = px & fiveBitMask;
    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
    out[0] = (stbi_uc)((r * 255) / 31);
    out[1] = (stbi_uc)((g * 255) / 31);
    out[2] = (stbi_uc)((b * 255) / 31);

    // some people claim that the most significant bit might be used for alpha
    // (possibly if an alpha-bit is set in the "image descriptor byte")
    // but that only made 16bit test images completely translucent..
    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void* stbi__tga_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    //   read in the TGA header stuff
    int tga_offset = stbi__get8(s);
    int tga_indexed = stbi__get8(s);
    int tga_image_type = stbi__get8(s);
    int tga_is_RLE = 0;
    int tga_palette_start = stbi__get16le(s);
    int tga_palette_len = stbi__get16le(s);
    int tga_palette_bits = stbi__get8(s);
    int tga_x_origin = stbi__get16le(s);
    int tga_y_origin = stbi__get16le(s);
    int tga_width = stbi__get16le(s);
    int tga_height = stbi__get16le(s);
    int tga_bits_per_pixel = stbi__get8(s);
    int tga_comp, tga_rgb16 = 0;
    int tga_inverted = stbi__get8(s);
    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
    //   image data
    unsigned char* tga_data;
    unsigned char* tga_palette = NULL;
    int i, j;
    unsigned char raw_data[4] = { 0 };
    int RLE_count = 0;
    int RLE_repeating = 0;
    int read_next_pixel = 1;
    STBI_NOTUSED(ri);
    STBI_NOTUSED(tga_x_origin); // @TODO
    STBI_NOTUSED(tga_y_origin); // @TODO

    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");
    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

    //   do a tiny bit of precessing
    if (tga_image_type >= 8)
    {
        tga_image_type -= 8;
        tga_is_RLE = 1;
    }
    tga_inverted = 1 - ((tga_inverted >> 5) & 1);

    //   If I'm paletted, then I'll use the number of bits from the palette
    if (tga_indexed) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

    if (!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
        return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

    //   tga info
    *x = tga_width;
    *y = tga_height;
    if (comp) *comp = tga_comp;

    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
        return stbi__errpuc("too large", "Corrupt TGA");

    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

    // skip to the data's starting position (offset usually = 0)
    stbi__skip(s, tga_offset);

    if (!tga_indexed && !tga_is_RLE && !tga_rgb16) {
        for (i = 0; i < tga_height; ++i) {
            int row = tga_inverted ? tga_height - i - 1 : i;
            stbi_uc* tga_row = tga_data + row * tga_width * tga_comp;
            stbi__getn(s, tga_row, tga_width * tga_comp);
        }
    }
    else {
        //   do I need to load a palette?
        if (tga_indexed)
        {
            if (tga_palette_len == 0) {  /* you have to have at least one entry! */
                STBI_FREE(tga_data);
                return stbi__errpuc("bad palette", "Corrupt TGA");
            }

            //   any data to skip? (offset usually = 0)
            stbi__skip(s, tga_palette_start);
            //   load the palette
            tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
            if (!tga_palette) {
                STBI_FREE(tga_data);
                return stbi__errpuc("outofmem", "Out of memory");
            }
            if (tga_rgb16) {
                stbi_uc* pal_entry = tga_palette;
                STBI_ASSERT(tga_comp == STBI_rgb);
                for (i = 0; i < tga_palette_len; ++i) {
                    stbi__tga_read_rgb16(s, pal_entry);
                    pal_entry += tga_comp;
                }
            }
            else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
                STBI_FREE(tga_data);
                STBI_FREE(tga_palette);
                return stbi__errpuc("bad palette", "Corrupt TGA");
            }
        }
        //   load the data
        for (i = 0; i < tga_width * tga_height; ++i)
        {
            //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
            if (tga_is_RLE)
            {
                if (RLE_count == 0)
                {
                    //   yep, get the next byte as a RLE command
                    int RLE_cmd = stbi__get8(s);
                    RLE_count = 1 + (RLE_cmd & 127);
                    RLE_repeating = RLE_cmd >> 7;
                    read_next_pixel = 1;
                }
                else if (!RLE_repeating)
                {
                    read_next_pixel = 1;
                }
            }
            else
            {
                read_next_pixel = 1;
            }
            //   OK, if I need to read a pixel, do it now
            if (read_next_pixel)
            {
                //   load however much data we did have
                if (tga_indexed)
                {
                    // read in index, then perform the lookup
                    int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
                    if (pal_idx >= tga_palette_len) {
                        // invalid index
                        pal_idx = 0;
                    }
                    pal_idx *= tga_comp;
                    for (j = 0; j < tga_comp; ++j) {
                        raw_data[j] = tga_palette[pal_idx + j];
                    }
                }
                else if (tga_rgb16) {
                    STBI_ASSERT(tga_comp == STBI_rgb);
                    stbi__tga_read_rgb16(s, raw_data);
                }
                else {
                    //   read in the data raw
                    for (j = 0; j < tga_comp; ++j) {
                        raw_data[j] = stbi__get8(s);
                    }
                }
                //   clear the reading flag for the next pixel
                read_next_pixel = 0;
            } // end of reading a pixel

            // copy data
            for (j = 0; j < tga_comp; ++j)
                tga_data[i * tga_comp + j] = raw_data[j];

            //   in case we're in RLE mode, keep counting down
            --RLE_count;
        }
        //   do I need to invert the image?
        if (tga_inverted)
        {
            for (j = 0; j * 2 < tga_height; ++j)
            {
                int index1 = j * tga_width * tga_comp;
                int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
                for (i = tga_width * tga_comp; i > 0; --i)
                {
                    unsigned char temp = tga_data[index1];
                    tga_data[index1] = tga_data[index2];
                    tga_data[index2] = temp;
                    ++index1;
                    ++index2;
                }
            }
        }
        //   clear my palette, if I had one
        if (tga_palette != NULL)
        {
            STBI_FREE(tga_palette);
        }
    }

    // swap RGB - if the source data was RGB16, it already is in the right order
    if (tga_comp >= 3 && !tga_rgb16)
    {
        unsigned char* tga_pixel = tga_data;
        for (i = 0; i < tga_width * tga_height; ++i)
        {
            unsigned char temp = tga_pixel[0];
            tga_pixel[0] = tga_pixel[2];
            tga_pixel[2] = temp;
            tga_pixel += tga_comp;
        }
    }

    // convert to target component count
    if (req_comp && req_comp != tga_comp)
        tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

    //   the things I do to get rid of an error message, and yet keep
    //   Microsoft's C compilers happy... [8^(
    tga_palette_start = tga_palette_len = tga_palette_bits =
        tga_x_origin = tga_y_origin = 0;
    STBI_NOTUSED(tga_palette_start);
    //   OK, done
    return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context* s)
{
    int r = (stbi__get32be(s) == 0x38425053);
    stbi__rewind(s);
    return r;
}

static int stbi__psd_decode_rle(stbi__context* s, stbi_uc* p, int pixelCount)
{
    int count, nleft, len;

    count = 0;
    while ((nleft = pixelCount - count) > 0) {
        len = stbi__get8(s);
        if (len == 128) {
            // No-op.
        }
        else if (len < 128) {
            // Copy next len+1 bytes literally.
            len++;
            if (len > nleft) return 0; // corrupt data
            count += len;
            while (len) {
                *p = stbi__get8(s);
                p += 4;
                len--;
            }
        }
        else if (len > 128) {
            stbi_uc   val;
            // Next -len+1 bytes in the dest are replicated from next source byte.
            // (Interpret len as a negative 8-bit int.)
            len = 257 - len;
            if (len > nleft) return 0; // corrupt data
            val = stbi__get8(s);
            count += len;
            while (len) {
                *p = val;
                p += 4;
                len--;
            }
        }
    }

    return 1;
}

static void* stbi__psd_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri, int bpc)
{
    int pixelCount;
    int channelCount, compression;
    int channel, i;
    int bitdepth;
    int w, h;
    stbi_uc* out;
    STBI_NOTUSED(ri);

    // Check identifier
    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
        return stbi__errpuc("not PSD", "Corrupt PSD image");

    // Check file type version.
    if (stbi__get16be(s) != 1)
        return stbi__errpuc("wrong version", "Unsupported version of PSD image");

    // Skip 6 reserved bytes.
    stbi__skip(s, 6);

    // Read the number of channels (R, G, B, A, etc).
    channelCount = stbi__get16be(s);
    if (channelCount < 0 || channelCount > 16)
        return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

    // Read the rows and columns of the image.
    h = stbi__get32be(s);
    w = stbi__get32be(s);

    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");
    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

    // Make sure the depth is 8 bits.
    bitdepth = stbi__get16be(s);
    if (bitdepth != 8 && bitdepth != 16)
        return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

    // Make sure the color mode is RGB.
    // Valid options are:
    //   0: Bitmap
    //   1: Grayscale
    //   2: Indexed color
    //   3: RGB color
    //   4: CMYK color
    //   7: Multichannel
    //   8: Duotone
    //   9: Lab color
    if (stbi__get16be(s) != 3)
        return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
    stbi__skip(s, stbi__get32be(s));

    // Skip the image resources.  (resolution, pen tool paths, etc)
    stbi__skip(s, stbi__get32be(s));

    // Skip the reserved data.
    stbi__skip(s, stbi__get32be(s));

    // Find out if the data is compressed.
    // Known values:
    //   0: no compression
    //   1: RLE compressed
    compression = stbi__get16be(s);
    if (compression > 1)
        return stbi__errpuc("bad compression", "PSD has an unknown compression format");

    // Check size
    if (!stbi__mad3sizes_valid(4, w, h, 0))
        return stbi__errpuc("too large", "Corrupt PSD");

    // Create the destination image.

    if (!compression && bitdepth == 16 && bpc == 16) {
        out = (stbi_uc*)stbi__malloc_mad3(8, w, h, 0);
        ri->bits_per_channel = 16;
    }
    else
        out = (stbi_uc*)stbi__malloc(4 * w * h);

    if (!out) return stbi__errpuc("outofmem", "Out of memory");
    pixelCount = w * h;

    // Initialize the data to zero.
    //memset( out, 0, pixelCount * 4 );

    // Finally, the image data.
    if (compression) {
        // RLE as used by .PSD and .TIFF
        // Loop until you get the number of unpacked bytes you are expecting:
        //     Read the next source byte into n.
        //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
        //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
        //     Else if n is 128, noop.
        // Endloop

        // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
        // which we're going to just skip.
        stbi__skip(s, h * channelCount * 2);

        // Read the RLE data by channel.
        for (channel = 0; channel < 4; channel++) {
            stbi_uc* p;

            p = out + channel;
            if (channel >= channelCount) {
                // Fill this channel with default data.
                for (i = 0; i < pixelCount; i++, p += 4)
                    *p = (channel == 3 ? 255 : 0);
            }
            else {
                // Read the RLE data.
                if (!stbi__psd_decode_rle(s, p, pixelCount)) {
                    STBI_FREE(out);
                    return stbi__errpuc("corrupt", "bad RLE data");
                }
            }
        }

    }
    else {
        // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
        // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

        // Read the data by channel.
        for (channel = 0; channel < 4; channel++) {
            if (channel >= channelCount) {
                // Fill this channel with default data.
                if (bitdepth == 16 && bpc == 16) {
                    stbi__uint16* q = ((stbi__uint16*)out) + channel;
                    stbi__uint16 val = channel == 3 ? 65535 : 0;
                    for (i = 0; i < pixelCount; i++, q += 4)
                        *q = val;
                }
                else {
                    stbi_uc* p = out + channel;
                    stbi_uc val = channel == 3 ? 255 : 0;
                    for (i = 0; i < pixelCount; i++, p += 4)
                        *p = val;
                }
            }
            else {
                if (ri->bits_per_channel == 16) {    // output bpc
                    stbi__uint16* q = ((stbi__uint16*)out) + channel;
                    for (i = 0; i < pixelCount; i++, q += 4)
                        *q = (stbi__uint16)stbi__get16be(s);
                }
                else {
                    stbi_uc* p = out + channel;
                    if (bitdepth == 16) {  // input bpc
                        for (i = 0; i < pixelCount; i++, p += 4)
                            *p = (stbi_uc)(stbi__get16be(s) >> 8);
                    }
                    else {
                        for (i = 0; i < pixelCount; i++, p += 4)
                            *p = stbi__get8(s);
                    }
                }
            }
        }
    }

    // remove weird white matte from PSD
    if (channelCount >= 4) {
        if (ri->bits_per_channel == 16) {
            for (i = 0; i < w * h; ++i) {
                stbi__uint16* pixel = (stbi__uint16*)out + 4 * i;
                if (pixel[3] != 0 && pixel[3] != 65535) {
                    float a = pixel[3] / 65535.0f;
                    float ra = 1.0f / a;
                    float inv_a = 65535.0f * (1 - ra);
                    pixel[0] = (stbi__uint16)(pixel[0] * ra + inv_a);
                    pixel[1] = (stbi__uint16)(pixel[1] * ra + inv_a);
                    pixel[2] = (stbi__uint16)(pixel[2] * ra + inv_a);
                }
            }
        }
        else {
            for (i = 0; i < w * h; ++i) {
                unsigned char* pixel = out + 4 * i;
                if (pixel[3] != 0 && pixel[3] != 255) {
                    float a = pixel[3] / 255.0f;
                    float ra = 1.0f / a;
                    float inv_a = 255.0f * (1 - ra);
                    pixel[0] = (unsigned char)(pixel[0] * ra + inv_a);
                    pixel[1] = (unsigned char)(pixel[1] * ra + inv_a);
                    pixel[2] = (unsigned char)(pixel[2] * ra + inv_a);
                }
            }
        }
    }

    // convert to desired output format
    if (req_comp && req_comp != 4) {
        if (ri->bits_per_channel == 16)
            out = (stbi_uc*)stbi__convert_format16((stbi__uint16*)out, 4, req_comp, w, h);
        else
            out = stbi__convert_format(out, 4, req_comp, w, h);
        if (out == NULL) return out; // stbi__convert_format frees input on failure
    }

    if (comp) *comp = 4;
    *y = h;
    *x = w;

    return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context* s, const char* str)
{
    int i;
    for (i = 0; i < 4; ++i)
        if (stbi__get8(s) != (stbi_uc)str[i])
            return 0;

    return 1;
}

static int stbi__pic_test_core(stbi__context* s)
{
    int i;

    if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))
        return 0;

    for (i = 0; i < 84; ++i)
        stbi__get8(s);

    if (!stbi__pic_is4(s, "PICT"))
        return 0;

    return 1;
}

typedef struct
{
    stbi_uc size, type, channel;
} stbi__pic_packet;

static stbi_uc* stbi__readval(stbi__context* s, int channel, stbi_uc* dest)
{
    int mask = 0x80, i;

    for (i = 0; i < 4; ++i, mask >>= 1) {
        if (channel & mask) {
            if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");
            dest[i] = stbi__get8(s);
        }
    }

    return dest;
}

static void stbi__copyval(int channel, stbi_uc* dest, const stbi_uc* src)
{
    int mask = 0x80, i;

    for (i = 0; i < 4; ++i, mask >>= 1)
        if (channel & mask)
            dest[i] = src[i];
}

static stbi_uc* stbi__pic_load_core(stbi__context* s, int width, int height, int* comp, stbi_uc* result)
{
    int act_comp = 0, num_packets = 0, y, chained;
    stbi__pic_packet packets[10];

    // this will (should...) cater for even some bizarre stuff like having data
     // for the same channel in multiple packets.
    do {
        stbi__pic_packet* packet;

        if (num_packets == sizeof(packets) / sizeof(packets[0]))
            return stbi__errpuc("bad format", "too many packets");

        packet = &packets[num_packets++];

        chained = stbi__get8(s);
        packet->size = stbi__get8(s);
        packet->type = stbi__get8(s);
        packet->channel = stbi__get8(s);

        act_comp |= packet->channel;

        if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");
        if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");
    } while (chained);

    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

    for (y = 0; y < height; ++y) {
        int packet_idx;

        for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {
            stbi__pic_packet* packet = &packets[packet_idx];
            stbi_uc* dest = result + y * width * 4;

            switch (packet->type) {
            default:
                return stbi__errpuc("bad format", "packet has bad compression type");

            case 0: {//uncompressed
                int x;

                for (x = 0; x < width; ++x, dest += 4)
                    if (!stbi__readval(s, packet->channel, dest))
                        return 0;
                break;
            }

            case 1://Pure RLE
            {
                int left = width, i;

                while (left > 0) {
                    stbi_uc count, value[4];

                    count = stbi__get8(s);
                    if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

                    if (count > left)
                        count = (stbi_uc)left;

                    if (!stbi__readval(s, packet->channel, value))  return 0;

                    for (i = 0; i < count; ++i, dest += 4)
                        stbi__copyval(packet->channel, dest, value);
                    left -= count;
                }
            }
            break;

            case 2: {//Mixed RLE
                int left = width;
                while (left > 0) {
                    int count = stbi__get8(s), i;
                    if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

                    if (count >= 128) { // Repeated
                        stbi_uc value[4];

                        if (count == 128)
                            count = stbi__get16be(s);
                        else
                            count -= 127;
                        if (count > left)
                            return stbi__errpuc("bad file", "scanline overrun");

                        if (!stbi__readval(s, packet->channel, value))
                            return 0;

                        for (i = 0; i < count; ++i, dest += 4)
                            stbi__copyval(packet->channel, dest, value);
                    }
                    else { // Raw
                        ++count;
                        if (count > left) return stbi__errpuc("bad file", "scanline overrun");

                        for (i = 0; i < count; ++i, dest += 4)
                            if (!stbi__readval(s, packet->channel, dest))
                                return 0;
                    }
                    left -= count;
                }
                break;
            }
            }
        }
    }

    return result;
}

static void* stbi__pic_load(stbi__context* s, int* px, int* py, int* comp, int req_comp, stbi__result_info* ri)
{
    stbi_uc* result;
    int i, x, y, internal_comp;
    STBI_NOTUSED(ri);

    if (!comp) comp = &internal_comp;

    for (i = 0; i < 92; ++i)
        stbi__get8(s);

    x = stbi__get16be(s);
    y = stbi__get16be(s);

    if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");
    if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

    if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");
    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

    stbi__get32be(s); //skip `ratio'
    stbi__get16be(s); //skip `fields'
    stbi__get16be(s); //skip `pad'

    // intermediate buffer is RGBA
    result = (stbi_uc*)stbi__malloc_mad3(x, y, 4, 0);
    if (!result) return stbi__errpuc("outofmem", "Out of memory");
    memset(result, 0xff, x * y * 4);

    if (!stbi__pic_load_core(s, x, y, comp, result)) {
        STBI_FREE(result);
        result = 0;
    }
    *px = x;
    *py = y;
    if (req_comp == 0) req_comp = *comp;
    result = stbi__convert_format(result, 4, req_comp, x, y);

    return result;
}

static int stbi__pic_test(stbi__context* s)
{
    int r = stbi__pic_test_core(s);
    stbi__rewind(s);
    return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
    stbi__int16 prefix;
    stbi_uc first;
    stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
    int w, h;
    stbi_uc* out;                 // output buffer (always 4 components)
    stbi_uc* background;          // The current "background" as far as a gif is concerned
    stbi_uc* history;
    int flags, bgindex, ratio, transparent, eflags;
    stbi_uc  pal[256][4];
    stbi_uc lpal[256][4];
    stbi__gif_lzw codes[8192];
    stbi_uc* color_table;
    int parse, step;
    int lflags;
    int start_x, start_y;
    int max_x, max_y;
    int cur_x, cur_y;
    int line_size;
    int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context* s)
{
    int sz;
    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
    sz = stbi__get8(s);
    if (sz != '9' && sz != '7') return 0;
    if (stbi__get8(s) != 'a') return 0;
    return 1;
}

static int stbi__gif_test(stbi__context* s)
{
    int r = stbi__gif_test_raw(s);
    stbi__rewind(s);
    return r;
}

static void stbi__gif_parse_colortable(stbi__context* s, stbi_uc pal[256][4], int num_entries, int transp)
{
    int i;
    for (i = 0; i < num_entries; ++i) {
        pal[i][2] = stbi__get8(s);
        pal[i][1] = stbi__get8(s);
        pal[i][0] = stbi__get8(s);
        pal[i][3] = transp == i ? 0 : 255;
    }
}

static int stbi__gif_header(stbi__context* s, stbi__gif* g, int* comp, int is_info)
{
    stbi_uc version;
    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
        return stbi__err("not GIF", "Corrupt GIF");

    version = stbi__get8(s);
    if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
    if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

    stbi__g_failure_reason = "";
    g->w = stbi__get16le(s);
    g->h = stbi__get16le(s);
    g->flags = stbi__get8(s);
    g->bgindex = stbi__get8(s);
    g->ratio = stbi__get8(s);
    g->transparent = -1;

    if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");
    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large", "Very large image (corrupt?)");

    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

    if (is_info) return 1;

    if (g->flags & 0x80)
        stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

    return 1;
}

static int stbi__gif_info_raw(stbi__context* s, int* x, int* y, int* comp)
{
    stbi__gif* g = (stbi__gif*)stbi__malloc(sizeof(stbi__gif));
    if (!g) return stbi__err("outofmem", "Out of memory");
    if (!stbi__gif_header(s, g, comp, 1)) {
        STBI_FREE(g);
        stbi__rewind(s);
        return 0;
    }
    if (x) *x = g->w;
    if (y) *y = g->h;
    STBI_FREE(g);
    return 1;
}

static void stbi__out_gif_code(stbi__gif* g, stbi__uint16 code)
{
    stbi_uc* p, * c;
    int idx;

    // recurse to decode the prefixes, since the linked-list is backwards,
    // and working backwards through an interleaved image would be nasty
    if (g->codes[code].prefix >= 0)
        stbi__out_gif_code(g, g->codes[code].prefix);

    if (g->cur_y >= g->max_y) return;

    idx = g->cur_x + g->cur_y;
    p = &g->out[idx];
    g->history[idx / 4] = 1;

    c = &g->color_table[g->codes[code].suffix * 4];
    if (c[3] > 128) { // don't render transparent pixels;
        p[0] = c[2];
        p[1] = c[1];
        p[2] = c[0];
        p[3] = c[3];
    }
    g->cur_x += 4;

    if (g->cur_x >= g->max_x) {
        g->cur_x = g->start_x;
        g->cur_y += g->step;

        while (g->cur_y >= g->max_y && g->parse > 0) {
            g->step = (1 << g->parse) * g->line_size;
            g->cur_y = g->start_y + (g->step >> 1);
            --g->parse;
        }
    }
}

static stbi_uc* stbi__process_gif_raster(stbi__context* s, stbi__gif* g)
{
    stbi_uc lzw_cs;
    stbi__int32 len, init_code;
    stbi__uint32 first;
    stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
    stbi__gif_lzw* p;

    lzw_cs = stbi__get8(s);
    if (lzw_cs > 12) return NULL;
    clear = 1 << lzw_cs;
    first = 1;
    codesize = lzw_cs + 1;
    codemask = (1 << codesize) - 1;
    bits = 0;
    valid_bits = 0;
    for (init_code = 0; init_code < clear; init_code++) {
        g->codes[init_code].prefix = -1;
        g->codes[init_code].first = (stbi_uc)init_code;
        g->codes[init_code].suffix = (stbi_uc)init_code;
    }

    // support no starting clear code
    avail = clear + 2;
    oldcode = -1;

    len = 0;
    for (;;) {
        if (valid_bits < codesize) {
            if (len == 0) {
                len = stbi__get8(s); // start new block
                if (len == 0)
                    return g->out;
            }
            --len;
            bits |= (stbi__int32)stbi__get8(s) << valid_bits;
            valid_bits += 8;
        }
        else {
            stbi__int32 code = bits & codemask;
            bits >>= codesize;
            valid_bits -= codesize;
            // @OPTIMIZE: is there some way we can accelerate the non-clear path?
            if (code == clear) {  // clear code
                codesize = lzw_cs + 1;
                codemask = (1 << codesize) - 1;
                avail = clear + 2;
                oldcode = -1;
                first = 0;
            }
            else if (code == clear + 1) { // end of stream code
                stbi__skip(s, len);
                while ((len = stbi__get8(s)) > 0)
                    stbi__skip(s, len);
                return g->out;
            }
            else if (code <= avail) {
                if (first) {
                    return stbi__errpuc("no clear code", "Corrupt GIF");
                }

                if (oldcode >= 0) {
                    p = &g->codes[avail++];
                    if (avail > 8192) {
                        return stbi__errpuc("too many codes", "Corrupt GIF");
                    }

                    p->prefix = (stbi__int16)oldcode;
                    p->first = g->codes[oldcode].first;
                    p->suffix = (code == avail) ? p->first : g->codes[code].first;
                }
                else if (code == avail)
                    return stbi__errpuc("illegal code in raster", "Corrupt GIF");

                stbi__out_gif_code(g, (stbi__uint16)code);

                if ((avail & codemask) == 0 && avail <= 0x0FFF) {
                    codesize++;
                    codemask = (1 << codesize) - 1;
                }

                oldcode = code;
            }
            else {
                return stbi__errpuc("illegal code in raster", "Corrupt GIF");
            }
        }
    }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc* stbi__gif_load_next(stbi__context* s, stbi__gif* g, int* comp, int req_comp, stbi_uc* two_back)
{
    int dispose;
    int first_frame;
    int pi;
    int pcount;
    STBI_NOTUSED(req_comp);

    // on first frame, any non-written pixels get the background colour (non-transparent)
    first_frame = 0;
    if (g->out == 0) {
        if (!stbi__gif_header(s, g, comp, 0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
        if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
            return stbi__errpuc("too large", "GIF image is too large");
        pcount = g->w * g->h;
        g->out = (stbi_uc*)stbi__malloc(4 * pcount);
        g->background = (stbi_uc*)stbi__malloc(4 * pcount);
        g->history = (stbi_uc*)stbi__malloc(pcount);
        if (!g->out || !g->background || !g->history)
            return stbi__errpuc("outofmem", "Out of memory");

        // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
        // background colour is only used for pixels that are not rendered first frame, after that "background"
        // color refers to the color that was there the previous frame.
        memset(g->out, 0x00, 4 * pcount);
        memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
        memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
        first_frame = 1;
    }
    else {
        // second frame - how do we dispose of the previous one?
        dispose = (g->eflags & 0x1C) >> 2;
        pcount = g->w * g->h;

        if ((dispose == 3) && (two_back == 0)) {
            dispose = 2; // if I don't have an image to revert back to, default to the old background
        }

        if (dispose == 3) { // use previous graphic
            for (pi = 0; pi < pcount; ++pi) {
                if (g->history[pi]) {
                    memcpy(&g->out[pi * 4], &two_back[pi * 4], 4);
                }
            }
        }
        else if (dispose == 2) {
            // restore what was changed last frame to background before that frame;
            for (pi = 0; pi < pcount; ++pi) {
                if (g->history[pi]) {
                    memcpy(&g->out[pi * 4], &g->background[pi * 4], 4);
                }
            }
        }
        else {
            // This is a non-disposal case eithe way, so just
            // leave the pixels as is, and they will become the new background
            // 1: do not dispose
            // 0:  not specified.
        }

        // background is what out is after the undoing of the previou frame;
        memcpy(g->background, g->out, 4 * g->w * g->h);
    }

    // clear my history;
    memset(g->history, 0x00, g->w * g->h);        // pixels that were affected previous frame

    for (;;) {
        int tag = stbi__get8(s);
        switch (tag) {
        case 0x2C: /* Image Descriptor */
        {
            stbi__int32 x, y, w, h;
            stbi_uc* o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
                return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x = g->start_x + w * 4;
            g->max_y = g->start_y + h * g->line_size;
            g->cur_x = g->start_x;
            g->cur_y = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
                g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
                g->step = 8 * g->line_size; // first interlaced spacing
                g->parse = 3;
            }
            else {
                g->step = g->line_size;
                g->parse = 0;
            }

            if (g->lflags & 0x80) {
                stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
                g->color_table = (stbi_uc*)g->lpal;
            }
            else if (g->flags & 0x80) {
                g->color_table = (stbi_uc*)g->pal;
            }
            else
                return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
                // if first frame, any pixel not drawn to gets the background color
                for (pi = 0; pi < pcount; ++pi) {
                    if (g->history[pi] == 0) {
                        g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                        memcpy(&g->out[pi * 4], &g->pal[g->bgindex], 4);
                    }
                }
            }

            return o;
        }

        case 0x21: // Comment Extension.
        {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
                len = stbi__get8(s);
                if (len == 4) {
                    g->eflags = stbi__get8(s);
                    g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                    // unset old transparent
                    if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 255;
                    }
                    if (g->eflags & 0x01) {
                        g->transparent = stbi__get8(s);
                        if (g->transparent >= 0) {
                            g->pal[g->transparent][3] = 0;
                        }
                    }
                    else {
                        // don't need transparent
                        stbi__skip(s, 1);
                        g->transparent = -1;
                    }
                }
                else {
                    stbi__skip(s, len);
                    break;
                }
            }
            while ((len = stbi__get8(s)) != 0) {
                stbi__skip(s, len);
            }
            break;
        }

        case 0x3B: // gif stream termination code
            return (stbi_uc*)s; // using '1' causes warning on some compilers

        default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
        }
    }
}

static void* stbi__load_gif_main_outofmem(stbi__gif* g, stbi_uc* out, int** delays)
{
    STBI_FREE(g->out);
    STBI_FREE(g->history);
    STBI_FREE(g->background);

    if (out) STBI_FREE(out);
    if (delays && *delays) STBI_FREE(*delays);
    return stbi__errpuc("outofmem", "Out of memory");
}

static void* stbi__load_gif_main(stbi__context* s, int** delays, int* x, int* y, int* z, int* comp, int req_comp)
{
    if (stbi__gif_test(s)) {
        int layers = 0;
        stbi_uc* u = 0;
        stbi_uc* out = 0;
        stbi_uc* two_back = 0;
        stbi__gif g;
        int stride;
        int out_size = 0;
        int delays_size = 0;

        STBI_NOTUSED(out_size);
        STBI_NOTUSED(delays_size);

        memset(&g, 0, sizeof(g));
        if (delays) {
            *delays = 0;
        }

        do {
            u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
            if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

            if (u) {
                *x = g.w;
                *y = g.h;
                ++layers;
                stride = g.w * g.h * 4;

                if (out) {
                    void* tmp = (stbi_uc*)STBI_REALLOC_SIZED(out, out_size, layers * stride);
                    if (!tmp)
                        return stbi__load_gif_main_outofmem(&g, out, delays);
                    else {
                        out = (stbi_uc*)tmp;
                        out_size = layers * stride;
                    }

                    if (delays) {
                        int* new_delays = (int*)STBI_REALLOC_SIZED(*delays, delays_size, sizeof(int) * layers);
                        if (!new_delays)
                            return stbi__load_gif_main_outofmem(&g, out, delays);
                        *delays = new_delays;
                        delays_size = layers * sizeof(int);
                    }
                }
                else {
                    out = (stbi_uc*)stbi__malloc(layers * stride);
                    if (!out)
                        return stbi__load_gif_main_outofmem(&g, out, delays);
                    out_size = layers * stride;
                    if (delays) {
                        *delays = (int*)stbi__malloc(layers * sizeof(int));
                        if (!*delays)
                            return stbi__load_gif_main_outofmem(&g, out, delays);
                        delays_size = layers * sizeof(int);
                    }
                }
                memcpy(out + ((layers - 1) * stride), u, stride);
                if (layers >= 2) {
                    two_back = out - 2 * stride;
                }

                if (delays) {
                    (*delays)[layers - 1U] = g.delay;
                }
            }
        } while (u != 0);

        // free temp buffer;
        STBI_FREE(g.out);
        STBI_FREE(g.history);
        STBI_FREE(g.background);

        // do the final conversion after loading everything;
        if (req_comp && req_comp != 4)
            out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

        *z = layers;
        return out;
    }
    else {
        return stbi__errpuc("not GIF", "Image was not as a gif type.");
    }
}

static void* stbi__gif_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    stbi_uc* u = 0;
    stbi__gif g;
    memset(&g, 0, sizeof(g));
    STBI_NOTUSED(ri);

    u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
    if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker
    if (u) {
        *x = g.w;
        *y = g.h;

        // moved conversion to after successful load so that the same
        // can be done for multiple frames.
        if (req_comp && req_comp != 4)
            u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
    }
    else if (g.out) {
        // if there was an error and we allocated an image buffer, free it!
        STBI_FREE(g.out);
    }

    // free buffers needed for multiple frame loading;
    STBI_FREE(g.history);
    STBI_FREE(g.background);

    return u;
}

static int stbi__gif_info(stbi__context* s, int* x, int* y, int* comp)
{
    return stbi__gif_info_raw(s, x, y, comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context* s, const char* signature)
{
    int i;
    for (i = 0; signature[i]; ++i)
        if (stbi__get8(s) != signature[i])
            return 0;
    stbi__rewind(s);
    return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
    int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
    stbi__rewind(s);
    if (!r) {
        r = stbi__hdr_test_core(s, "#?RGBE\n");
        stbi__rewind(s);
    }
    return r;
}

#define STBI__HDR_BUFLEN  1024
static char* stbi__hdr_gettoken(stbi__context* z, char* buffer)
{
    int len = 0;
    char c = '\0';

    c = (char)stbi__get8(z);

    while (!stbi__at_eof(z) && c != '\n') {
        buffer[len++] = c;
        if (len == STBI__HDR_BUFLEN - 1) {
            // flush to end of line
            while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
                ;
            break;
        }
        c = (char)stbi__get8(z);
    }

    buffer[len] = 0;
    return buffer;
}

static void stbi__hdr_convert(float* output, stbi_uc* input, int req_comp)
{
    if (input[3] != 0) {
        float f1;
        // Exponent
        f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));
        if (req_comp <= 2)
            output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
        else {
            output[0] = input[0] * f1;
            output[1] = input[1] * f1;
            output[2] = input[2] * f1;
        }
        if (req_comp == 2) output[1] = 1;
        if (req_comp == 4) output[3] = 1;
    }
    else {
        switch (req_comp) {
        case 4: output[3] = 1; /* fallthrough */
        case 3: output[0] = output[1] = output[2] = 0;
            break;
        case 2: output[1] = 1; /* fallthrough */
        case 1: output[0] = 0;
            break;
        }
    }
}

static float* stbi__hdr_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    char buffer[STBI__HDR_BUFLEN];
    char* token;
    int valid = 0;
    int width, height;
    stbi_uc* scanline;
    float* hdr_data;
    int len;
    unsigned char count, value;
    int i, j, k, c1, c2, z;
    const char* headerToken;
    STBI_NOTUSED(ri);

    // Check identifier
    headerToken = stbi__hdr_gettoken(s, buffer);
    if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
        return stbi__errpf("not HDR", "Corrupt HDR image");

    // Parse header
    for (;;) {
        token = stbi__hdr_gettoken(s, buffer);
        if (token[0] == 0) break;
        if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    }

    if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

    // Parse width and height
    // can't use sscanf() if we're not using stdio!
    token = stbi__hdr_gettoken(s, buffer);
    if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    token += 3;
    height = (int)strtol(token, &token, 10);
    while (*token == ' ') ++token;
    if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    token += 3;
    width = (int)strtol(token, NULL, 10);

    if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large", "Very large image (corrupt?)");
    if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large", "Very large image (corrupt?)");

    *x = width;
    *y = height;

    if (comp) *comp = 3;
    if (req_comp == 0) req_comp = 3;

    if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
        return stbi__errpf("too large", "HDR image is too large");

    // Read data
    hdr_data = (float*)stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
    if (!hdr_data)
        return stbi__errpf("outofmem", "Out of memory");

    // Load image data
    // image data is stored as some number of sca
    if (width < 8 || width >= 32768) {
        // Read flat data
        for (j = 0; j < height; ++j) {
            for (i = 0; i < width; ++i) {
                stbi_uc rgbe[4];
            main_decode_loop:
                stbi__getn(s, rgbe, 4);
                stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
            }
        }
    }
    else {
        // Read RLE-encoded data
        scanline = NULL;

        for (j = 0; j < height; ++j) {
            c1 = stbi__get8(s);
            c2 = stbi__get8(s);
            len = stbi__get8(s);
            if (c1 != 2 || c2 != 2 || (len & 0x80)) {
                // not run-length encoded, so we have to actually use THIS data as a decoded
                // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
                stbi_uc rgbe[4];
                rgbe[0] = (stbi_uc)c1;
                rgbe[1] = (stbi_uc)c2;
                rgbe[2] = (stbi_uc)len;
                rgbe[3] = (stbi_uc)stbi__get8(s);
                stbi__hdr_convert(hdr_data, rgbe, req_comp);
                i = 1;
                j = 0;
                STBI_FREE(scanline);
                goto main_decode_loop; // yes, this makes no sense
            }
            len <<= 8;
            len |= stbi__get8(s);
            if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
            if (scanline == NULL) {
                scanline = (stbi_uc*)stbi__malloc_mad2(width, 4, 0);
                if (!scanline) {
                    STBI_FREE(hdr_data);
                    return stbi__errpf("outofmem", "Out of memory");
                }
            }

            for (k = 0; k < 4; ++k) {
                int nleft;
                i = 0;
                while ((nleft = width - i) > 0) {
                    count = stbi__get8(s);
                    if (count > 128) {
                        // Run
                        value = stbi__get8(s);
                        count -= 128;
                        if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                        for (z = 0; z < count; ++z)
                            scanline[i++ * 4 + k] = value;
                    }
                    else {
                        // Dump
                        if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                        for (z = 0; z < count; ++z)
                            scanline[i++ * 4 + k] = stbi__get8(s);
                    }
                }
            }
            for (i = 0; i < width; ++i)
                stbi__hdr_convert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);
        }
        if (scanline)
            STBI_FREE(scanline);
    }

    return hdr_data;
}

static int stbi__hdr_info(stbi__context* s, int* x, int* y, int* comp)
{
    char buffer[STBI__HDR_BUFLEN];
    char* token;
    int valid = 0;
    int dummy;

    if (!x) x = &dummy;
    if (!y) y = &dummy;
    if (!comp) comp = &dummy;

    if (stbi__hdr_test(s) == 0) {
        stbi__rewind(s);
        return 0;
    }

    for (;;) {
        token = stbi__hdr_gettoken(s, buffer);
        if (token[0] == 0) break;
        if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    }

    if (!valid) {
        stbi__rewind(s);
        return 0;
    }
    token = stbi__hdr_gettoken(s, buffer);
    if (strncmp(token, "-Y ", 3)) {
        stbi__rewind(s);
        return 0;
    }
    token += 3;
    *y = (int)strtol(token, &token, 10);
    while (*token == ' ') ++token;
    if (strncmp(token, "+X ", 3)) {
        stbi__rewind(s);
        return 0;
    }
    token += 3;
    *x = (int)strtol(token, NULL, 10);
    *comp = 3;
    return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context* s, int* x, int* y, int* comp)
{
    void* p;
    stbi__bmp_data info;

    info.all_a = 255;
    p = stbi__bmp_parse_header(s, &info);
    if (p == NULL) {
        stbi__rewind(s);
        return 0;
    }
    if (x) *x = s->img_x;
    if (y) *y = s->img_y;
    if (comp) {
        if (info.bpp == 24 && info.ma == 0xff000000)
            *comp = 3;
        else
            *comp = info.ma ? 4 : 3;
    }
    return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context* s, int* x, int* y, int* comp)
{
    int channelCount, dummy, depth;
    if (!x) x = &dummy;
    if (!y) y = &dummy;
    if (!comp) comp = &dummy;
    if (stbi__get32be(s) != 0x38425053) {
        stbi__rewind(s);
        return 0;
    }
    if (stbi__get16be(s) != 1) {
        stbi__rewind(s);
        return 0;
    }
    stbi__skip(s, 6);
    channelCount = stbi__get16be(s);
    if (channelCount < 0 || channelCount > 16) {
        stbi__rewind(s);
        return 0;
    }
    *y = stbi__get32be(s);
    *x = stbi__get32be(s);
    depth = stbi__get16be(s);
    if (depth != 8 && depth != 16) {
        stbi__rewind(s);
        return 0;
    }
    if (stbi__get16be(s) != 3) {
        stbi__rewind(s);
        return 0;
    }
    *comp = 4;
    return 1;
}

static int stbi__psd_is16(stbi__context* s)
{
    int channelCount, depth;
    if (stbi__get32be(s) != 0x38425053) {
        stbi__rewind(s);
        return 0;
    }
    if (stbi__get16be(s) != 1) {
        stbi__rewind(s);
        return 0;
    }
    stbi__skip(s, 6);
    channelCount = stbi__get16be(s);
    if (channelCount < 0 || channelCount > 16) {
        stbi__rewind(s);
        return 0;
    }
    STBI_NOTUSED(stbi__get32be(s));
    STBI_NOTUSED(stbi__get32be(s));
    depth = stbi__get16be(s);
    if (depth != 16) {
        stbi__rewind(s);
        return 0;
    }
    return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context* s, int* x, int* y, int* comp)
{
    int act_comp = 0, num_packets = 0, chained, dummy;
    stbi__pic_packet packets[10];

    if (!x) x = &dummy;
    if (!y) y = &dummy;
    if (!comp) comp = &dummy;

    if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {
        stbi__rewind(s);
        return 0;
    }

    stbi__skip(s, 88);

    *x = stbi__get16be(s);
    *y = stbi__get16be(s);
    if (stbi__at_eof(s)) {
        stbi__rewind(s);
        return 0;
    }
    if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {
        stbi__rewind(s);
        return 0;
    }

    stbi__skip(s, 8);

    do {
        stbi__pic_packet* packet;

        if (num_packets == sizeof(packets) / sizeof(packets[0]))
            return 0;

        packet = &packets[num_packets++];
        chained = stbi__get8(s);
        packet->size = stbi__get8(s);
        packet->type = stbi__get8(s);
        packet->channel = stbi__get8(s);
        act_comp |= packet->channel;

        if (stbi__at_eof(s)) {
            stbi__rewind(s);
            return 0;
        }
        if (packet->size != 8) {
            stbi__rewind(s);
            return 0;
        }
    } while (chained);

    *comp = (act_comp & 0x10 ? 4 : 3);

    return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context* s)
{
    char p, t;
    p = (char)stbi__get8(s);
    t = (char)stbi__get8(s);
    if (p != 'P' || (t != '5' && t != '6')) {
        stbi__rewind(s);
        return 0;
    }
    return 1;
}

static void* stbi__pnm_load(stbi__context* s, int* x, int* y, int* comp, int req_comp, stbi__result_info* ri)
{
    stbi_uc* out;
    STBI_NOTUSED(ri);

    ri->bits_per_channel = stbi__pnm_info(s, (int*)&s->img_x, (int*)&s->img_y, (int*)&s->img_n);
    if (ri->bits_per_channel == 0)
        return 0;

    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");
    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large", "Very large image (corrupt?)");

    *x = s->img_x;
    *y = s->img_y;
    if (comp) *comp = s->img_n;

    if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
        return stbi__errpuc("too large", "PNM too large");

    out = (stbi_uc*)stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
    if (!out) return stbi__errpuc("outofmem", "Out of memory");
    stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

    if (req_comp && req_comp != s->img_n) {
        out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
        if (out == NULL) return out; // stbi__convert_format frees input on failure
    }
    return out;
}

static int      stbi__pnm_isspace(char c)
{
    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context* s, char* c)
{
    for (;;) {
        while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
            *c = (char)stbi__get8(s);

        if (stbi__at_eof(s) || *c != '#')
            break;

        while (!stbi__at_eof(s) && *c != '\n' && *c != '\r')
            *c = (char)stbi__get8(s);
    }
}

static int      stbi__pnm_isdigit(char c)
{
    return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context* s, char* c)
{
    int value = 0;

    while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
        value = value * 10 + (*c - '0');
        *c = (char)stbi__get8(s);
    }

    return value;
}

static int      stbi__pnm_info(stbi__context* s, int* x, int* y, int* comp)
{
    int maxv, dummy;
    char c, p, t;

    if (!x) x = &dummy;
    if (!y) y = &dummy;
    if (!comp) comp = &dummy;

    stbi__rewind(s);

    // Get identifier
    p = (char)stbi__get8(s);
    t = (char)stbi__get8(s);
    if (p != 'P' || (t != '5' && t != '6')) {
        stbi__rewind(s);
        return 0;
    }

    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

    c = (char)stbi__get8(s);
    stbi__pnm_skip_whitespace(s, &c);

    *x = stbi__pnm_getinteger(s, &c); // read width
    stbi__pnm_skip_whitespace(s, &c);

    *y = stbi__pnm_getinteger(s, &c); // read height
    stbi__pnm_skip_whitespace(s, &c);

    maxv = stbi__pnm_getinteger(s, &c);  // read max value
    if (maxv > 65535)
        return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
    else if (maxv > 255)
        return 16;
    else
        return 8;
}

static int stbi__pnm_is16(stbi__context* s)
{
    if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
        return 1;
    return 0;
}
#endif

static int stbi__info_main(stbi__context* s, int* x, int* y, int* comp)
{
#ifndef STBI_NO_JPEG
    if (stbi__jpeg_info(s, x, y, comp)) return 1;
#endif

#ifndef STBI_NO_PNG
    if (stbi__png_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_GIF
    if (stbi__gif_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_BMP
    if (stbi__bmp_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PSD
    if (stbi__psd_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PIC
    if (stbi__pic_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_PNM
    if (stbi__pnm_info(s, x, y, comp))  return 1;
#endif

#ifndef STBI_NO_HDR
    if (stbi__hdr_info(s, x, y, comp))  return 1;
#endif

    // test tga last because it's a crappy test!
#ifndef STBI_NO_TGA
    if (stbi__tga_info(s, x, y, comp))
        return 1;
#endif
    return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context* s)
{
#ifndef STBI_NO_PNG
    if (stbi__png_is16(s))  return 1;
#endif

#ifndef STBI_NO_PSD
    if (stbi__psd_is16(s))  return 1;
#endif

#ifndef STBI_NO_PNM
    if (stbi__pnm_is16(s))  return 1;
#endif
    return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const* filename, int* x, int* y, int* comp)
{
    FILE* f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE* f, int* x, int* y, int* comp)
{
    int r;
    stbi__context s;
    long pos = ftell(f);
    stbi__start_file(&s, f);
    r = stbi__info_main(&s, x, y, comp);
    fseek(f, pos, SEEK_SET);
    return r;
}

STBIDEF int stbi_is_16_bit(char const* filename)
{
    FILE* f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE* f)
{
    int r;
    stbi__context s;
    long pos = ftell(f);
    stbi__start_file(&s, f);
    r = stbi__is_16_main(&s);
    fseek(f, pos, SEEK_SET);
    return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const* buffer, int len, int* x, int* y, int* comp)
{
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__info_main(&s, x, y, comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const* c, void* user, int* x, int* y, int* comp)
{
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);
    return stbi__info_main(&s, x, y, comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const* buffer, int len)
{
    stbi__context s;
    stbi__start_mem(&s, buffer, len);
    return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const* c, void* user)
{
    stbi__context s;
    stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);
    return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
"./Utils\\ThreadPool.h"
#pragma once
#include <thread>
#include <deque>
#include <vector>
#include <condition_variable>
#include <string>
#include <atomic>

#include "LogUtils.h"

/*
* Takes in a function (the func that the worker runs)
* Has a task scheduler and an output manager
* Can be fed in a templated input and it will provide an output
*/
// TODO: Add dynamic thread allocation (should be easy)
template <class TaskIn, class TaskOut, TaskOut (*Task)(const TaskIn&)>
class ThreadPool {
public:
    ThreadPool(size_t threads, std::string type, size_t batchSize = SIZE_MAX);
    ~ThreadPool();

    void Stop();

    void SubmitTask(const std::vector<TaskIn>& task);
    void SubmitTask(const TaskIn& task);

    std::vector<TaskOut> GetOutput();
    size_t GetQueueSize();
private:
    // Threads
    std::deque<std::thread> workers_;
    std::thread scheduler_;
    std::thread output_manager_;
    size_t worker_count_;

    // Condition Variables
    std::deque<std::condition_variable> worker_cv_;
    std::condition_variable scheduler_cv_;
    std::condition_variable output_cv_;
    bool stop_;
    bool output_ready_;

    // Mutex
    std::deque<std::mutex> workers_locks_;
    std::deque<std::mutex> workers_output_locks_;
    std::mutex scheduler_lock_;
    std::mutex output_lock_;
    std::string type_;

    // Task list
    std::vector<TaskIn> task_list_; // This stores all of the task to do
    std::vector<TaskOut> output_list_;
    std::vector<std::vector<TaskIn>> worker_task_;
    std::vector<std::vector<TaskOut>> worker_output_;
    size_t batch_size_;

    // Task Queued
    std::atomic<size_t> task_queued_;

    void Scheduler();
    void Worker(int workerId);
    void OutputManager();
};

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline ThreadPool<TaskIn, TaskOut, Task>::ThreadPool(size_t threads, std::string type, size_t batchSize) :
    workers_{ threads },
    scheduler_{ &ThreadPool::Scheduler, this },
    output_manager_{ &ThreadPool::OutputManager, this },
    worker_count_{ threads },
    worker_cv_{ threads },
    stop_{ false },
    output_ready_{ false },
    workers_locks_{ threads },
    workers_output_locks_{ threads },
    type_{ type },
    worker_task_{ threads },
    worker_output_{ threads },
    batch_size_{ batchSize },
    task_queued_{ 0 } {

    for (size_t i = 0; i < threads; ++i) {
        workers_[i] = std::thread(&ThreadPool::Worker, this, i);
    }
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline ThreadPool<TaskIn, TaskOut, Task>::~ThreadPool() {
    if (!stop_)
        Stop();
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::Scheduler() {
    g_logger.LogDebug("ThreadPool::Scheduler", type_ + " Thread Pool | Started task scheduler");

    std::vector<TaskIn> internalTaskList;

    while (!stop_) {
        {
            std::unique_lock<std::mutex> lock{ scheduler_lock_ };

            scheduler_cv_.wait_for(lock, std::chrono::milliseconds(100),
                [this]() { return !task_list_.empty() || stop_; });

            if (stop_) break;

            internalTaskList = std::move(task_list_);
            task_list_.clear();
        }


        // Evenly distribute the tasks
        size_t taskPerWorker = internalTaskList.size() / worker_count_;
        size_t taskPerWorkerRemainder = internalTaskList.size() % worker_count_;

        size_t currIndex = 0;

        for (size_t i = 0; !stop_ && i < worker_count_; ++i) {

            size_t taskCount = taskPerWorker;
            if (taskPerWorkerRemainder != 0) {
                taskCount += 1;
                --taskPerWorkerRemainder;
            }

            if (taskCount == 0) break;

            std::lock_guard<std::mutex> lock{ workers_locks_[i] };
            worker_task_[i].insert(worker_task_[i].end(),
                internalTaskList.begin() + currIndex,
                internalTaskList.begin() + taskCount + currIndex);

            currIndex += taskCount;

            worker_cv_[i].notify_one();
        }

        internalTaskList.clear();
    }

    g_logger.LogDebug("ThreadPool::Scheduler", type_ + " Thread Pool | Shutting down task scheduler");
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::Worker(int workerId) {
    g_logger.LogDebug("ThreadPool::Worker", type_ + " Thread Pool | Started worker " + std::to_string(workerId));
    bool workingOnBatch = false;
    size_t batchIndex = 0;
    std::vector<TaskIn> workerTasks;

    while (!stop_) {
        std::vector<TaskOut> output;

        // Collect task first
        if (!workingOnBatch) {
            std::unique_lock<std::mutex> lock{ workers_locks_[workerId] };
            worker_cv_[workerId].wait_for(lock, std::chrono::milliseconds(100),
                [this, workerId]() {return stop_ || !worker_task_[workerId].empty(); });
            if (stop_) break;
            workerTasks = std::move(worker_task_[workerId]);
            worker_task_[workerId].clear();
        }
        size_t i = batchIndex;
        for (; !stop_ && i < std::min(workerTasks.size(), batchIndex + batch_size_); ++i) {
            if (stop_) break;
            const TaskIn& task = workerTasks[i];
            TaskOut out = Task(task);
            output.push_back(std::move(out));
        }
        
        if (i == workerTasks.size()) {
            workerTasks.clear();
            workingOnBatch = false;
            batchIndex = 0;
        } else {
            batchIndex = i;
            workingOnBatch = true;
        }

        if (stop_) break;

        {
            std::lock_guard<std::mutex> lock{ workers_output_locks_[workerId] };
            worker_output_[workerId].insert(worker_output_[workerId].end(),
                std::make_move_iterator(output.begin()),
                std::make_move_iterator(output.end()));
        }

        {
            std::lock_guard<std::mutex> outputLock{ output_lock_ };
            output_ready_ = true;
            output_cv_.notify_one();
        }
        output.clear();

    }
    g_logger.LogDebug("ThreadPool::Worker", type_ + " Thread Pool | Shutting down worker " + std::to_string(workerId));
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::OutputManager() {
    g_logger.LogDebug("ThreadPool::Worker", type_ + " Thread Pool | Started output manager");
    while (!stop_) {
        // Waits for output
        {
            std::unique_lock<std::mutex> lock{ output_lock_ };
            output_cv_.wait_for(lock, std::chrono::milliseconds(100),
                [this]() {return output_ready_ || stop_;  });
            if (stop_) break;
            output_ready_ = false;
        }

        // Find workers output and manage them

        for (size_t i = 0; !stop_ && i < worker_count_; ++i) {
            std::vector<TaskOut> workerOut;
            {
                std::lock_guard<std::mutex> lock{ workers_output_locks_[i] };
                workerOut = std::move(worker_output_[i]);
                worker_output_[i].clear();
            }
            if (!workerOut.empty()) {
                std::lock_guard<std::mutex> lock{ output_lock_ };
                output_list_.insert(output_list_.end(),
                    std::make_move_iterator(workerOut.begin()),
                    std::make_move_iterator(workerOut.end()));
            }
        }
    }
    g_logger.LogDebug("ThreadPool::Worker", type_ + " Thread Pool | Shutting down output manager");
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::SubmitTask(const std::vector<TaskIn>& task) {
    std::lock_guard<std::mutex> lock{ scheduler_lock_ };
    task_queued_+=task.size();
    task_list_.insert(task_list_.end(), task.begin(), task.end());
    scheduler_cv_.notify_one();
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::SubmitTask(const TaskIn& task) {
    std::lock_guard<std::mutex> lock{ scheduler_lock_ };
    task_list_.push_back(task);
    scheduler_cv_.notify_one();
    task_queued_++;
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline std::vector<TaskOut> ThreadPool<TaskIn, TaskOut, Task>::GetOutput() {
    std::lock_guard<std::mutex> lock{ output_lock_ };
    std::vector<TaskOut> out = std::move(output_list_);
    task_queued_ -= out.size();
    return out;
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline void ThreadPool<TaskIn, TaskOut, Task>::Stop() {
    stop_ = true;
    scheduler_.join();
    output_manager_.join();

    for (size_t i = 0; i < worker_count_; ++i) {
        workers_[i].join();
    }
    worker_cv_.clear();
    workers_locks_.clear();
    workers_output_locks_.clear();
    type_.clear();
    task_list_.clear();
    output_list_.clear();
    worker_task_.clear();
    worker_output_.clear();
}

template <class TaskIn, class TaskOut, TaskOut(*Task)(const TaskIn&)>
inline size_t ThreadPool<TaskIn, TaskOut, Task>::GetQueueSize() {
    return task_queued_.load();
}
